[{"title":"10.hash","url":"/ypf-blog/2025/03/25/webpack4/10.hash/","content":"# 介绍\n在webpack中, 打包后可以有3种hash来配置文件名.`hash`,`chunkhash`,`contenthash`.\n我们来测试下这三种的区别:\n\n## hash\n> 打包后的所有文件都有相同的hash值,随便修改一个文件,所有文件的hash值都会变\n```js\n// webpack.config.js\nconst path = require(\"path\");\nmodule.exports = {\n  mode: \"production\", // development-开发 'production'打包模式 默认production, 开发模式tree-shaking不生效,production 模式默认会启用 TerserPlugin 来压缩代码\n  devtool: false, // 是否生成source map\n  entry: {\n    main:\"./src/index.js\",\n    vendor:[\"isarray\"]\n  },\n  output: {\n    // filename: \"bundle.js\", // 打包后的文件名\n    filename: \"[name].[hash:8].js\", // 打包后的文件名\n    path: path.resolve(__dirname, \"dist\"), // 输出路径(只能是绝对路径,不能是相对路径)\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          \"style-loader\", \n          \"css-loader\"\n        ],\n      },\n    ],\n  }\n};\n```\n- 上面我们配置2个入口,打包后,所有的文件都有`相同的hash`值.这里没有抽离css, 如果抽离也是和js一样的hash值. \n- **注意** 随便改一个文件,hash会全部重新更新为一样的新的hash值.如果`不改文件`,直接在此打包,`hash不会变`\n<img src=\"images/1.jpg\" width=\"50%\" height=\"50%\" />\n\n## chunkhash\n> 1. 不同的入口具有各自的hash值,要是提取css,其hash值也跟着入口来 如`page1.001js、page1.001.css`和`page2.002js、page2.002.css`\n> 2. 如果修改一个入口,只有修改的hash会变, 其他入口不变,这样可以更好的缓存\n上面代码我们修改为\n```js\nfilename: \"[name].[chunkhash:8].js\"\n```\n打包后我们会发现,2个入口有不同的hash值.\n<img src=\"images/2.jpg\" width=\"50%\" height=\"50%\" />\n\n## contenthash\n> 根据自身文件的内容来生成hash值,只要文件内容不变,hash值就不会变.\n\n上面chunkhash看起来实际应用不错,但是我们看到同一个入口的js和css因为是相同的hash值, 当我们只修改js,`不修改css`, 打包后会发现,`css的hash`值也跟着`变了`, 这样其实没有意义.\n我们提取css来测试下:\n```js\nconst path = require(\"path\");\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nmodule.exports = {\n  mode: \"production\", // development-开发 'production'打包模式 默认production, 开发模式tree-shaking不生效,production 模式默认会启用 TerserPlugin 来压缩代码\n  devtool: false, // 是否生成source map\n  entry: {\n    main:\"./src/index.js\",\n    vendor:[\"isarray\"]\n  },\n  output: {\n    // filename: \"bundle.js\", // 打包后的文件名\n    filename: \"[name].[chunkhash:8].js\", // 打包后的文件名\n    path: path.resolve(__dirname, \"dist\"), // 输出路径(只能是绝对路径,不能是相对路径)\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // \"style-loader\", \n          MiniCssExtractPlugin.loader,\n          \"css-loader\"\n        ],\n      },\n    ],\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: \"[name].[contenthash:8].css\",\n    }),\n  ],\n};\n```\n<img src=\"images/3.jpg\" width=\"50%\" height=\"50%\" />\n我们可以看到css是单独的hash,当修改入口js,css的hash值不会变.\n\n# 总结\n- hash: 所有文件hash值都一样, 随便修改一个文件,所有文件的hash值都会重新变成一样的\n- chunkhash: 不同入口具有不同的hash值\n- contenthash: 根据文件内容来生成hash值,文件内容不变,hash值不会变\n- 所有css我们用contenthash、js用chunkhash,可以做到精确的缓存\n注意,如果不修改文件再次打包,hash不会变, 只有修改文件才会按照上面3种规则来重新生成.\n\n\n\n  ","categories":["webpack4"]},{"title":"9.treeshaking","url":"/ypf-blog/2025/03/21/webpack4/9.treeshaking/","content":"# 什么是treeshaking?\n- 中文即摇树,即摇掉多余的代码(死代码). 最初是由rollup实现,后来webpack自2.0开始实现.\n- treeshaking是基于`ESModule`进行`静态分析导入导出`, 确定模块中哪些导出值`未`曾被其它模块`使用`,然后`删除掉`\n- 不能处理commonjs动态执行的情况.\n\n# 配置\n```js\nmodule.exports = {\n  mode: \"production\" // 默认就是production, \n}\n// 或者\nmodule.exports = {\n  mode: \"development\" ,\n  optimization:{\n    // minimize: false, // 压缩\n    usedExports: true, // 启用 Tree Shaking标记功能(只有mode=development才会看到标记)\n  },\n}\n```\n- webpack会在打包过程中,使用`usedExports`对要剔除的代码进行`先标记`,然后通过Terser插件进行`后剔除`\n<img src=\"images/1.jpg\" width=\"50%\" height=\"50%\" />\n- 实际测试,在开发模式下,只会看到部分代码标记,有些没用的代码没有被标记,但是生产模式剔除掉了.所以还是建议直接生产模式看\n\n# 场景\n```js\n// functions.js\n// 保留\nfunction add() {console.log(\"add\")}\n// 被剔除,没用到\nfunction sub() {console.log(\"sub\")}\n// 被剔除,虽被引用但没用到\nfunction mul() {console.log(\"mul\")}\n// 被剔除,没用到(测试就算export了,也会被剔除掉)\nfunction div() {console.log(\"div\");}\n// 引入就执行,保留\nconsole.log(\"func\");\nexport {add,sub,mul}\n\n// index.js\nimport { add,sub,mul } from './functions';\nadd(1,2); \nconst a= mul \nimport './common.js' // 没有被剔除\nimport './index.css' // 没有被剔除\n```\n我们可以看到\n- 默认全局js、css、直接执行语句都会被保留\n- 导入模块如果重新赋值但未使用也会被剔除\n- 未导出或者导出但未使用也会被剔除\n\n默认webpack会认为当前项目有副作用, 我们可以通过在`package.json`中配置`sideEffects`来告诉webpack当前项目无副作用,从而来控制treeshaking.\n## sideEffects(副作用)\n### 有副作用\n```js\n// package.json\n{\n\"sideEffects\": true, \n}\n```\n测试结果就是上面的场景,说明webpack默认项目有副作用,但会自动剔除一些没用的代码.\n### 无副作用\n```js\n// package.json\n{\n\"sideEffects\": false, \n}\n```\n- 全局js、css被剔除\n- 只有导入模块被使用和直接执行语句被保留\n- 其他未使用或重新赋值未使用被剔除\n\n### 指定文件副作用\n```js\n// package.json\n{\n  \"sideEffects\": [\n    './src/common.js'\n  ]\n}\n```\n- common.js会被保留, css被剔除\n- 未使用或重新赋值未使用被剔除\n- 使用的会被保留\n\n### 在loader配置sideEffects\n```js\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\"style-loader\", \"css-loader\"],\n        sideEffects: true  // 会保留全局css\n      }\n    ]\n  }\n}\n```\n- 此时所有css文件都默认有副作用, 会保留\n\n### babel-loader\n我们知道treeshaking是基于`ESModule`进行静态分析的, 我们在用babel处理js的时候,Babel可以将 import/export 风格的 ESM 语句等价转译为 CommonJS 风格的模块化语句,所以要`关掉`.\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: \"babel-loader\",\n            options: {\n              presets: [\n                [\n                  \"@babel/preset-env\",\n                  {\n                    modules: false, // 保留ES模块不转换,告诉babel不要转换\n                  },\n                ],\n              ],\n            },\n          }\n        ],\n      }\n    ]\n  }\n}\n```\n- 测试babel7版本,默认modules就是false,可以选 `commonjs|cjs|amd|umd|false`等\n- 只是在Babel编译环节编译禁止处理es，后面最终webpack转换仍为commonjs\n\n### `#pure`标注\n```js\nfunction test(){\n  console.log('test')\n}\nfunction test1(){\n  console.log('test1')\n}\n/*#__PURE__*/ test() // 会被剔除\n/*#__PURE__*/\ntest()  // 会被剔除\ntest1() // 不会被剔除\n```\n- 经`/*#__PURE__*/`标注的代码会被剔除\n\n### 支持treeshaking的包\n如果可以的话，应尽量使用支持 Tree Shaking 的 npm 包，例如：\n- 使用 `lodash-es` 替代 `lodash` ，或者使用 `babel-plugin-lodash` 实现类似效果\n<img src=\"images/2.jpg\" width=\"50%\" height=\"50%\" />\n<img src=\"images/3.jpg\" width=\"50%\" height=\"50%\" />\n\n## 总结\n- package.json\n  - 如果默认(有副作用),`全局文件和使用`到会保留,其他剔除\n  - 如果设置无副作用, 那么只有使用到的会保留,其他包括全局文件会被剔除\n  - 如果指定文件,那么只有指定文件和使用到的会保留,其他被剔除\n- `loader`中配置副作用, 文件会被保留\n- babel处理js,要关掉处理es\n- 经过`/*#__PURE__*/`标注的代码(同一行或下一行), 会被剔除\n- 尽量使用支持treeshaking的包,如`lodash-es`\n\n# 原理\nWebpack 在编译时会进行以下步骤：\n- **收集所有导出**：分析每个模块的 export 语句，记录所有导出的变量/函数。 注意,必须是es模块(`import/export`，而非`require`)\n- **追踪导入并使用**：从入口文件开始，记录哪些导出被import并分析哪些导入`被实际使用`（例如被调用、赋值等）。\n- **标记未使用的导出**：未被任何模块导入或导入后未被实际使用的导出会被标记为 `/* unused harmony export */`。\n- **剔除未使用的导出**：通过 Terser 插件对代码进行压缩，剔除标记为 `/* unused harmony export */` 的导出。\n\n那么如何判断import后是否被实际使用呢？\n- 直接调用（如 foo()）、属性访问（如 obj.key）、逻辑运算等会被视为使用。\n- 仅导入但未操作（如 import { foo } from 'bar' 后未调用 foo）会被标记为未使用。\n实际Webpack 在编译阶段会将代码解析为 抽象语法树（AST），然后遍历 AST 节点，分析变量的引用关系。具体判断逻辑如下：\n```js\nimport { foo } from './module';\nfoo(); // ✅ 明确调用 → 已使用\n```\nAST分析：\nWebpack 会识别 CallExpression 节点，并检查其调用的函数名是否`匹配导入`的变量（foo）。\n总之,就是会判断`各种ast节点`并匹配`导入的变量`来判断`是否被使用`.\n","categories":["webpack4"]},{"title":"8.split代码分割","url":"/ypf-blog/2025/03/06/webpack4/8.split代码分割/","content":"# SplitChunksPlugin\n[SplitChunksPlugin](https://www.webpackjs.com/plugins/split-chunks-plugin/#splitchunksmaxasyncrequests) 是webapck的内置插件，用于分离优化代码,提取公共代码防止被重复打包.\n> 先来举个例子,webpack设置中有3个入口文件：`a.js、b.js 和 c.js`,每个入口都引入了`common.js`,如果不设置splitChunks, 此时打包结果是, 3个入口`都包含common.js`, 那么就会导致common.js重复引入, 影响性能。\n# 配置\nwebpack通过`optimization`(英文最优化)来进行代码优化.\n## 基本配置\n```js\n// webpack.config.js\noptimization: {\n  splitChunks: {\n    // 要分隔什么类型的代码块, 默认async异步\n    // all-代表所有代码块, async-异步代码块(import(xx)), initial-同步代码块(require(xx)/import x from xx), \n    chunks: \"all\",\n\n    // 要生成chunk的最小体积, 默认20000bytes即20kb\n    // 超过该值才会分隔.如page1、page2都依赖title1、title2, 那么如果title1+title2>=minSize, webpack会自动分割出一个page1~page2.js(title1、title2)\n    minSize: 0,  // 推荐用默认20k\n\n    // 设置拆分代码块的名称\n    // true-分隔符连接的原始代码块.默认~, 比如page1、page2都依赖title,title生成的chunk名就是 page1~page2.js\n    // false-title生成的是0.js这种文件名\n    name: true,\n\n    // 设置分隔出的chunk的分隔符,默认~\n    // 比如page1、page2都依赖title,生成的chunk名就是 page1~page2.js(里面是title模块)\n    automaticNameDelimiter: \"~\",\n\n    // 缓存组\n    cacheGroups: {\n      // 第三方库抽离,如果没有name, libs可以改成任意名字,比如aa, 打包生成的名字就是aa.js\n      libs: {\n        name: 'chunk-libs',\n        test: /[\\\\/]node_modules[\\\\/]/,\n        priority: 10,  //权重, 越高的权重, 会优先按此规则抽离\n      },\n      // elementUI组件库单独打包\n      elementUI: {\n        name: 'chunk-elementUI', // split elementUI into a single package\n        priority: 20, // the weight needs to be larger than libs and app or it will be packaged into libs or app\n        test: /[\\\\/]node_modules[\\\\/]_?element-ui(.*)/, // in order to adapt to cnpm\n      },\n      // 公共模块抽离,如果没有name,可以改成任意名字,比如common1, 打包生成的名字就是common1.js\n      commons: {\n        name: 'chunk-commons',\n        test: resolve('src'), // can customize your rules\n        minChunks: 2, // 在分割之前，这个代码块最小应该被引用的次数\n        priority: 5,\n        reuseExistingChunk: true, // 重用已存在的代码块, 测试没效果不知道为啥\n      },\n    },\n\n    maxInitialRequests:30,\n    maxAsyncRequests:30,\n    runtimeChunk: true,\n  },\n},\n```\n我们来举个例子看下,4个文件内容如下:\n```js\n// page1.js\nrequire(\"./module1\");\nrequire(\"./module2\");\nrequire(\"jquery\");\nimport(/* webpackChunkName: \"asyncModule1\" */\"./asyncModule1\");\n```\n```js\n// page2.js\nrequire(\"./module1\");\nrequire(\"./module2\");\nrequire('jquery')\n```\n```js\n// page3.js\nrequire(\"./module1\");\nrequire(\"./module3\");\nrequire('jquery')\n```\n```js\n// asyncModule1.js\nrequire('lodash')\n```\n```js\n// 打包前\npage1- module1、module2、jquery、asyncModule1\npage2- module1、module2、jquery\npage3- module1、module3、jquery\nasyncModule1- lodash\n\n// 打包生成的文件如下:\npage1\npage2\npage3\nasyncModule1\ncommons~page1~page2~page3(module1)\ncommons~page1~page2(module2)\nlibs~page1~page2~page3(jquery)\nlibs~asyncModule1(lodash)\n```\n所以编译规则是:\n1. page1、2、3都依赖jquery, 所以生成`libs~page1~page2~page3(jquery)`\n2. page1、2、3都依赖module1, 所以生成`commons~page1~page2~page3(module1)`\n3. page1、2依赖module2, 所以生成`commons~page1~page2(module2)`\n4. `异步`模块asyncModule1\n5. 异步模块asyncModule1依赖lodash, 所以生成`libs~asyncModule1(lodash)`\n6. page1、2、3`各自`生成自己的chunk\n\n## maxInitialRequests\n> 打包后的`入口文件`加载时，还能同时加载js文件的数量, 包含自己,import() 异步加载不算在内. 默认30\n上面的例子当我们设置`maxInitialRequests:1`,生成文件如下\n```js\npage1(module1、module2、jquery、asyncModule1)\npage2(module1、module2、jquery)\npage3(module1、module3、jquery)\nasyncModule1\nlibs~asyncModule1(lodash)\n```\n上面设置为1, 入口文件肯定默认分离1个,就导致其他模块不会分离导致`重复.` 如果设置2,权重高的优先分离,超过2个,权重低的就不会被分离了.\n## maxAsyncRequests\n> 限制`异步模块中`的最大并发请求数,包含自己, 默认30\n当同时设置`maxAsyncRequests:1`时, 生成的文件如下:\n```js\npage1(module1、module2、jquery、asyncModule1)\npage2(module1、module2、jquery)\npage3(module1、module3、jquery)\nasyncModule1(lodash)\n```\n该参数表示从异步的模块中引用的模块被分离的个数.设置过低和上面一样,也会导致重复.\n\n## runtimeChunk\n默认false.\nwebpack默认打包后的入口js都会包含一个`自执行函数`和`参数依赖模块对象`. 如果我们更改依赖模块,入口js每次都会重新生成. 这样会存在缓存失效的问题. 实际我们只修改模块,只是模块变了,自执行函数永远都不变,可以缓存住.\n所以:\n设置`runtimeChunk: true`,原先的3个入口page1、2、3会多出3个·runtime~page1、runtime~page2、runtime~page3`文件.\n - runtime文件只有自执行函数,参数是空的不包含模块.\n - page文件是模块信息,并且多了个runtime模块\n - 所以修改模块,runtime文件不会变,不会重新生成可以缓存.page会重新生成.\n<img src=\"images/1.jpg\" width=\"50%\" height=\"50%\" />\n<img src=\"images/2.jpg\" width=\"50%\" height=\"50%\" />\n\n## runtimeChunk和runtimeCompiler\n看到runtime,以为这两个是类似的配置,其实不是, 这两个完全不一样.\n- runtimeChunk: webpack的配置,用于优化 Webpack 打包，`分离运行时代码`，与业务代码分离,提升`缓存`利用率\n- runtimeCompiler: 用于vue编译的配置. 表示是否使用`包含`运行时`编译器`的 Vue 构建版本。默认值false.设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右.\n在vue中,有2中运行模式:\n1. runtime-only\nrender --> vDom --> UI\n我们一般通过vue-cli的`vue-loader`将.vue编译,然后通过`vue-template-compiler`编译template为render函数,这个是编译的时候做的,所以打包出来的只包含运行时的 Vue.js 代码(render)，所以代码体积会更轻量。\n\n2. runtime-compiler\ntemplate --> ast --> render --> vDom --> UI\n打包出的包含`template --> ast --> render`编译器代码,在运行时才去编译template为render,所以代码更大. \n\n### 总结\n一般我们如果使用 .vue文件或者直接render,就不需要含编译器的代码,直接使用`runtime-only`\n```js\nnew Vue({\n  el : '#app',\n  render: h => h(App),\n})\n```\n如果需要用到模版编译即`动态使用模版`,就需要用`runtime-compiler`\n```js\nnew Vue({\n  el : '#app',\n  template:  '<div>{{ message }}</div>',\n})\n```\n- runtime-only： template在项目打包的时候，就已经编译为 render函数\n- runtime-compiler： 在运行的时候，才去编译 template为render函数\n\n\n# 配置总结\n- 分割的场景: 多入口自动分割、异步模块自动分割、自己手动切割\n- 一般可以设置三种规则:\n  - 为第`三方模块`配置规则(`node_modules`)单独抽离一个包\n  - 为`自己项目`中的模块配置规则(`minChunks=2最少被引用2次`)单独抽离一个包,权重比三方模块低的话,会优先到三方模块中\n  - 类似elementUI比较`大的包`设置比第三方规则权重高来单独抽离一个包\n- `maxInitialRequests`和`maxAsyncRequests`默认就是30可以不传.如果传的数字太小就会出现上面例子,包不会被抽离,导致包重复.\n- `runtimeChunk`可以将入口中的`自执行函数抽离`到一个runtime文件,里面只有自执行函数,没有模块信息. `入口只剩下模块信息`并多依赖一个runtime. 这样每次模块变更,只会更新入口文件,runtime不会重新生成可以一直缓存. 注意只会影响入口文件,不会影响其他规则文件.\n- runtimeChunk: webpack的配置,用于优化 Webpack 打包，`分离运行时代码`，与业务代码分离,提升`缓存`利用率\n- runtime-only：vue的配置, template在项目打包的时候，就已经编译为 render函数\n- runtime-compiler：vue的配置, 在运行的时候，才去编译 template\n\n# 分割后加载原理\n我们前面讲过,`import(xx)`异步加载实际是动态创建script引入js文件,但手动分割的包不会创建script,而需要`手动引入`.\n举个例子:\n```js\n// 2个入口\n// home.js\nconst title=require('./title')\nconsole.log(title);\n// login.js\nconst title=require('./title')\nconsole.log(title);\n\n// title.js\nmodule.exports=\"title\"\n```\n经过上面缓存组配置进行分割,结果为\n```js\nhome.js\nlogin.js\ncommons~home~login.js(title)\n```\n我们如果要在index.html使用`home.js`, 同时还需要引入`commons~home~login.js`才可以.那么谁先谁后呢?正常是依赖文件先,但webpack已经兼容,结论是`都可以`. \n我们先看下代码:\n```js [toggle]\n// commons~home~login.js\n(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([\n  [\"commons~home~login\"],\n  {\n    \"./src3/title.js\": function (module, exports) {\n      module.exports = \"title\";\n    },\n  },\n]);\n```\n```js [toggle]\n// home.js 精简代码\n(function (modules) {\n  function webpackJsonpCallback(data) {\n    var chunkIds = data[0];\n    var moreModules = data[1];\n    var executeModules = data[2];\n    var moduleId,\n      chunkId,\n      i = 0,\n      resolves = [];\n    for (; i < chunkIds.length; i++) {\n      chunkId = chunkIds[i];\n      if (\n        Object.prototype.hasOwnProperty.call(installedChunks, chunkId) &&\n        installedChunks[chunkId]\n      ) {\n        resolves.push(installedChunks[chunkId][0]);\n      }\n      installedChunks[chunkId] = 0;\n    }\n    for (moduleId in moreModules) {\n      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n        modules[moduleId] = moreModules[moduleId];\n      }\n    }\n\n    while (resolves.length) {\n      resolves.shift()();\n    }\n\n    // add entry modules from loaded chunk to deferred list\n    deferredModules.push.apply(deferredModules, executeModules || []);\n\n    // run deferred modules when all chunks ready\n    return checkDeferredModules();\n  }\n  function checkDeferredModules() {\n    var result;\n    for (var i = 0; i < deferredModules.length; i++) {\n      var deferredModule = deferredModules[i];\n      var fulfilled = true;\n      for (var j = 1; j < deferredModule.length; j++) {\n        var depId = deferredModule[j];\n        if (installedChunks[depId] !== 0) fulfilled = false;\n      }\n      if (fulfilled) {\n        deferredModules.splice(i--, 1); // 删除已经加载的模块\n        result = __webpack_require__(\n          (__webpack_require__.s = deferredModule[0])\n        );\n      }\n    }\n    return result;\n  }\n  function __webpack_require__(moduleId) {\n    // Check if module is in cache\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    var module = (installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {},\n    });\n\n    // Execute the module function\n    modules[moduleId].call(\n      module.exports,\n      module,\n      module.exports,\n      __webpack_require__\n    );\n\n    // Flag the module as loaded\n    module.l = true;\n\n    // Return the exports of the module\n    return module.exports;\n  }\n  var installedModules = {};\n  var installedChunks = {\n    home: 0,\n  };\n  var deferredModules = [];\n  var jsonpArray = (window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []);\n  jsonpArray.push = webpackJsonpCallback; // 重写push方法\n  for (var i = 0; i < jsonpArray.length; i++) {\n    webpackJsonpCallback(jsonpArray[i]);\n  }\n  // 第一个是入口模块,后面都是入口的依赖模块\n  deferredModules.push([\"./src3/home.js\", \"commons~home~login\"]);\n  // 检查依赖模块是否加载完毕\n  return checkDeferredModules();\n})({\n  \"./src3/home.js\": function (module, exports, __webpack_require__) {\n    const title = __webpack_require__(/*! ./title */ \"./src3/title.js\");\n    console.log(title);\n  },\n});\n```\n## 主文件先,依赖文件后\n```html\n<script src=\"home.js\"></script>\n<script src=\"commons~home~login.js\"></script>\n```\n我们理一下逻辑:\n1. 之前我们讲过主文件,自执行函数是从入口开始加载的\n<img src=\"images/3.jpg\" width=\"50%\" height=\"50%\" />\n\n而拆分过模块的主文件,`不是`从`入口`开始,而是从 **检查依赖模块是否加载完毕函数** 开始\n```js\nreturn checkDeferredModules()\n```\n2. `checkDeferredModules`函数主要用来循环入口拆分出的依赖模块数组,默认定义变量`fulfilled=true`表示依赖是否完全加载完毕\n  - 如果依赖没有加载完毕(installedChunks[xx]!==0),修改标志`fulfilled=false`并结束`return undefined`;\n  - 如果依赖加载完毕(installedChunks[xx]==0),`return  __webpack_require__(主入口)`开始执行主入口内容.\n3. 此时主文件执行完毕,加载我们引入的依赖文件, 代码很简单就是调用`window[\"webpackJsonp\"].push`塞入模块内容. 我们之前讲异步模块的时候,讲过webpack会在window绑定桥函数供异步模块加载完毕后调用.\n - 注意⚠️异步模块是webpack直接创建script来加载依赖, 结束调用桥函数塞入依赖内容,而拆分模块是自己引入的脚本,当加载脚本时,调用桥就表示加载结束了\n<img src=\"images/4.jpg\" width=\"50%\" height=\"50%\" />\n4. 调用桥函数,会`installedChunks[chunkId] = 0`表示模块加载结束, 此时有个**重要区别!!!**\n - 异步默认桥函数没有返回值,而拆分模块,桥函数`return checkDeferredModules`重新检查依赖加载是否完毕\n5. 重复第2步, 循环依赖数组,发现依赖都加载完毕(installedChunks[xx]==0), 返回入口代码执行.\n\n## 依赖文件先,主文件后\n```html\n<script src=\"commons~home~login.js\"></script>\n<script src=\"home.js\"></script>\n```\n我们理一下逻辑:\n1. 先加载依赖文件, 通过桥函数塞入依赖模块代码信息\n2. 加载主文件, **关键点**\n```js\n  // 先取出依赖模块数组\n  var jsonpArray = (window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []);\n  // 再重写push为桥函数, 所以先加载的依赖模块调用的push就是数组的push方法,不是桥函数\n  jsonpArray.push = webpackJsonpCallback; // 重写push方法\n  // 循环依赖数组,直接调用桥函数,此时依赖默认都加载完毕了, installedChunks[chunkId] = 0\n  for (var i = 0; i < jsonpArray.length; i++) {\n    webpackJsonpCallback(jsonpArray[i]);\n  }\n```\n3. 主文件执行`return checkDeferredModules`, 循环依赖数组,发现依赖都加载完毕(installedChunks[xx]==0), `最后返回入口代码执行`.\n\n# 分割加载原理总结\n1. 正常依赖模块要先加载,主文件后加载,但是webpack已经处理兼容顺序,`谁先引入都可以`\n2. 如果是主文件先加载\n - 加载主文件, 循环依赖模块,通过`checkDeferredModules`函数检查依赖模块是否加载完毕,如果加载完毕,返回主文件代码执行,否则结束`return undefined`;\n - 加载依赖文件, 调用桥函数塞入依赖,此时依赖模块加载完毕, 桥函数`return checkDeferredModules`再次检查,发现依赖加载完毕, 返回主入口代码`return  __webpack_require__(主入口)`\n3. 如果是依赖文件先加载\n - 加载依赖文件,调用原生的push方法塞入依赖模块代码\n - 加载主文件,先取出依赖模块数组,再重写push为桥函数,然后将取出来依赖数组直接循环执行桥函数.最后 `return checkDeferredModules`进行检查,此时发现依赖模块都已经先加载完毕了,返回主入口直接执行\n ## 注意⚠️\n - 之前讲的异步模块(`import(xx)`)是webpack`自动创建script`来加载依赖,加载结束后再调用桥函数塞入依赖内容.\n - 而拆分模块是需要`自己引入脚本`,当加载脚本时,执行到调用桥push就就会触发模块加载完毕(installedChunks[xx]=0)\n - 主入口先加载, 依赖后加载调用的push是桥函数; 而依赖先加载,调用的push是原生数组的push方法,执行到主入口,再重写push为桥函数,然后将取出来依赖数组直接循环执行桥函数","categories":["webpack4"]},{"title":"6.手写webpack","url":"/ypf-blog/2025/02/07/webpack4/6.手写webpack/","content":"# 手写代码\n## webpack.js\n```js [toggle]\nlet Compiler = require(\"./Compiler\");\nlet fs = require(\"fs\");\nconst webpack = (options, callback) => {\n  let compiler = new Compiler(options.context); // 创建compiler实例\n  compiler.options = options; // 给compiler实例挂载options\n  // 设置文件环境, 如node环境, 给compiler实例挂载fs进行读写文件(webpack会自定义fs进行增强)\n  compiler.inputFileSystem = fs; // 读文件\n  compiler.outputFileSystem = fs; // 写文件\n  // 挂载配置文件的plugins\n  if (options.plugins && Array.isArray(options.plugins)) {\n    options.plugins.forEach((plugin) => {\n      plugin.apply(compiler); // 调用插件apply方法进行初始化\n    });\n  }\n  // environment 准备好之后\n  compiler.hooks.environment.call();\n  // environment 安装完成之后\n  compiler.hooks.afterEnvironment.call();\n  // 挂载webpack各种内置插件\n  // 注册入口插件(解析入口)\n  // 1.注册入口hook\n  compiler.hooks.entryOption.tap(\"EntryOptionPlugin\", (context, entry) => {\n    if (Array.isArray(entry)) {\n      // 多入口\n      // new MultiEntryPlugin(context, entry, \"main\").apply(compiler);\n    } else {\n      // 单入口\n      // new SingleEntryPlugin(context, entry, \"main\").apply(compiler);\n      compiler.hooks.make.tapAsync(\n        \"SingleEntryPlugin\",\n        (compilation, callback) => {\n          // 从此开始编译入口以及入口的依赖\n          compilation.addEntry(context, entry, \"main\",false, callback);\n        }\n      );\n    }\n  });\n  // 2.触发入口插件\n  // context: 当前工作目录(如npm run build所在绝对路径目录)\n  // entry:入口文件, 如 ./src/index.js\n  compiler.hooks.entryOption.call(compiler.context, options.entry);\n  return compiler;\n};\nexports = module.exports = webpack;\n```\n## Compiler.js\n```js [toggle]\nconst {\n  Tapable,\n  SyncHook,\n  SyncBailHook,\n  AsyncParallelHook,\n  AsyncSeriesHook,\n} = require(\"tapable\");\nconst path = require(\"path\");\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\nconst Compilation = require(\"./Compilation\");\nconst mkdirp = require(\"mkdirp\"); // 递归创建目录\nclass Compiler extends Tapable {\n  constructor(context) {\n    super();\n    this.context = context;\n    // 各种hook\n    this.hooks = {\n      entryOption: new SyncBailHook([\"context\", \"entry\"]), // 在 webpack 选项中的 entry 配置项 处理过之后触发\n      beforeRun: new AsyncSeriesHook([\"compiler\"]), // 运行前\n      run: new AsyncSeriesHook([\"compiler\"]), // 运行\n      beforeCompile: new AsyncSeriesHook([\"params\"]), // 编译前\n      compile: new SyncHook([\"params\"]), // 编译\n      make: new AsyncParallelHook([\"compilation\"]), // make构建\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]), // 开始一次新的编译, 开始创建compilation对象\n      compilation: new SyncHook([\"compilation\", \"params\"]), // compilation对象创建完成\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]), //  创建普通模块工厂完成\n      afterCompile: new AsyncSeriesHook([\"compilation\"]), // 编译完成\n      emit: new AsyncSeriesHook([\"compilation\"]), // 英文发射: 此时开始写硬盘了(chunk生成文件)\n      done: new AsyncSeriesHook([\"stats\"]), // 所有的编译全部完成\n      // ...\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n      /** @type {SyncHook} */\n      environment: new SyncHook([]),\n      /** @type {SyncHook} */\n      afterEnvironment: new SyncHook([]),\n    };\n  }\n  // 开始\n  run(callback) {\n    console.log(\"开始run\");\n    this.hooks.beforeRun.callAsync(this, (err) => {\n      this.hooks.run.callAsync(this, (err) => {\n        // 在创建comilation之前已经创建了一个普通模块工厂\n        const normalModuleFactory = new NormalModuleFactory();\n        this.hooks.normalModuleFactory.call(normalModuleFactory);\n        const params = {\n          normalModuleFactory,\n        };\n        this.hooks.beforeCompile.callAsync(params, (err) => {\n          console.log(\"开始编译compile\");\n          this.hooks.compile.call(params);\n          const compilation = new Compilation(this); // this就是compiler实例\n          this.hooks.thisCompilation.call(compilation, params);\n          this.hooks.compilation.call(compilation, params);\n          this.hooks.make.callAsync(compilation, (err) => {\n            console.log(\"make执行完成\");\n            compilation.seal((err) => {\n              console.log(\"seal封装执行完成\");\n              // 封装代码完成才会编译完成, 触发afterCompile编译完成钩子\n              this.hooks.afterCompile.callAsync(compilation, (err) => {\n                console.log(\"afterCompile执行完成\");\n                // emit写插件用的最多, 因为此时开始写硬盘了, 这是修改的最后一步\n                this.hooks.emit.callAsync(compilation, (err) => {\n                  console.log(\"emit执行完成\");\n                  // 创建打包目录\n                  mkdirp(this.options.output.path, () => {\n                    const assets = compilation.assets;\n                    let outputPath = this.options.output.path;\n                    for (let file in assets) {\n                      let source = assets[file];\n                      let filePath = path.posix.join(outputPath, file);\n                      this.outputFileSystem.writeFileSync(\n                        filePath,\n                        source,\n                        \"utf-8\"\n                      );\n                    }\n                    // 编译完成回调\n                    const stats = new Stats(compilation);\n                    this.hooks.done.callAsync(stats, (err) => {\n                      console.log(\"done执行完成\");\n                      callback(err, stats);\n                    });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  }\n}\n// Stats英文:统计\nclass Stats {\n  constructor(compilation) {\n    this.entries = compilation.entries; // 所有入口模块\n    this.modules = compilation.modules; // 所有模块\n    this.chunks = compilation.chunks; // 所有的chunk\n    this.files = compilation.files; // 所有的输出文件名\n  }\n  toJson() {\n    return this;\n  }\n}\nmodule.exports = Compiler;\n```\n## Compilation.js\n```js [toggle]\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\nconst async = require(\"neo-async\");\nconst path = require(\"path\");\nconst ejs = require(\"ejs\");\nconst fs = require(\"fs\");\nconst mainTemplate = fs.readFileSync(\n  path.resolve(__dirname, \"templates/main.ejs\"),\n  \"utf-8\"\n);\nconst mainRender = ejs.compile(mainTemplate);\nconst chunkTemplate = fs.readFileSync(\n  path.resolve(__dirname, \"templates/chunk.ejs\"),\n  \"utf-8\"\n);\nconst chunkRender = ejs.compile(chunkTemplate);\nconst {\n  Tapable,\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  AsyncSeriesHook,\n} = require(\"tapable\");\nclass Compilation extends Tapable {\n  constructor(compiler) {\n    super();\n    this.compiler = compiler;\n    this.options = compiler.options;\n    this.context = compiler.context;\n    this.inputFileSystem = compiler.inputFileSystem; // 读文件fs\n    this.outputFileSystem = compiler.outputFileSystem; // 写文件fs\n    this.entries = []; // 入口数组. 只有入口模块\n    this.modules = []; // 模块数组(所有模块,比如入口依赖另一个, 就是入口模块、依赖模块)\n    this.chunks = []; // 最终生成的所有chunk\n    this.files = []; // 最终生成的所有chunk文件名\n    this.assets = {}; // 用于最终生成所有chunk的文件信息\n    this.hooks = {\n      // 成功构建完成一个模块后,就会触发这个钩子\n      succeedModule: new SyncHook([\"module\"]),\n      seal: new SyncHook(), // 开始封装\n      beforeChunks: new SyncHook(), // 封装代码块之前\n      afterChunks: new SyncHook(), // 封装代码块之后\n    };\n  }\n  /**\n   * 开始编译一个新的入口\n   * @param {*} context   上下文绝对路径\n   * @param {*} entry     入口文件 如 ./src/index.js\n   * @param {*} name      入口名称\n   * @param {*} callback  回调函数(入口和它所有的依赖模块都构建完成后,就会调用这个回调函数)\n   */\n  addEntry(context, entry, name, async, callback) {\n    this.createModule(\n      {\n        name, // main\n        context, // 上下文\n        rawRequest: entry, // 模块相对路径 ./src/index.js\n        resource: path.join(context, entry), // 模块绝对路径\n        moduleId: entry,\n        async,\n      },\n      (entryModule) => {\n        this.entries.push(entryModule);\n      },\n      callback\n    );\n  }\n  createModule(data, addEntryFn, callback) {\n    // 通过模块工厂创建一个模块\n    let module = new NormalModuleFactory(data);\n    if (addEntryFn) {\n      // 如果是入口模块,添加到入口数组中\n      addEntryFn(module);\n    }\n    this.modules.push(module);\n    // 编译模块\n    module.build(this, (err, module) => {\n      // console.log(\"成功编译一个模块\", module);\n      this.hooks.succeedModule.call(module);\n      //    说明该模块有依赖\n      if (module.dependencies.length > 0) {\n        this.processDependencies(module, (err) => {\n          callback(err, module);\n        });\n      } else {\n        callback(err, module);\n      }\n    });\n  }\n\n  /**\n   * 处理依赖\n   * @param {*} module\n   * @param {*} callback\n   */\n  processDependencies(module, callback) {\n    const dependencies = module.dependencies;\n    // 遍历依赖模块, 当前模块依赖的模块都编译完成,调用callback\n    async.forEach(\n      dependencies,\n      (item, done) => {\n        const { name, context, rawRequest, moduleId, resource } = item;\n        this.createModule(\n          {\n            name, // main\n            context, // 上下文\n            rawRequest, // 模块原始相对路径 ./title.js\n            resource, // 模块绝对路径\n            moduleId, // ./src/title.js\n          },\n          null,\n          done\n        );\n      },\n      callback\n    );\n  }\n  /**\n   * 根据入口把模块封装成chunk(chunk就是模块的集合)\n   * @param {*} callback\n   */\n  seal(callback) {\n    this.hooks.seal.call();\n    this.hooks.beforeChunks.call(); // 开始准备生成chunk\n    for (const entryModule of this.entries) {\n      const chunk = {\n        entryModule,\n        name: entryModule.name, //chunk的name,  如main\n        files: [], // chunk.js文件名\n        modules: [], // chunk.js依赖的模块\n        async: entryModule.async, // 是否是动态模块\n      };\n      this.chunks.push(chunk);\n      chunk.modules = this.modules.filter(\n        (module) => module.name === entryModule.name\n      );\n    }\n    this.hooks.afterChunks.call(this.chunks);\n    // 根据chunks 生成代码块assets用于输出文件\n    for (let i = 0; i < this.chunks.length; i++) {\n      const chunk = this.chunks[i];\n      const file = chunk.name + \".js\"; // 文件名\n      chunk.files.push(file);\n      this.files.push(file);\n      // 创建文件代码\n      let source;\n      if (chunk.async) {\n        source = chunkRender({\n          chunkName: chunk.name,\n          modules: chunk.modules,\n        });\n      } else {\n        source = mainRender({\n          entryModuleId: chunk.entryModule.moduleId,\n          modules: chunk.modules,\n        });\n      }\n      this.assets[file] = source;\n    }\n    callback();\n  }\n}\nmodule.exports = Compilation;\n```\n## NormalModuleFactory.js\n```js [toggle]\nconst path = require(\"path\");\nconst types = require(\"@babel/types\");\nconst traverse = require(\"@babel/traverse\");\nconst generator = require(\"@babel/generator\");\nconst async = require(\"neo-async\");\n// const acorn = require(\"acorn\");\n// 这里用babel模拟,实际webpack用的acorn, 因为babel有@babel/types方便操作\nconst { parse } = require(\"@babel/core\");\nconst { runLoaders } = require(\"loader-runner\");\n\nclass NormalModule {\n  constructor({ name, context, rawRequest, resource, moduleId, async } = {}) {\n    this.name = name;\n    this.context = context;\n    this.rawRequest = rawRequest;\n    this.resource = resource;\n    this.moduleId = moduleId;\n    // ast解析器\n    this.parser = parse;\n    // 此模块对应的源码\n    this._source;\n    // 此模块对应的ast\n    this._ast;\n    // 当前模块依赖的模块信息\n    this.dependencies = [];\n    // 当前模块依赖的异步模块(import(xx))\n    this.blocks = [];\n    // 是否是异步模块, 如果是import(xx)就是异步, 否则就是同步\n    this.async = async;\n  }\n  /**\n   * 编译本模块\n   * @param {*} compilation\n   * @param {*} callback\n   * 1. 可能内容不是js,就调用对应的loader将内容转换成js, 转换不了就报错了\n   * 2. 将js内容通过parser转换成ast\n   * 3. 分析ast,找到内部的require/import节点, 重复上面步骤进行递归,直至所有依赖模块都编译完成\n   */\n  build(compilation, callback) {\n    // loader处理\n    let {\n      module: { rules },\n    } = compilation.options;\n    let loaders = [];\n    for (let i = 0; i < rules.length; i++) {\n      let rule = rules[i];\n      if (rule.test.test(this.resource)) {\n        loaders.push(...rule.use);\n      }\n    }\n    // loader绝对路径\n    const resolveLoader = (loader) => {\n      return require.resolve(\n        path.posix.join(this.context, \"loaders\", loader)\n      );\n    };\n    loaders = loaders.map(resolveLoader);\n    runLoaders(\n      {\n        resource: this.resource,\n        loaders,\n      },\n      (err, { result }) => {\n        this._source = result.toString();\n        this._ast = this.parser(this._source);\n        traverse.default(this._ast, {\n          // 获取依赖模块\n          CallExpression: (nodePath) => {\n            const node = nodePath.node;\n            if (\n              node.callee.name === \"require\" ||\n              types.isImport(node.callee)\n            ) {\n              const moduleName = node.arguments[0].value; // 模块名\n              let depResource; // 依赖模块的绝对路径\n              // path.posix.sep  基于linux的路径分隔符 /\n              // window是 \\  linux是 / , webpack为了统一,都是用 /\n              const ext =\n                moduleName.split(path.posix.sep).pop().indexOf(\".\") > -1\n                  ? \"\"\n                  : \".js\"; // 模块名是否带有扩展名\n              // .开头说明引入的是本地模块,反正是node_modules中的第三方模块\n              if (moduleName.startsWith(\".\")) {\n                //  path加上posix就表示使用/, 如果不加就是自适应系统,window是\\，linux是/\n                depResource = path.posix.join(\n                  path.posix.dirname(this.resource),\n                  moduleName + ext\n                );\n              } else {\n                depResource = require.resolve(\n                  path.posix.join(this.context, \"node_modules\", moduleName)\n                );\n                depResource = depResource.replace(/\\\\/g, \"/\"); // windows路径 \\ 转linux路径 /\n              }\n              const depModuleId =\n                \".\" + depResource.slice(this.context.length);\n              if (node.callee.name === \"require\") {\n                //  依赖模块id (相对路径), 如 ./src/title.js\n                // console.log(path.posix.relative('c:/a/b','c:/a/b/c')); c  相当于去除相同的路径\n\n                // 修改ast\n                //  require => __webpack_require__, 即打包后的文件内容require(xx) 变为 __webpack_require__(xx)\n                node.callee.name = \"__webpack_require__\";\n                //  修改require的参数, 即 require('title') 变为 require('./src/title.js')\n                node.arguments = [types.stringLiteral(depModuleId)];\n                this.dependencies.push({\n                  name: this.name, // 入口模块名 main\n                  context: this.context, // 上下文即根目录\n                  rawRequest: moduleName, // 依赖模块的原始路径  ./title\n                  moduleId: depModuleId, // 依赖模块id , 转换后路径 ./src/title.js\n                  resource: depResource, // 依赖模块绝对路径\n                });\n              } else if (types.isImport(node.callee)) {\n                let chunkName = \"0\";\n                if (\n                  Array.isArray(node.arguments[0].leadingComments) &&\n                  node.arguments[0].leadingComments.length\n                ) {\n                  let leadingComments =\n                    node.arguments[0].leadingComments[0].value;\n                  if (leadingComments.indexOf(\"webpackChunkName\") > -1) {\n                    chunkName = leadingComments.split(\":\")[1].trim();\n                  }\n                }\n                nodePath.replaceWithSourceString(`\n                  __webpack_require__.e(\"${chunkName}\").then(__webpack_require__.t.bind(null,\"${depModuleId}\"))\n                `);\n                this.blocks.push({\n                  name: chunkName,\n                  context: this.context, // 上下文即根目录\n                  async: true,\n                  entry: depModuleId,\n                });\n              }\n            }\n          },\n        });\n        let { code } = generator.default(this._ast);\n        this._source = code;\n        // 循环构建每一个异步代码块, 都构建完成后才表示当前模块编译完成\n        async.forEach(\n          this.blocks,\n          (block, done) => {\n            const { context, entry, name, async } = block;\n            compilation.addEntry(context, entry, name, async, done);\n          },\n          (err) => {\n            callback(err, this);\n          }\n        );\n      }\n    );\n  }\n}\nmodule.exports = NormalModule;\n```\n## template.js\n```js [toggle]\n(function (modules) {\n    var installedModules = {};\n    function __webpack_require__(moduleId) {\n      if (installedModules[moduleId]) {\n        return installedModules[moduleId].exports;\n      }\n      var module = installedModules[moduleId] = {\n        i: moduleId,\n        l: false,\n        exports: {}\n      };\n      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n      module.l = true;\n      return module.exports;\n    }\n    return __webpack_require__(\"<%-entryModuleId%>\");\n  })\n    ({\n      <%\n        for(let module of modules)\n        {%>\n            \"<%-module.moduleId%>\":\n            (function (module, exports, __webpack_require__) {\n              <%-module._source%>\n            }),\n        <%}\n      %> \n    });\n```\n\n# 流程解析\n1. 初始化参数: 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。\n2. 初始化Compiler实例: `let compiler = new Compiler(options.context)`\n  - 定义`各种hook`: 如entryOption、compile、make、compilation、normalModuleFactory、emit、done等\n  - 定义`run方法`(编译的核心)\n3. 挂载plugin: 从配置参数对象,读取plugins数组循环订阅注册\n4. 注册并执行`entryOption入口钩子`:  回调中注册make钩子,从这里开始判断单/多入口进行编译以及入口的依赖编译\n```js [toggle]\n// 注册\ncompiler.hooks.entryOption.tap(\"EntryOptionPlugin\", (context, entry) => {\n    if (Array.isArray(entry)) {\n      // 多入口\n      // new MultiEntryPlugin(context, entry, \"main\").apply(compiler);\n    } else {\n      // 单入口\n      // new SingleEntryPlugin(context, entry, \"main\").apply(compiler);\n      compiler.hooks.make.tapAsync(\n        \"SingleEntryPlugin\",\n        (compilation, callback) => {\n          // 从此开始编译入口以及入口的依赖\n          compilation.addEntry(context, entry, \"main\", callback);\n        }\n      );\n    }\n});\n// 执行\ncompiler.hooks.entryOption.call(compiler.context, options.entry)\n```\n5. 开始编译: 执行`compiler.run((err, stats) => {console.log(err,stats.toJson())})`. (下面都是run里面的代码,为了排版好看不缩进,从第6步重新开始, 不放到该步里面进行缩进)\n\n6. 创建`compilation`实例. 用于: 整个工程的编译模块汇总(上面模块工程是一个模块)\n  ```js\n  const compilation = new Compilation(compiler)\n  ```\n- 定义各种属性\n  - entries: 入口模块,只有入口\n  - modules: 所有模块(比如入口模块依赖另一个模块, 就是入口模块、依赖模块)\n  - chunks: 最终生成的所有chunk\n  - assets: 最终生成的所有资源(根据chunks生成,内容差不多,区别是assets多了个通过ejs(webpack用的是自己字符串拼接的模版,这边方便用ejs)打包后的最终的代码,详见打包后的模块代码),用于遍历来生成dist中的一个个chunk文件\n- 定义createModule方法\n  - 创建`normalModuleFactory`模块工厂实例. 用于: 编译模块(js解析为ast,递归找到require/import依赖模块存入dependencies数组)\n    ```js\n    const module = new NormalModuleFactory()\n    ```\n    - 定义一个模块的各种属性:\n      - 模块id(相对于根目录的路径)`moduleId`: 打包后自执行函数的入参模块对象key, 如 ./src/index.js\n      - 模块编译后的代码`_source`: 比如require(xx)变为__webpack_require__(xx)\n      - 模块ast`_ast`\n      - 该模块依赖的模块`dependencies`: 是个数组,里面也是一个个模块对象包含上面这些属性\n      - 该模块依赖的`异步模块`(import(xx))数组`blocks`\n      - 该模块是否是异步模块标记 `this.async = async`\n    - 定义build方法\n      - 根据配置options找到rules,遍历判断如果和resource匹配,则通过`loader-runner的runLoaders方法`进行loader解析为js代码\n      ```js\n       runLoaders(\n        {\n          resource: this.resource,\n          loaders,\n        },\n        (err, { result }) => {\n             this._source = result.toString();\n             this._ast = this.parser(this._source);\n             ... //遍历ast节点判断\n        })\n      ```\n      - 通过parser`将loader解析的的js代码解析为ast`\n      - 分析判断ast节点是import/require, 说明是依赖同步模块,`塞入dependencies`数组中.同时require(xx)改为`__webpack_require__(xx)`. 注意⚠️,塞入dependencies前有段逻辑\n        - 依赖的同步模块需要判断路径是否`startsWith(\".\")`, 是的话是本地模块, 不是的话需要把模块路径拼接上`node_modules`\n      - 分析判断ast节点import如果是异步模块(import(xx)),说明是异步模块,`塞入blocks`数组中,塞入的数据标记`async:true`.同时import(xx)改为`__webpack_require__.e(xx).then(__webpack_require__.t.bind(null,\"${depModuleId}\"))`\n      ```js\n      nodePath.replaceWithSourceString(`\n        __webpack_require__.e(\"${chunkName}\").then(__webpack_require__.t.bind(null,\"${depModuleId}\"))\n      `);\n      ```\n      - `遍历blocks`调用addEntry进行`入口添加`(因为动态模块相当于一个入口,需要单独生成chunk)\n      ```js\n       // 循环blocks中每一个异步代码块, blocks都构建完成(addEntry)后才表示当前模块编译完成\n        async.forEach(\n          this.blocks,\n          (block, done) => {\n            const { context, entry, name, async } = block;\n            compilation.addEntry(context, entry, name, async, done);\n          },\n          (err) => {\n            callback(err, this);\n          }\n        );\n      ```\n  - 将module实例塞入`modules`,并判断是入口,存入`entries`\n  - 调用module.build编译,并将module.dependencies并`塞入modules`中\n- 定义seal方法,英文密封.用于: 遍历entries, 塞入`chunks`, 然后遍历chunks,同时调用mainRender模版塞入`assets`用于最终生成dist文件\n7. 执行make钩子触发`从入口开始编译`: `compilation.addEntry(context, entry, \"main\", callback)`里面调用了createModule方法\n  ```js\n  compiler.hooks.make.callAsync(compilation, err => {\n    compilation.seal((err) => {\n      console.log(\"seal封装执行完成\");\n      ... 触发emit钩子并输出文件\n  })\n  ```\n8. 调用seal开始封装模块成(assets、moudles,chunks、entries )\n9. 触发emit钩子: 写插件用的最多, 因为此时开始写硬盘了, 这是修改的最后一步\n- 根据配置文件ouput属性创建dist目录\n- 遍历assets通过fs写文件\n10. 触发done钩子: 输出文件完成.\n\n# 总结\n## webpack核心五大类\n- Compiler: `协调整个编译`过程, 只在初始化执行一次,主要定义遍布整个编译生命周期的hooks以及run方法(创建Compilation实例、NormalModuleFactory实例)\n- Compilation: 描述`一次编译`过程, 每次改动文件编译都会创建一个新的Compilation实例, 就是`代码编译的产物`(assets、chunks、modules、entries)\n- NormalModuleFactory: 创建一个模块,用于编译模块: `ast找依赖、require改__webpack_require__`(js解析为ast,递归找到require/import依赖模块存入dependencies数组)、定义模块id(即相对于根目录的路径)用于打包后的自执行函数的模块入参key、require改__webpack_require__\n- Webpack: 解析参数,初始化`Compiler实例`, 注册入口钩子用于开始`从入口开始编译`\n- template: 提前定义好模版字符串, 遍历modules作为打包后的模版入参,`拼接到模版`中用于最终输出文件的内容(webpack是自己封装的模板, 这里为了简单,用的ejs), \n\n## 简单流程\n1. 初始化参数: 从配置文件和 Shell 语句中读取与`合并参数`，得出最终的参数。\n2. 初始化Compiler实例: 定义遍布整个编译生命周期的hooks和run方法\n3. 调用`compiler.run((err, stats) => {console.log(err,stats.toJson())})`方法开始执行编译\n4. 定义entryOption入口钩子,从`入口开始`进行编译, 调用compilation.createModule创建模块, 该方法调用const module=new ModuleFactory()创建一个模块,包括\n  - moduleId-打包后自执行函数的入参模块对象key, 如 ./src/index.js\n  - 读取webpack配置的`rules遍历`,正则判断文件路径匹配到的话,调用loader-runner的`runLoaders`方法进行匹配到的loader解析为js代码,然后将js通过parse解析为ast\n  - 分析ast, 该模块的`同步依赖`模块存入dependencies同时require改为__webpack_require__后,再ast转源码的_source\n    - 依赖的同步模块需要判断路径是否`startsWith(\".\")`, 是的话是本地模块, 不是的话需要把模块路径修改拼接上`node_modules`\n  - 分析ast, 该模块的`异步依赖模`块存入blocks同时import(xx)改为__webpack_require__.e(xx).then(__webpack_require__.t.bind(null,\"${depModuleId}\"))后,再ast转源码的_source\n  - 遍历blocks调用addEntry方法进入入口`添加异步模块`(异步模块实际就相当于一个入口,需要生成单独的chunk)\n5. 构建和封装compilation模块产物: `assets、moudles,chunks、entries`\n  - 将上面定义的模块module存入`modules`, 入口模块通过addEntry存入`entries`, 遍历module.dependencies塞入modules.\n  - 遍历entries, 塞入`chunks`,同时调用mainRender模版(提前定义好了输出文件的结构)生成打包后的文件内容字符串塞入`assets`用于最终生成dist文件\n6. 触发`emit钩子`,写插件用的最多, 因为此时开始写硬盘了, 这是修改的最后一步\n7. 根据webpack.config.js配置文件的ouput属性`创建dist`目录\n8. 遍历`assets`通过fs`写文件`\n9. 触发`done钩子`表明输出文件完成.\n\n","categories":["webpack4"]},{"title":"7.插件plugin","url":"/ypf-blog/2025/01/21/webpack4/7.插件plugin/","content":"# 介绍\n我们上节课已经讲过webpack的运行流程,知道\n- loader机制让webpack拥有了处理`除js类型文件以外`的能力,而plugin则用于控制webpack`整个编译流程`. 一般用于处理编译的资源.\n- compiler、compilation、normalModuleFactory都有hooks供我们调用来创建插件.\n\n# 插件\n## ZipPlugin\n> 打包完成后, 在dist中同时将打包结果压缩到zip包中作为归档\n\n我们可以在`complier的emit`钩子进行处理: emit是修改产出文件的最后机会(后面webpack就开始写文件了)\n```js [toggle]\n// ZipPlugin.js\nlet jszip= require('jszip')\nlet {RawSource} = require('webpack-sources')\nclass Plugin {\n    constructor(options) {\n       this.options = options;\n    }\n    apply(compiler) {\n        compiler.hooks.emit.tapAsync('ZipPlugin', (compilation,callback) => {\n            console.log('ZipPlugin',compilation.assets);\n            let zip= new jszip();\n            for (let filename in compilation.assets) {\n                 const source= compilation.assets[filename].source(); // 编译后的文件代码字符串\n                 zip.file(filename,source); // 往压缩包添加文件\n            }\n            // 生成压缩包(会在dist目录生成压缩包)\n            zip.generateAsync({type:'nodebuffer'}).then((content)=>{\n                compilation.assets[this.options.filename] = new RawSource(content);\n                callback()\n            });\n        });\n    }\n}\nmodule.exports = Plugin;\n// webpack.config.js使用\nplugins:[\n  new ZipPlugin({\n    filename: \"my-assets.zip\",\n  }),\n]\n```\n\n## DonePlugin\n>  打包完成后, 输出编译成功\n\n我们可以在 `complier的done`钩子进行处理: done是webpack写文件结束触发的钩子\n```js [toggle]\nclass DonePlugin {\n    constructor(options) {\n       this.options = options;\n    }\n    apply(compiler) {\n        compiler.hooks.done.tap('DonePlugin', (assets) => {\n            console.log('DonePlugin',this.options.message);\n        });\n    }\n}\nmodule.exports = DonePlugin;\n\n// webpack.config.js使用\nplugins:[\n  new DonePlugin({\n    message:\"编译完成\"\n  }),\n]\n```\n\n## AutoExternalPlugin\n> 打包时忽略通过npm引用的第三方库, 并将忽略的包直接在html中通过CDN引用, 减少打包体积\n### 例子\n```js\n// index.js\nlet $=require('jquery')\nconsole.log($);\n```\n我们看下打包结果,webpack会把jquery也打包进来, 截图没法截全, 模块入参对象,有个key为`./node_modules/jquery/dist/jquery.js`, value是整个jquery内容\n<img src=\"images/1.jpg\" width=\"50%\"/>\n我们如果不想打包jQuery, 而通过cdn引入,相当于要引用window.jQuery,如下图\n<img src=\"images/2.jpg\" width=\"50%\"/>\n然后我们需要在index.html中引入cdn,如下图\n<img src=\"images/3.jpg\" width=\"50%\"/>\n\n```js\n// webpack.config.js\nplugins:[\n     new AutoExternalPlugin({\n      jquery:{ // 代码中import引入的包名 如 import $ from 'jquery'的jquery\n        expose:\"jQuery\", // 全局变量 (注意jq会在window挂jQuery和$两个变量, 这里我们用jQuery或$都行)\n        url:\"https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js\"\n      }\n    }),\n]\n```\n\n### 流程\n所以要完成上面功能,我们需要:\n- 配置: webpack.config.js配置要忽略的第三方库\n- ast解析存储引用的模块: 通过hook,在ast中判断rquire/import,将值存起来`importedModules数组`\n- 模块替换: 模块在配置中的话, 替换成`module.exports=window.jQuery`\n- html替换: 自动往html插入cdn(html-webpack-plugin的hook). 插入前需要判断有没有引用(第二步存的数组),只配置没引用就不要插入.\n<!-- 配置的模块判断是否引用 -->\n### 实现\n```js [toggle]\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst ExternalModule = require(\"webpack/lib/ExternalModule\");\n/**\n * 1. 自动在index.html中添加script标签引入外部js文件\n * 2. 自动往webpack.config.js中添加 externals 配置\n * https://github.com/jantimon/html-webpack-plugin\n */\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst ExternalModule = require(\"webpack/lib/ExternalModule\");\nclass Plugin {\n  constructor(options) {\n    this.options = options;\n    this.importedModules = {}; // 存储外部引入的模块\n  }\n  apply(compiler) {\n    compiler.hooks.normalModuleFactory.tap(\n      \"AutoExternalPlugin\",\n      (normalModuleFactory) => {\n        // 1. 解析ast,将import/require引用的存起来\n        normalModuleFactory.hooks.parser\n          .for(\"javascript/auto\")\n          .tap(\"AutoExternalPlugin\", (parser) => {\n            // 在解析ast时候, 遇到import就会执行此钩子\n            parser.hooks.import.tap(\n              \"AutoExternalPlugin\",\n              (statement, source) => {\n                this.importedModules[source] = true;\n              }\n            );\n            //   在解析ast时候, 遇到require就会执行此钩子\n            parser.hooks.call\n              .for(\"require\")\n              .tap(\"AutoExternalPlugin\", (expression) => {\n                let value = expression.arguments[0].value;\n                this.importedModules[value] = true;\n              });\n          });\n        // 2. 配置了且引用了,替换成window.xxx\n        normalModuleFactory.hooks.factory.tap(\n          \"AutoExternalPlugin\",\n          (factory) => {\n            return (data, callback) => {\n              const request = data.request;\n              if (this.options[request]) {\n                let variable = this.options[request].expose;\n                callback(null, new ExternalModule(variable, \"window\", request));\n              } else {\n                factory(data, callback);\n              }\n            };\n          }\n        );\n      }\n    );\n    // 3. 自动在index.html中添加script标签引入外部js文件\n    compiler.hooks.compilation.tap(\n      \"AutoExternalPlugin\",\n      (compilation, params) => {\n        // 这里是html-webpack-plugin的钩子(它会往webpack的hooks挂自定义钩子)\n        HtmlWebpackPlugin.getHooks(compilation).alterAssetTags.tapAsync(\n          \"AutoExternalPlugin\",\n          (data, callback) => {\n            Object.keys(this.options)\n              .filter((key) => this.importedModules[key]) // 如果配置了,但项目没引用, 不需要插入cdn\n              .forEach((key) => {\n                const { url, expose } = this.options[key];\n                data.assetTags.scripts.unshift({\n                  tagName: \"script\",\n                  voidTag: false,\n                  attributes: {\n                    defer: false,\n                    src: url,\n                  },\n                });\n              });\n            // 瀑布钩子, 将data作为参数传递给下一个钩子\n            callback(null, data);\n          }\n        );\n      }\n    );\n  }\n}\nmodule.exports = Plugin;\n```","categories":["webpack4"]},{"title":"5.tapable","url":"/ypf-blog/2025/01/14/webpack4/5.tapable/","content":"# 前言\n> [tapable](https://github.com/webpack/tapable)是一个由Webpack团队维护的事件库。它基于发布订阅模式实现事件处理.\n\n# 用法\n- 从执行机制上:分为`同步`和`异步`两种,其中异步又分为`串行和并行`\n- 从功能上:分为同步钩子、同步`瀑布`钩子、同/异步`保险`钩子、同/异步`循环`钩子、异步`串/并行`钩子\n- 从使用上: 注册hook,执行hook\n\n## 同步Sync\n### 同步钩子-SyncHook\n> 按注册顺序执行\n```js [toggle]\nlet { SyncHook } = require(\"tapable\");\n// 创建钩子\nconst hook = new SyncHook([\"name\", \"age\"]); // 参数是数组,必须提前声明callback的参数\n// 注册钩子\nhook.tap(\"1\", (name, age) => {\n  console.log(1, name, age);\n});\nhook.tap(\"2\", (name, age) => {\n  console.log(2, name, age);\n});\nhook.tap(\"3\", (name, age) => {\n  console.log(3, name, age);\n});\n// 执行钩子\nhook.call(\"名字\", 18);\n// 1 名字 18\n// 2 名字 18\n// 3 名字 18\n```\n### 同步保险钩子-SyncBailHook\n> Bail英文翻译为保释、保险.\n> 如果一个钩子返回值!=undefined, 跳出\n```js [toggle]\n// 创建钩子 \nlet { SyncBailHook } = require(\"tapable\");\nconst hook = new SyncBailHook([\"name\", \"age\"]); // 参数是数组,必须提前声明callback的参数\n// 注册钩子\nhook.tap(\"1\", (name, age) => {\n  console.log(1, name, age);\n});\nhook.tap(\"2\", (name, age) => {\n  console.log(2, name, age);\n  return  2\n});\nhook.tap(\"3\", (name, age) => {\n  console.log(3, name, age);\n});\n// 1 名字 18\n// 2 名字 18\n```\n### 同步瀑布钩子-SyncWaterfallHook\n> 上一个钩子返回结果为!=undefined,则下一个钩子第一个参数会是上一个钩子的返回结果, 其余参数依次往后挤,最后一个参数变为undefined\n```js [toggle]\nlet { SyncWaterfallHook } = require(\"tapable\");\n// 创建钩子 \nconst hook = new SyncWaterfallHook([\"name\", \"age\"]); // 参数是数组,必须提前声明callback的参数\n// 注册钩子\nhook.tap(\"1\", (name, age) => {\n  console.log(1, name, age);\n  return 'A'\n});\nhook.tap(\"2\", (arg,name, age) => {\n  console.log(2, arg,name, age);\n  return  ''\n}); \nhook.tap(\"3\", (arg,name, age) => {\n  console.log(3, arg,name, age);\n});\n// 执行钩子\nhook.call(\"名字\", 18);\n// 1 名字 18\n// 2 A 18 undefined\n// 3 '' 18 undefined\n```\n### 同步循环钩子-SyncLoopHook\n> 上一个钩子返回结果如果==undefined,则执行下一个钩子;!=undefined,则从头开始重新执行\n```js [toggle]\n// 创建钩子\nlet { SyncLoopHook } = require(\"tapable\");\nconst hook = new SyncLoopHook([\"name\", \"age\"]); // 参数是数组,必须提前声明callback的参数\nlet num1 = 0;\nlet num2 = 0;\nlet num3 = 0;\n// 注册钩子\nhook.tap(\"A\", (name, age) => {\n  console.log(\"A\", num1);\n  if (++num1 == 1) {\n    num1 = 0;\n    return;\n  }\n  return true\n});\nhook.tap(\"B\", (name, age) => {\n  console.log(\"B\", num2);\n  if (++num2 == 2) {\n    num2 = 0;\n    return;\n  }\n  return true\n});\nhook.tap(\"C\", (name, age) => {\n  console.log(\"C\", num3);\n  if (++num3 == 3) {\n    num3 = 0;\n    return;\n  }\n  return true\n});\n// 执行钩子\nhook.call(\"名字\", 18);\n// A 0\n// B 0\n// A 0\n// B 1\n// C 0\n// A 0\n// B 0\n// A 0\n// B 1\n// C 1\n// A 0\n// B 0\n// A 0\n// B 1\n// C 2\n```\n## 异步Async\n### 并行\n#### 异步并行钩子-AsyncParallelHook\n> hook同时执行,最晚的hook执行结束(callback触发)才会执行回调\n```js [toggle]\n// 任务同时执行,总花费3s\nconsole.time('cost')\nhook.tapAsync(\"1\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(1, name, age);\n    callback();\n  }, 1000);\n});\nhook.tapAsync(\"2\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(2, name, age);\n    callback();\n  }, 2000);\n});\nhook.tapAsync(\"3\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(3, name, age);\n    callback();\n  }, 3000);\n});\n// 执行钩子\nhook.callAsync(\"名字\", 18, (error) => {\n  console.log(error, \"执行完成\");\n  console.timeEnd('cost')\n});\n// 1 名字 18\n// 2 名字 18\n// 3 名字 18\n// undefined 执行完成\n// cost: 3.002s\n```\n##### promise写法\n> 只要有一个reject, 无论有没有值执行结束后, 走到error\n```js [toggle]\nconsole.time('cost')\nhook.tapPromise(\"1\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(1, name, age);\n      resolve();\n    }, 1000);\n  });\n});\nhook.tapPromise(\"2\", (name, age, callback) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(2, name, age);\n      resolve();\n    }, 2000);\n  });\n});\nhook.tapPromise(\"3\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(3, name, age);\n      resolve();\n    }, 3000);\n  });\n});\n// 执行钩子\nhook.promise(\"名字\", 18).then(() => {\n  console.log( \"执行完成\");\n  console.timeEnd('cost')\n})\n// 1 名字 18\n// 2 名字 18\n// 3 名字 18\n// 执行完成\n// cost: 3.003s\n```\n#### 异步并行保险钩子-AsyncParallelBailHook\n> callback返回值为真,则跳出. 执行完成后该返回值作为参数传入回调函数 , 比如''是假, 不会跳出\n```js [toggle]\nconsole.time('cost')\nhook.tapAsync(\"1\", (name, age, callback) => { \n  setTimeout(() => {\n    console.log(1, name, age);\n    callback();\n  }, 1000);\n});\nhook.tapAsync(\"2\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(2, name, age);\n    callback('1'); \n  }, 2000); \n});\nhook.tapAsync(\"3\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(3, name, age);\n    callback();\n  }, 3000);\n});\n// 执行钩子\nhook.callAsync(\"名字\", 18, (data) => {\n  console.log(data, \"执行完成\");\n  console.timeEnd('cost')\n});\n// 1 名字 18\n// 2 名字 18\n// 1 执行完成\n// cost: 2.003s\n// 3 名字 18\n```\n##### promise写法\n> resolve返回值!=undefined,则跳出. 执行完成后该返回值作为参数传入回调函数\n> 只要有一个reject且值为真,则跳出,执行完成后走到error; reject有值不为真, 不跳出,仍会走到then\n```js [toggle]\nconsole.time('cost')\nhook.tapPromise(\"1\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(1, name, age);\n      resolve();\n    }, 1000);\n  });\n});\nhook.tapPromise(\"2\", (name, age, callback) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(2, name, age);\n      resolve('');\n      // reject()\n      // reject(1);\n    }, 2000);\n  });\n});\nhook.tapPromise(\"3\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(3, name, age);\n      resolve();\n    }, 3000);\n  });\n});\n// 执行钩子\nhook.promise(\"名字\", 18).then((data) => {\n  console.log(data, \"执行完成\");\n  console.timeEnd('cost')\n},(error)=>{\n  console.log('error',error);\n})\n// 1 名字 18\n// 2 名字 18\n// '' 执行完成\n// cost: 2.003s\n// 3 名字 18\n```\n### 串行\n#### 异步串行钩子-AsyncSeriesHook\n> 前一个任务结束才会执行下一个, 所以总花费时间是每个任务时间之和\n```js [toggle]\nconsole.time('cost')\nhook.tapAsync(\"1\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(1, name, age);\n    callback();\n  }, 1000);\n});\nhook.tapAsync(\"2\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(2, name, age);\n    callback();\n  }, 2000);\n});\nhook.tapAsync(\"3\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(3, name, age);\n    callback();\n  }, 3000);\n});\n// 执行钩子\nhook.callAsync(\"名字\", 18, (error) => {\n  console.log(error, \"执行完成\");\n  console.timeEnd('cost')\n});\n// 1 名字 18\n// 2 名字 18\n// 3 名字 18\n// undefined 执行完成\n// cost:  6.013s\n```\n##### promise写法\n> 任意一个reject,后面就不会走了, 执行error回调 \n```js [toggle]\nconsole.time('cost')\nhook.tapPromise(\"1\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(1, name, age);\n      resolve();\n    }, 1000);\n  });\n});\nhook.tapPromise(\"2\", (name, age, callback) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(2, name, age);\n      resolve();\n      // reject()\n    }, 2000);\n  });\n});\nhook.tapPromise(\"3\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(3, name, age);\n      resolve();\n    }, 3000);\n  });\n});\n// 执行钩子\nhook.promise(\"名字\", 18).then(() => {\n  console.log( \"执行完成\");\n  console.timeEnd('cost')\n},() => {\n  console.log( \"执行失败\");\n  console.timeEnd('cost')\n})\n// 1 名字 18\n// 2 名字 18\n// 3 名字 18\n// 执行完成\n// cost: 6.014s\n```\n#### 异步串行保险钩子-AsyncSeriesBailHook\n> 返回值为真,则跳出. 执行完成后该返回值作为参数传入回调函数 , 比如''是假, 不会跳出\n```js [toggle]\nconsole.time('cost')\nhook.tapAsync(\"1\", (name, age, callback) => { \n  setTimeout(() => {\n    console.log(1, name, age);\n    callback();\n  }, 1000);\n});\nhook.tapAsync(\"2\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(2, name, age);\n    callback('1'); \n  }, 2000); \n});\nhook.tapAsync(\"3\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(3, name, age);\n    callback();\n  }, 3000);\n});\n// 执行钩子\nhook.callAsync(\"名字\", 18, (data) => {\n  console.log(data, \"执行完成\");\n  console.timeEnd('cost')\n});\n// 1 名字 18\n// 2 名字 18\n// 1 执行完成\n// cost: 3.010s\n```\n##### promise写法\n> 返resolve值!=undefined,则跳出. 执行完成后该返回值,传入回调函数 , 比如'', 会跳出\n> 只要有一个reject且值无论真假,则跳出. 最后走到error\n```js [toggle]\nlet { AsyncSeriesWaterfallHook } = require(\"tapable\");\nconst hook = new AsyncSeriesWaterfallHook([\"name\", \"age\"]); // 参数是数组,必须提前声明callback的参数\nconsole.time('cost')\nhook.tapPromise(\"1\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(1, name, age);\n      resolve();\n    }, 1000);\n  });\n});\nhook.tapPromise(\"2\", (name, age, callback) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(2, name, age);\n      // resolve('');\n      // reject();\n    }, 2000);\n  });\n});\nhook.tapPromise(\"3\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(3, name, age);\n      resolve();\n    }, 3000);\n  });\n});\n// 执行钩子\nhook.promise(\"名字\", 18).then((data) => {\n  console.log(data, \"执行完成\");\n  console.timeEnd('cost')\n},(error)=>{\n  console.log('error',error);\n})\n// 1 名字 18\n// 2 名字 18\n// '' 执行完成\n// cost: 3.014s\n```\n#### 异步串行瀑布钩子-AsyncSeriesWaterfallHook\n> callback第一个参数是回调函数\n> 第二个参数有值, 会作为下一个hook的参数\n```js [toggle]\nconsole.time('cost')\nhook.tapAsync(\"1\", (name, age, callback) => { \n  setTimeout(() => {\n    console.log(1, name, age);\n    callback(null,'A');\n  }, 1000);\n});\nhook.tapAsync(\"2\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(2, name, age);\n    callback(); \n  }, 2000); \n});\nhook.tapAsync(\"3\", (name, age, callback) => {\n  setTimeout(() => {\n    console.log(3, name, age);\n    callback();\n  }, 3000);\n});\n// 执行钩子\nhook.callAsync(\"名字\", 18, (data) => {\n  console.log(data, \"执行完成\");\n  console.timeEnd('cost')\n});\n// 1 名字 18\n// 2 A 18\n// 3 A 18\n// null 执行完成\n// cost: 6.012s\n```\n##### promise写法\n> 返回值!=undefined,则跳出. 执行完成后该返回值作为参数传入回调函数\n> 只要有一个reject且值无论真假,则跳出. 最后走到error\n```js [toggle]\nconsole.time('cost')\nhook.tapPromise(\"1\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(1, name, age);\n      resolve('A');\n    }, 1000);\n  });\n});\nhook.tapPromise(\"2\", (name, age, callback) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(2, name, age);\n      resolve();\n      // reject();\n    }, 2000);\n  });\n});\nhook.tapPromise(\"3\", (name, age) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(3, name, age);\n      resolve();\n    }, 3000);\n  });\n});\n// 执行钩子\nhook.promise(\"名字\", 18).then((data) => {\n  console.log(data, \"执行完成\");\n  console.timeEnd('cost')\n},(error)=>{\n  console.log('error',error);\n})\n// 1 名字 18\n// 2 A 18\n// 3 A 18\n// A 执行完成\n// cost: 6.014s\n```\n## HookMap\n> HookMap是基于es6 Map实现, 相当于一个对象,存储`管理`hook\n```js\nconst { HookMap, SyncHook } = require('tapable');\nconst keyedHook = new HookMap((key) => new SyncHook(['arg']));\n// 在keyedHook中创建一个name为key1的hook，同时为该hook通过tap注册事件 \nkeyedHook.for('key1').tap('Plugin 1', (arg) => {\n  console.log('key1-Plugin 1', arg);\n});\nkeyedHook.for('key1').tap('Plugin 2', (arg) => {\n  console.log('key1-Plugin 2', arg);\n});\n// 在keyedHook中创建一个name为key2的hook，同时为该hook通过tap注册事件\nkeyedHook.for('key2').tap('Plugin 1', (arg) => {\n  console.log('key2-Plugin 1', arg);\n});\n// 从HookMap中拿到name为key1的hook\nconst hook = keyedHook.get('key1');\nif (hook) {\n  // 通过call方法触发Hook\n  hook.call('hello');\n}\n// key1-Plugin 1 hello\n// key1-Plugin 2 hello\n```\n### 总结\n- HookMap用于管理hook, 通过`for方法创建带key`的hook\n- 通过get方法`获取指定key`的hook来执行\n\n# 总结\n- tapable是一个基于`发布订阅`模式的钩子系统,使用方法`注册`hook,`执行`hook\n- 从执行机制上:分为`同步`和`异步`两种,其中异步又分为`串行和并行`\n- 种类:\n  - 瀑布钩子: 上一个hook的`返回值作为`下一个hook的`参数`\n  - 保险钩子: 上一个hook返回有值, 直接`跳出`\n  - 循环钩子: 上一个hook返回有值, 从头`循环`执行, 没值(===undefined)则执行下一个hook\n- 同步:按注册顺序执行\n- 异步串行:上一个任务结束,再执行下一个,时间=每个hook时间`之和`, 所有任务结束进入最终回调\n- 异步并行:同时执行, 时间=时间`最长`的hook,所有任务结束进入最终回调\n- 我们可以用HookMap来`命名`hook,`管理` hook\n\n# 实现tapable\n在实现之前,我们需要知道 `函数定义`, 因为tapable用的是`动态函数`\n## 函数定义\n有三种\n1. 函数声明\n```js\nfunction sum(a, b) {\n  return a + b;\n}\n```\n2. 函数表达式\n```js\nvar sum = function (a, b) {};\n```\n3. 构造(动态)函数\n```js\nconst sum = new Function(\"a\", \"b\", `return a+b`);\nconst sum = new Function(\"a,b\", `return a+b`);\nconst sum = new Function(`return 1`);\n```\n- 可以看到:动态函数可以给用字符串的方式传参数、函数体. 其中参数可以省略.\n\n## 实现\n由于官方源码分了好几个js来继承, 为了简单, 这里只实现最核心的流程.\n```js\nclass SyncHook {\n  constructor(args) {\n    // 参数\n    if (!Array.isArray(args)) {\n      args = [];\n    }\n    this._args = args;\n    // 存储所有的钩子函数, 格式是对象 [{name:钩子名称, fn: 钩子函数}]\n    this.taps = [];\n    this._x = undefined; // 存储所有的钩子函数, 格式是函数 [钩子函数1,钩子函数2]\n  }\n  tap(options, fn) {\n    if (typeof options === \"string\") {\n      options = {name: options};\n    }\n    options.fn = fn;\n    this.taps.push(options);\n  }\n  call(...args) {\n    // 动态创建一个函数\n    const callFn = this.create(options);\n    // 执行钩子\n    callFn.apply(this, args); \n  }\n  /**\n   *\n   * function(name,age){\n   *    var _fn0 = _x[0];\n   *    _fn0(name,age);\n   *    var _fn1 = _x[1];\n   *    _fn1(name,age);\n   * }\n   */\n  create() {\n    const args = this.args.join(\",\");\n    const body = this.taps\n      .map((item, i) => {\n        return `\n                var _fn${i} = ${item.fn};\\n\n                _fn${i}(${args});\n            `;\n      })\n      .join(\"\\n\");\n    return new Function(args, body);\n  }\n}\nmodule.exports = SyncHook;\n```\n## 总结\n1. 初始化`this._args`存储参数列表\n2. 调用tap的时候,往taps存储钩子函数\n3. 调用call的时候,创建一个动态函数, 该函数使用`new Function(第一步的args, 函数体)`\n4. 函数体是循环遍历taps, 拼接出多个函数,并传入args\n5. 执行该动态函数\n\n## AsyncParallelHook\n上面展示的同步代码, 异步整体差不多, \n- 注册: 多了callback供单个异步动作结束后调用\n- 执行: 多了回调\n```js\n// 注册\nhook.tapAsync(\"1\", (name, age, callback) => {\n  setTimeout(() => {\n    callback();\n  }, 1000);\n});\n// 执行\nhook.callAsync(\"名字\", 18, (error) => {\n  console.log(error, \"执行完成\");\n  console.timeEnd('cost')\n});\n```\n```js\n  callAsync(...args) {\n    // 添加最终结束回调\n    args.push(() => {})\n    // 动态创建一个函数\n    const callFn = this.create(options);\n    // 执行钩子\n    callFn.apply(this, args); \n  }\n  create(){\n     const header = `\n        var _counter = this.taps.length;\n    `;\n    const body = options.taps\n      .map((item, i) => {\n        return `\n              var _fn${i} = ${item};\\n\n              _fn${i}(${this.args},()=>{\n                    if(--_counter===0){\n                       this.args[this.args.length-1]()\n                    }\n             });\n          `;\n      })\n      .join(\"\\n\");\n    return new Function(\n      this.args,\n      header + body\n    );\n  }\n```\n### 总结\n- 注册: 多了`callback供单个`异步动作结束后调用\n- 执行: 多了`最终回调`\n- 所以参数最后`push一个最终函数`,创建动态函数的函数体, 插入一个`callback`,单个执行就会`计数-1`直至总taps为0, 最终执行结束, 执行最终函数\n- 上面代码是有注册函数,才能循环最终执行最终回调,没有展示完整的. 实际源码就算`没有注册函数`,执行callAsyc`也会直接`执行`最终回调`函数(源码判断注册函数.length===0直接执行最终回调,有再循环)\n\n\n> https://juejin.cn/post/7040982789650382855#heading-17","categories":["webpack4"]},{"title":"4.loader","url":"/ypf-blog/2024/12/30/webpack4/4.loader/","content":"# 为什么会有loader\n- webpack只能处理`.js和.json文件`,但打包过程中遇到其他类型文件，如`.vue、.ts、图片、.css`等，webpack就无能为力了,面对这一问题，webpack提供了loader机制,用来将webpack不能识别的文件，转换为标准的js模块.\n- loader的本质就是一个**函数**,webpack内部的`loader runner`会调用此函数，然后将上一个loader产生的结果或者资源文件传入进去\n\n# 用法\n我们通常使用loader是在配置文件中配置的，除去`inline-loader`下面会讲到\n```js\nmodule.exports = {\n  rules: [\n    {\n      test: /\\.js$/,\n      // use: [\"babel-loader\"],\n      // loader: \"babel-loader\",\n      // use:{\n      //   loader: 'babel-loader',\n      // },\n      use: [\n        {\n          loader: 'babel-loader', // 会去找node_modules中的babel-loader\n          // loader: path.join(__dirname, \"loaders/babel-loader.js\"), // 引用本地loader\n          options: {\n            presets: [\"@babel/preset-env\"],\n          },\n        },\n      ],\n    },\n  ],\n}\n```\n我们看到, 使用的时候有多种写法\n- 我们可以`use: 对象、字符串、数组、数组对象`, 一般我们用最后一种,可以传多个且能传options进行配置\n- loader可以引用**本地路径**,也可以引用node_modules中的loader\n- 如果觉得本地路径写法不优雅,我们通过**resolveLoader**配置webpack查找loader方式\n```js\n  // webpack找loader方式, 优先匹配node_modules中的loader, 找不到再依次匹配loaders中的loader\n resolveLoader: {\n   modules: [\"node_modules\", path.resolve(__dirname, \"loaders\")],\n },\n rules: [\n    {\n      test: /\\.js$/,\n      use: [\n        {\n          loader: 'babel-loader',  // 仍写babel-loader\n          options: {\n            presets: [\"@babel/preset-env\"],\n          },\n        },\n      ],\n    },\n  ],\n```\n\n# loader分类\n在webpack中,从loader的执行时机, 可以分为4种,执行顺序: `pre -> normal -> inline -> post`\n- **pre**:  前置loader\n- **normal**: 普通loader\n- **inline**: 内联loader\n- **post**: 后置loader\n\n## 配置loader\n- **pre**和**post**和**normal**都是通过rule对象的`enforce配置`的, 不传enforce, 默认是normal\n```js\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.txt$/i,\n        use: [\"a-loader\"],\n        enforce: \"post\", // post loader\n      },\n      {\n        test: /\\.txt$/i,\n        use: [\"b-loader\"], // normal loader\n      },\n      {\n        test: /\\.txt$/i,\n        use: [\"c-loader\"],\n        enforce: \"pre\", // pre loader\n      },\n    ],\n  },\n};\n```\n\n## 内联loader\n- **inline**比较特殊,它只能在**代码中**引入模块的时候进行声明, 语法如下,官方文档[loader](https://webpack.docschina.org/concepts/loaders/#using-loaders)\n```js\nimport common from 'inliner-loader1?type=abc&limit=64!inliner-loader2?type=abc!./index.js'\nrequire('inliner-loader1?type=abc!inliner-loader2?type=abc!./index.js')\n```\n- 使用`!`进行分割, 最后一块是要解析的文件\n- 每个loader都可以配置options, 类似query参数\n- 我们可以在**最前面**加上3种方式来控制配置loader如何执行\n  - **!**: 不执行normal-loader\n  - **!!**:不执行所有配置loader\n  - **-!**: 不执行pre-loader和normal-loader\n如\n```js\nrequire('!inliner-loader1!inliner-loader2!./index.js')\nrequire('!!inliner-loader1!inliner-loader2!./index.js')\nrequire('-!inliner-loader1!inliner-loader2!./index.js')\n```\n\n## 异步loader\n上面四种loader默认都是同步的,如果需要异步, 我们可以这样\n```js\n// async-loader\nfunction loader(source){\n    let callback = this.async();\n    setTimeout(() => {\n        callback(null,source+'//async2')\n    }, 5000);\n}\n```\n-  调用async方法,可以把loader执行从同步改为异步\n-  虽然loader此时是异步的,但是此时会进入阻塞状态, 只有等待调用callback后,才会执行下一个loader,比如 loader1、异步loader2、loader3, 执行顺序是: `先输出loader1、5s后输出loader2、最后输出loader3`\n\n# loader执行顺序\n## 无pitch\n- 从种类来看:  `pre -> normal -> inline -> post`\n- 从执行方向看: `倒序执行/从右向左/从下往上`, 比如`use:[loader1 ,loader2 ,loader3]`, 执行顺序是: `loader3 -> loader2 -> loader1`\n\n## 有pitch\npitch英文抛的意思,在代码里相当于熔断.\n正常loader是一个函数,如果我们给loader定义一个pitch函数,那么执行顺序就不一样了:\n```js\nconst loader = function (content, map, meta) {\n console.log(\"a-loader执行\");\n return content;\n};\nloader.pitch = function () {\n console.log(\"a-loader pitch执行\");\n};\n```\n上面workflow:  先执行pitch,再执行loader.\n###  例子🌰1\n```js\nuse:[loader1,loader2,loader3]  // 每个都绑定pitch函数,那么执行顺序是:\n//loader1\nconst loader = function (content, map, meta) {\n console.log(\"loader1执行\");\n return content+'1';\n};\nloader.pitch = function () {\n console.log(\"loader1 pitch执行\");\n};\nmodule.exports =loader\n\n//loader2\nconst loader = function (content, map, meta) {\n console.log(\"loader2执行\");\n return content+'2';\n};\nloader.pitch = function () {\n console.log(\"loader2 pitch执行\");\n};\nmodule.exports =loader\n\n// loader3\nconst loader = function (content, map, meta) {\n console.log(\"loader3执行\");\n return content+'3';\n};\nloader.pitch = function () {\n console.log(\"loader3 pitch执行\");\n};\nmodule.exports =loader\n```\n执行结果:\n- `loader1-pitch -> loader2-pitch -> loader3-pitch -> loader3 -> loader2 -> loader1`\n- 打印结果:result表示执行loader转换后的结果,以及对应的二进制resourceBuffer\n<img src=\"images/1.jpg\" width=\"80%\"/>\n\n###  例子🌰2\n```js\nuse:[loader1,loader2,loader3]  // 每个都绑定pitch函数,那么执行顺序是:\n//loader1\nconst loader = function (content, map, meta) {\n console.log(\"loader1执行\");\n return content+'1';\n};\nloader.pitch = function () {\n console.log(\"loader1 pitch执行\");\n};\nmodule.exports =loader\n\n//loader2\nconst loader = function (content, map, meta) {\n console.log(\"loader2执行\");\n return content+'2';\n};\nloader.pitch = function () {\n return '2'\n};\nmodule.exports =loader\n\n// loader3\nconst loader = function (content, map, meta) {\n console.log(\"loader3执行\");\n return content+'3';\n};\nloader.pitch = function () {\n console.log(\"loader3 pitch执行\");\n};\nmodule.exports =loader\n```\n执行结果:\n- `loader1-pitch -> loader2-pitch  -> loader1-loader`\n- 如果pitch有return返回值(return不行,需要有值),那么直接跳出,执行上一个loader,一次倒序执行\n- 打印结果:result此时是-pick返回的值传递给上一个loader的source, 处理后的结果\n<img src=\"images/2.jpg\" width=\"80%\"/>\n\n## 总结\n<img src=\"images/3.jpg\" width=\"80%\"/>\n<img src=\"images/4.jpg\" width=\"80%\"/>\n\n- 上图很清晰,loader🈶两个阶段,`normal和pitch`, normal就是正常的loader函数.\n- pitch**没有返回值**,执行pitch结束后, 会读取文件内容作为source依次传给loader的source处理.(注意是在pitch阶段全部处理完成后，这一步才会读取引入的资源文件内容。)\n- **有返回值**, source直接是pich的返回值, 再传给上一个loader的source依次loader处理(即打破原有顺序掉头执行)\n- 实际loader的执行是调用了`loader-runner`的runLoaders方法.\n```js\nconst { runLoaders } = require(\"loader-runner\"); // 是一个执行loader链条的模块(webpack会自动安装)\nrunLoaders(\n  {\n    resource: path.resolve(__dirname, \"src/index.js\"), // 解析的文件\n    loaders, // loader绝对路径数组\n    readResource: fs.readFile.bind(fs), // 读文件方法\n  },\n  (err, result) => {\n    console.log(err);\n    console.log(result);\n  }\n);\n```\n<img src=\"images/5.jpg\" width=\"50%\"/>\n\n### loader-runner\n我们需要了解下loader-runner的运行机制. 假如我们有一个loader的配置如下: `!loader1!loader2!loader3!./src/index.js`\n- 先切割变成数组`[loader1,loader2,loader3]`传递给loader-runner\n- loader-runner会构造一个上下文`loaderContext`对象,供执行pitch和normal函数的this指针\n  - loaders: 上面loader数组转换为数组对象,每个loader对象包含\n     - loader的全路径path\n     - query参数\n     - pitchExecuted: 是否执行了pitch方法, executed:英文执行的意思\n  - request: 将loaders全路径数组转换为内联字符串方式: xx/loader1!xx/loader2!xx/loader3!D:/src/index.js\n  - resource: 要被处理的的resource,如D:/src/index.js  \n  - loaderIndex: 当前执行loader函数(pitch/normal)的索引\n  - data: 当前执行loader的data参数\n  - currentRequest: `当前loader+剩余loader+resouce字符串`\n  - remainingRequest: `剩余loader+resouce字符串`, 不包括当前loader的request.\n  - previousRequest:  `之前loader字符串`, 不包括当前loader的request.\n- 循环loaders, 依次执行loader的pitch函数,`loaderIndex++`\n  - loaderIndex=0: 此时开始执行`loader1-pitch`\n    - currentRequest:`xx/loader1!xx/loader2!xx/loader3!D:/src/index.js`\n    - remainingRequest:`xx/loader2!xx/loader3!D:/src/index.js`\n    - previousRequest:`''`\n  - loaderIndex=1: loader1-pitch执行完毕, 执行`loader2-pitch`\n    - currentRequest:`xx/loader2!xx/loader3!D:/src/index.js`\n    - remainingRequest:`xx/loader3!D:/src/index.js`\n    - previousRequest:`xx/loader1`\n  - loaderIndex=2: loader2-pitch执行完毕, 执行`loader3-pitch`\n    - currentRequest:`xx/loader3!D:/src/index.js`\n    - remainingRequest:`D:/src/index.js`\n    - previousRequest:`xx/loader1!xx/loader2`\n- 依次执行loader的normal函数,`loaderIndex--`\n  - loaderIndex=2: loader3-pitch执行完毕,开始执行`loader3-normal`\n    - currentRequest:`xx/loader3!D:/src/index.js`\n    - remainingRequest:`D:/src/index.js`\n    - previousRequest:`xx/loader1!xx/loader2`\n  - loaderIndex=1: loader3-normal执行完毕,开始执行`loader2-normal`\n    - currentRequest:`xx/loader2!xx/loader3!D:/src/index.js`\n    - remainingRequest:`xx/loader3!D:/src/index.js`\n    - previousRequest:`xx/loader1`\n  - loaderIndex=0: loader2-normal执行完毕,开始执行`loader1-normal`\n    - currentRequest:`xx/loader1!xx/loader2!xx/loader3!D:/src/index.js`\n    - remainingRequest:`xx/loader2!xx/loader3!D:/src/index.js`\n    - previousRequest:`''`\n\n1. 通过上面流程我们可以知道pitch和normal函数的三个字段输出是**一样的**, 我们可以按pitch来理解这三个字段的结果\n2. `remainingRequest`这个属性比较重要,pitch函数就需要用到这个属性来将剩余的loader变成内链执行.(因为pitch跳出就没法执行后续了,所以在这里手动执行)\n\n# 常用loader\n## file-loader\n>`file-loader`用于处理非js文件，如图片、字体等，会将文件拷贝到输出目录，并返回文件地址。\n```js\n// webpack.config.js\n module: {\n    rules: [\n      {\n        test:/\\.(jpg|png|gif|bmp)$/,\n        use:{\n          loader:'file-loader',\n          options:{\n            filename: '[hash].[ext]',\n          }\n        }\n      },\n    ]\n }  \n```\n```js\n// file-loader.js\nconst { getOptions, interpolateName } = require(\"loader-utils\");\nfunction loader(source) {\n    // loader.raw = true, 此时source返回是个二进制流Buffer, 如果不加, source返回的是utf-8字符串,这里因为是图片文件, source就是个乱码字符串\n  console.log(\"加载file-loader\");\n  // 获取loader的配置\n  let options = getOptions(this); // {filename: '[hash].[ext]'}\n  // 生成文件名,interpolate英文插入的意思\n  let filename = interpolateName(this, options.filename, { content: source }); // 需要根据source生成hash\n  // 调用webpack创建文件\n  this.emitFile(filename, source);\n  return `module.exports = ${JSON.stringify(filename)}`;\n}\nloader.raw = true; // 因为加载的是二进制文件\nmodule.exports = loader;\n```\n### 总结\n- 获取配置\n- 根据source以及配置生成文件名\n- 调用webpack创建文件\n- 上面必须加`JSON.stringify`, 不加如下图\n<img src=\"images/6.jpg\" width=\"50%\"/>\n- 如果用`module.exports`, 使用`require('xx.jpg')`不需要加default, 如果是`export default`,需要加default, 我们在第一节讲过,es模块会转为commonjs模块,并增加了default\n- 因为图片是文件流,所以需要给loader**绑定raw属性**\n\n## url-loader\n> `url-loader`可以将打包过程中用到的文件转换为 base64 格式字符串，这样可以减少网络请求次数。比如100个小图片,处理后,只有1个文件, 减少100次请求, 优化了网络请求。但注意需要控制阈值,否则会导致文件过大\n```js\n// webpack.config.js\n module: {\n    rules: [\n      {\n        test:/\\.(jpg|png|gif|bmp)$/,\n         use:{\n          loader:'url-loader',\n          options:{\n            filename: '[hash].[ext]',\n            limit: 8*1024 // 8kb   单位:字节 1kb=1024byte\n          }\n        }\n      },\n    ]\n } \n```\n```js\nconst mime = require(\"mime\");\nconst { getOptions, interpolateName } = require(\"loader-utils\");\nfunction loader(source) {\n    // loader.raw = true, 此时source返回是个二进制流Buffer, 如果不加, source返回的是utf-8字符串,这里因为是图片文件, source就是个乱码字符串\n  console.log(\"加载url-loader\");\n  // 获取loader的配置\n  let {limit,fallback='file-loader'} = getOptions(this); \n  if(limit){\n    limit=parseInt(limit); \n  }\n  const mimeType = mime.getType(this.resourcePath);// 获取文件类型, 如xx/a.jpg=>image/jpeg\n  if(!limit || source.length<limit){\n    let base64String =`data:${mimeType};base64,${source.toString('base64')}`\n    return `module.exports = ${JSON.stringify(base64String)}`\n  }else{\n    let fileLoader = require('./'+fallback);\n    return fileLoader.call(this,source);\n  }\n}\nloader.raw = true; // 因为加载的是二进制文件\nmodule.exports = loader;\n```\n### 总结\n- 判断阈值以及获取文件类型插入base64字符串\n- 如果不满足阈值，则使用file-loader, 所以我们如果用了urrl-loader，不用再在webpack.config.js中配置file-loader了, 但需要安装, 因为会依赖\n\n## style-loader和less-loader\n> `style-loader` 可以将 css 代码注入到 js 中，运行时，通过创建 style 标签，将样式插入到 head 中。\n> `less-loader` 将 less 转为 css, 然后交给 style-loader 处理。 sass-loader同理\n### style-loader使用normal\n```js [toggle]\n// index.js\nrequire('./index.less')\n// webpack.config.js \n module: {\n    rules: [\n      {\n        test:/\\.css$/,\n        use:[\n          'style-loader', // 创建style标签插入页面中\n          'less-loader', // 将less转换为css\n        ]\n      },\n    ]\n } \n```\n```js [toggle]\n// less-loader \nconst less = require(\"less\");\nfunction loader(source) {\n  const callback = this.async();\n  //  将less转换为css\n  less.render(\n    source,\n    {\n      filename: this.resource,\n    },\n    (err, output) => {\n      callback(err, output.css);\n    }\n  );\n}\nmodule.exports = loader;\n```\n```js [toggle]\n// style-loader \nfunction loader(source) {\n  let style = `\n    let style = document.createElement('style');\n    style.innerHTML = ${JSON.stringify(source)};\n    document.head.appendChild(style);\n `;\n return style;\n}\nmodule.exports = loader;\n```\n### 总结\n上面原理很简单:\n- 都没有pitch, less-loader先执行返回`编译后的css`,传给style-loader进行`插入style`\n这样看好像没什么问题, 但是如果我们代码里有`@import 'a.css'`以及`background:url(a.jpg)`这种有链接的情况, 就没法处理, 需要通过`css-loader处理`.但是css-loader返回的是`脚本,不是css`,所以stye-loader接受后直接插入style就会`有问题`. 所以style-loader的代码需要放到`pitch`中. 我们在下面具体讲解下\n\n## style-loader和css-loader\n```js\n// index.js\nrequire('./index.css')\n// index.css\n@import \"./import.css\";\ndiv{ background: url('./1-1.jpg');color:red }\n// webpack.config.js \n module: {\n    rules: [\n      {\n        test:/\\.css$/,\n        use:[\n          'style-loader', // 创建style标签插入页面中\n          'css-loader', // 解析css\n        ]\n      },\n    ]\n } \n```\n我们先用上面的style-loader中的normal函数里, 打印下css-loader返回给style-loader的source是啥样的脚本?\n<img src=\"images/7.jpg\" width=\"80%\"/>\n\n我们来分析下流程:\n1. 正常顺序是`style-loader-pitch、css-loader-pitch、css-loader、style-loader`, 但style-loader-pitch有返回值直接`跳出就结束`了. 那css-loader怎么办?这就需要`remainingRequest`了.\n2. `remainingRequest`: 剩余还未执行的loader,上面我们在`loader-runner`中分析过.\n\n### style-loader使用pitch\n```js\n// style-loader\nconst { stringifyRequest } = require(\"loader-utils\");\nfunction loader(source) {\n}\nloader.pitch = function (remainingRequest, previousRequest, data) {\n  console.log(\"加载style-loader-pitch\");\n  console.log(stringifyRequest(this, `!!${remainingRequest}`)) // \"!!../node_modules/css-loader/dist/cjs.js!./index.css\"\n  let style = `\n    let style = document.createElement('style');\n    style.innerHTML =  require(${stringifyRequest(this, `!!${remainingRequest}`)}); // 重新执行loader-runner,只执行css-loader\n    document.head.appendChild(style);\n `;\n  return style; \n};\nmodule.exports = loader;\n```\n- 上面我们把`style-loader`逻辑放到pitch中,此时执行完就跳出结束流程了, 那么css-loader怎么办? 此时就需要通过`remainingRequest`重新进行加载\n- `stringifyRequest`是为了把loader转换为相对路径,因为webpack内链执行都是相对的, 所以需要转换成相对路径.\n\n### css-loader\n```js [toggle]\nconst loaderUtils = require(\"loader-utils\");\nconst tokenizer = require(\"css-selector-tokenizer\");\nconst postcss = require(\"postcss\");\n// @import引入的css包含进来\n// url路径变成输出路径,如background:url(./a.png)\nfunction loader(source) {\n  console.log(\"加载css-loader\");\n  const cssPlugin = (options) => {\n    return (cssRoot) => {\n      // cssRoot就是ast语法树\n      //   console.log(cssRoot,'cssRoot');\n      //   遍历ast, 所有@import xx规则\n      cssRoot.walkAtRules(/^import$/, (rule) => {\n        rule.remove(); // 删除@import xx 规则\n        options.imports.push(rule.params.slice(1, -1)); // 去除最外层双引号, 因为astexplore, rule.params获取的是\"'a.css'\", 然后添加到imports数组中 ,如'a.css',\n      });\n      //   遍历ast, 所有background:url(xx)规则\n      cssRoot.walkDecls(/^background$/, (decl) => {\n        let values = tokenizer.parseValues(decl.value);\n        values.nodes.forEach((value) => {\n          value.nodes.forEach((item) => {\n            if (item.type === \"url\") {\n              // 变成相对路径并require共webpack其他loader解析\n              item.url =\n                \"`+require(\" +\n                loaderUtils.stringifyRequest(this, item.url) +\n                \")+`\";\n            }\n          });\n        });\n        decl.value = tokenizer.stringifyValues(values);\n        // console.log(decl, \"decl\");\n      });\n    };\n  };\n  let callback = this.async();\n  let options = {\n    imports: [], // 引入的css(去除@import) 如 @import 'a.css' 中的 a.css\n  };\n  let pipeLine = postcss([cssPlugin(options)]);\n  pipeLine.process(source).then((result) => {\n    let imports = options.imports\n      .map((url) => {\n        return (\n          \"`+require(\" +\n          loaderUtils.stringifyRequest(this, \"!!css-loader1!\" + url) +\n          \")+`\"\n        );\n      })\n      .join(\"\\r\\n\");\n    // let output = \"module.exports = `\"  + result.css + \"`\"; // 拼接@import xx的css和普通的css,如div{xx}\n    let output = \"module.exports=`\" + imports + \"\\r\\n\" + result.css + \"`\"; // 拼接@import xx的css和普通的css,如div{xx}\n    output = output.replace(/\\\\\"/g, '\"');\n    console.log(output, \"output\");\n    callback(null, output);\n  });\n}\nmodule.exports = loader;\n```\n#### 总结\n- `css-loader`依赖postcss解析ast\n- 分析ast,找到所有`@import xx`规则的url, 转换为相对路径并拼接上`css-loader`并require, 通过内链的方式进行执行\n- 分析ast,找到所有`background:url(xx)`规则, 转换为相对路径并require,供webpack的其他loader解析\n- 因为都要通过require引用, 所以肯定是个js脚本, 所以需要`style-loader`在pitch就得执行,而不是`css-loader`执行导致style标签中的是js脚本\n\n简单来说，如果在loader开发中你的需要依赖其他loader，但此时上一个loader的normal函数返回的并不是处理后的资源文件内容而是一段js脚本，那么将你的loader逻辑设计在pitch阶段无疑是一种更好的方式。\n\n## babel-loader\n我们来实现一个babel-loader来进行es6转es5,希望下面箭头函数转换为es5\n```js\n// src/index.js\nlet sum = (a, b) => a + b;\n``` \n```js\n// src/loaders/babel-loader.js\nlet babel = require(\"@babel/core\");\nfunction loader(source) {\n  console.log(\"加载babel-loader\");\n  let options = {\n    presets: [\"@babel/preset-env\"], // 预设(插件集合), babel本质就是一个转换器, 需要预设/插件才能转换代码,否则就是一个流程器\n    // 生成sourceMap (注意: 这里设为true, 只是表示babel会生成sourceMap给webpack, 最终打包是否生成sourceMap文件,是webpack控制的, 所以还需要webpack的配置devtool:source-map, 否则sourceMap文件不会生成)\n    // 此处为true, webpack的devtool:source-map,  调试会看到index.js,且是es6源代码\n    // 此处为false, webpack的devtool:source-map,  调试会看到index.js, 且是es5代码\n    // 此处为true, webpack的devtool:false,  调试会看到main.js, 且是es5代码\n    // 此处为false, webpack的devtool:false,  调试会看到main.js, 且是es5代码\n    // 所以需要同时开启才能在谷歌控制台看到es6源代码+源文件\n    sourceMap: true, \n  };\n  //   转换后的es5代码 source-map文件 抽象语法树\n  const { code, map, ast } = babel.transform(source, options);\n  //   因为babel转换后提供了ast, 那么webpack会直接使用这个ast, 不会自己再通过acron解析器将code转ast了, 提高效率, 所以如果loader有ast,可以直接用\n//  在loader执行时,this指向loaderContext, 它上面有个callback方法, 用来返回结果\n  return this.callback(null, code, map, ast);\n}\nmodule.exports = loader;\n```\n### 总结\n- 原理很简单, **loader本质上就是一个函数**, 最终通过**this.callback**给webpack返回结果, webpack会根据返回结果进行下一步操作\n  - callback接收三个参数: code-转换后的es5代码, map-sourceMap文件, ast-抽象语法树\n  -  因为babel转换后提供了ast, 所以调用callback传进去, 那么webpack会**直接使用这个ast**, 不会自己再通过acron解析器将code转ast了, 提高效率, 所以如果loader有ast,可以直接用\n- loader的sourceMap和webpack.config.js中的devtool:'source-map'需要**同时开启,才会生效**\n  - webpack的devtool:source-map、loader的sourceMap:true,  谷歌控制台调试会看到index.js, 是es6源代码\n  - webpack的devtool:source-map、loader的sourceMap:false, 会看到index.js, 是es5代码\n  - webpack的devtool:false、loader的sourceMap:true, 会看到main.js, 是es5代码\n  - webpack的devtool:false、loader的sourceMap:false, 会看到main.js, 是es5代码\n\n\n>[学习webpack loader](https://zhuanlan.zhihu.com/p/659040417)","categories":["webpack4"]},{"title":"3.工作流程","url":"/ypf-blog/2024/12/23/webpack4/3.工作流程/","content":"# 手动打包\n我们一般都是执行`npm run build`进行打包, 实际上webpack本质就是一个Compiler类,导出的是一个实例.我们可以手动调用实例进行打包.[Node 接口文档](https://www.webpackjs.com/api/node/)\n\n```js\nconst webpack= require(\"webpack\");\nconst config = require(\"../webpack.config.js\");\n\n// 初始化编译器\nconst compiler = webpack(config);\n// 调用run方法进行打包编译\ncompiler.run((err, stats) => {\n  if (err || stats.hasErrors()) {\n    // ...\n  }\n   // 过滤显示字段(颗粒化控制)\n  console.log(stats.toJson({\n    chunks: true, // 显示代码块\n    modules: true, // 显示模块\n    assets: true, // 显示资源文件\n  }));\n});\n```\n[stats.toJson](https://www.webpackjs.com/api/node/#statstojsonoptions)\n- 返回是一个对象, 包含打包的文件信息、内容、依赖模块等[信息](https://www.webpackjs.com/api/stats/#asset-objects)\n\n现在我们来手动实现下webpack实例来了解webpack的工作流程\n\n# 工作流程\n## 初始化参数\n- 从配置文件和shell语句中读取与合并参数，得出最终的参数\n```js\nlet config = require(\"../webpack.config\");\nclass Compiler {\n  constructor(config) {\n    this.config = config;\n    // 注册插件钩子函数-下面注册插件用\n    this.hooks = {\n      emit: new SyncHook(),\n    };\n  }\n  apply(){}\n}\n```\n\n## 初始化实例\n- 用上一步得到的参数配置，初始化生成一个Compiler实例\n```js\nlet compiler = new Compiler(config);\n```\n\n## 循环注册插件\n- 读取配置中的plugins选项，**循环并注册插件** (此时插件只是注册(添加到待执行队列中),没有执行),往插件传入compiler实例\n```js\nfor (let plugin of config.plugins) {\n  plugin.apply(compiler);\n}\n```\n- 插件调用实例的**订阅方法**, 将回调函数加入实例队列中等待后续执行, 实际webpack依赖的是`tapable`库,这里咱们自己实现了tapable库\n```js\n// src/plugins/InfoPlugin.js\nclass InfoPlugin {\n    apply(compiler) {\n        compiler.hooks.emit.tap('InfoPlugin', (assets) => {\n            console.log('InfoPlugin',assets);\n        });\n    }\n}\nmodule.exports = InfoPlugin;\n```\n```js\n// src/utils/syncHook.js\n// 自己实现tapable\nclass SyncHook {\n  constructor(args) {\n    this.tasks = [];\n  }\n  //   注册事件\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n  //   触发事件\n  call(...args) {\n    this.tasks.forEach((task) => {\n      task(...args);\n    });\n  }\n}\nmodule.exports = SyncHook;\n```\n我们可以看到上面就是一个发布订阅模式\n\n\n## 执行实例compiler的run方法，开始编译\n```js [toggle]\n// webpack工作流程\nclass Compiler {\n  constructor(config) {\n    this.config = config;\n    // 注册插件钩子函数\n    this.hooks = {\n      emit: new SyncHook(),\n    };\n  }\n  run() {\n    let entries = []; // 所有入口\n    let chunks = []; // 所有chunk\n    let modules = []; // 所有模块, chunk就是入口生成的js,module就是chunk依赖的各个模块, chunk包含module\n    let assets = {}; // 待输出文件chunk对象\n    // 4-1.获取入口文件路径\n    let entry = path.join(this.config.context, this.config.entry);\n    entries.push(entry);\n    // 4-2.从入口文件出发，调用所有配置的loader进行编译(如果非js文件都需要loader处理)\n    let rawEntryContent = fs.readFileSync(entry, \"utf8\"); // 读取入口文件内容\n    let entrySource = babelLoader(rawEntryContent); // loader本质就是一个函数, 模拟babel-loader处理得到转换后的内容\n    //  入口模块\n    let entryModule = {\n      id: \"./src/index.js\",\n      source: entrySource,\n      name: \"main\", // 哪个入口依赖的\n    };\n    modules.push(entryModule);\n    // 4-3.将入口模块编译成ast,然后递归识别找到里面的依赖模块以及依赖的依赖(require、import),比如index.js依赖了require('a.css'),\n    let cssPath = path.join(this.config.context, \"./src/a.css\");\n    let rawCssContent = fs.readFileSync(cssPath, \"utf8\");\n    let cssSource = cssLoader(rawCssContent);\n    let cssModule = {\n      id: \"./src/a.css\",\n      source: cssSource,\n      name: \"main\", // 哪个入口依赖的\n    };\n    modules.push(cssModule);\n    // 4-4.将入口转换为chunk(默认一个入口一个chunk.js), 一个chunk.js包含多个依赖模块\n    let chunk = {\n      id: \"main\",\n      modules: [entryModule, cssModule],\n    };\n    chunks.push(chunk);\n    // 5.将chunk转换为一个个单独的文件加入到输出列表(这步是修改输出内容的最后机会)\n    for (let chunk of chunks) {\n      assets[chunk.id + \".js\"] = `\n    (function (modules) {\n            return __webpack_require__(\"./src/[chunk.id].js\"); // 加载入口文件\n     })({\n        \"./src/[chunk.id].js\": function (module, exports, __webpack_require__) {\n        },\n    });\n    `;\n    }\n    this.hooks.emit.call(assets); // 执行插件\n    // 6. 遍历输出列表，写入文件系统\n    for (let fileName in assets) {\n      fs.writeFileSync(\n        path.join(this.config.output.path, fileName),\n        assets[fileName]\n      );\n    }\n  }\n}\nfunction babelLoader(content) {\n  return `\n    let sum=(a,b)=>a+b\n    require('./a.css')\n  `;\n}\nfunction cssLoader(content) {\n  return `\n        let style= document.createElement('style')\n        style.innerHTML=${JSON.stringify(content)}\n        document.head.appendChild(style)\n    `;\n}\n```\n我们来分步骤讲解下\n\n### 从配置读取入口路径\n```js\nlet entries = []; // 所有入口(比如多入口)\nlet entry = path.join(this.config.context, this.config.entry);\nentries.push(entry);\n```\n### 获取入口内容调用loader编译并存入modules数组中\n```js\nlet rawEntryContent = fs.readFileSync(entry, \"utf8\"); // 读取入口文件内容\nlet entrySource = babelLoader(rawEntryContent); // loader本质就是一个函数, 模拟babel-loader处理得到转换后的内容\n// 这里假设定义一个loader\nfunction babelLoader(content) {\n  return `\n    let sum=(a,b)=>a+b\n    require('./a.css')\n  `;\n}\n//  入口模块\nlet entryModule = {\n  id: \"./src/index.js\",\n  source: entrySource, // 编译后内容\n  name: \"main\", // 哪个入口依赖的\n};\nlet modules = []; // 存储所有模块, chunk就是根据入口生成的js,module就是chunk依赖的各个模块,所以一个入口一个chunk, 一个chunk包含module\nmodules.push(entryModule);\n```\n- loader本质上是一个函数, 就是**转换内容**,如babel-loader转换es6代码为es5代码\n- 转换后定义模块对象, 模块对象包含id路径、source编译后代码、name入口来源信息, 存入modules数组中\n\n### 将编译代码转ast获取依赖模块\n- 通过acorn库将loader转换后的代码转换为ast,然后识别ast, 收集依赖关系,从而形成一颗关系树.比如index.js依赖了require('a.css')\n```js\nlet cssPath = path.join(this.config.context, \"./src/a.css\");\nlet rawCssContent = fs.readFileSync(cssPath, \"utf8\");\nlet cssSource = cssLoader(rawCssContent);\nlet cssModule = {\n  id: \"./src/a.css\",\n  source: cssSource,\n  name: \"main\", // 哪个入口依赖的\n};\nmodules.push(cssModule);\n```\n- cssLoader是定义的loader, 模拟css-loader处理css文件, 得到js对象, 存入modules数组中\n\n### 将模块转换为chunk\n```js\nlet chunks = []; // 所有chunk\nlet chunk = {\n  id: \"main\",\n  modules: [entryModule, cssModule],\n};\nchunks.push(chunk);\n```\n### 5. 根据chunk构建输出js对象\n- 将chunk转换为一个个单独的文件加入到输出列表对象(这步是修改输出内容的最后机会),该对象就是输出文件名、内容\n\n```js\nfor (let chunk of chunks) {\n  assets[chunk.id + \".js\"] = `\n(function (modules) {\n        return __webpack_require__(\"./src/[chunk.id].js\"); // 加载入口文件\n  })({\n    \"./src/[chunk.id].js\": function (module, exports, __webpack_require__) {\n    },\n});\n`;\n}\n```\n\n### 执行插件\n```js\nthis.hooks.emit.call(assets); // 执行插件\n```\n- 执行发布订阅模式的发布, 将输出文件对象传入进去供**插件操作修改**\n\n### 遍历输出对象，写入文件系统到打包目录\n```js\nfor (let fileName in assets) {\n  fs.writeFileSync(\n    path.join(this.config.output.path, fileName),\n    assets[fileName]\n  );\n}\n```\n\n# 总结\n- **初始化参数**: 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。\n- **初始化实例**: 定义config、 定义钩子函数(发布订阅)供插件注册用\n- **从配置读取插件循环订阅注册**\n- **执行compile.run开始编译**\n  - 获取入口文件路径同时**fs读取入口内容进行loader转换**\n  - 将loader转换后的代码通过**acorn转ast获取依赖模块**, 如果依赖模块不是js也要调用loader进行转换\n  - **构建输出对象**: 即chunk对象(即要打包输出的js), chunk对象包含一个入口的所有module模块数组(入口模块和依赖模块)、打包输出的文件名id. 注意: 一个入口一个chunk, 一个chunk包含多个依赖module模块. 这一步是修改输出内容的最后机会,我们可以通过插件来修改\n  - **执行插件**: 传入构建对象,此时可以修改输出内容\n  - 遍历输出对象,**操作fs写入**文件系统(打包文件夹)\n\n\n","categories":["webpack4"]},{"title":"2.按需加载","url":"/ypf-blog/2024/12/12/webpack4/2.按需加载/","content":"# import按需加载\n> 我们知道,webpack打包默认把所有模块都会打包出一个js, 如上节讲的 `main.js`.这样会导致文件过大,所以我们需要按需加载(分割js)\n\n```js \n// title.js\nmodule.exports = \"title\";\n// title-es.js\nexport default \"title-es\";\n// index.js\nconst a = import(\"./title\");\nconst b = import(\"./title-es\");\nconsole.log(a, b);\na.then((res) => {\n  console.log(res, \"res-commonjs\");\n});\nb.then((res) => {\n  console.log(res, \"res-es\");\n});\n```\n打包运行如下图:\n<img src=\"images/1.jpg\" width=\"50%\"/>\n<img src=\"images/2.jpg\" width=\"50%\"/>\n上图, title被打包到1.js, title-es被打包到0.js. 剩下就是主入口main.js\n\n- 在webpack中, 只要通过`import('xxx')`引入的模块,打包的时候都会`生成单独的js`文件,不会合并到入口js中,也就是说`入口的js都是同步js`.\n  - 这里说的是`import('xx')引入文件`,会生成单独js\n  - 不是`import xx from 'xxx'这种引入属性`,这种还是合并到入口js中\n- 如果通过import引入模块里面内部也有通过import引入, 其内部引入的也会生成单独的js, 所以只要import引入模块都会生成单独js\n- 默认分离的模块名是webpack自己生成的, 当然也可以使用webpack提供的`魔法注释`自定义\n- 返回是一个`promise`,查看then返回结果,无论es还是commonjs模块, 都会变成下面这种es对象\n  - default: 模块的默认导出\n  - keys: 模块的属性\n  - __esModule: true\n  - Symbol(Symbol.toStringTag): Module\n\n## 魔法注释\n> 魔术注释(Magic Comments)是由 Webpack 提供的，可以为代码分割服务的一种技术。通过在 import 关键字后的括号中使用指定注释，我们可以对代码分割后的 chunk 有更多的控制权。\n- `webpackChunkName`: 用来指定打包后的文件名\n- `webpackPrefetch`: 资源预拉取\n- `webpackPreload`: 资源预加载\n- ...[等等](https://rain120.github.io/study-notes/engineering/webpack/magic-comments)\n  \n```js\nconst a = import(/* webpackChunkName: \"test\" */ \"./title\");\n```\n上面截图我们知道title打包后是1.js, 我们重命名后就会变成title.js\n- 如果同一个模块, 一个使用重命名,一个没有,经测试, 最终只会生成`一个重命名的js`,无论执行顺序怎么调换\n\n```js\nconst a = import(/* webpackChunkName: \"test\" */ \"./title\");\nconst b = import( \"./title\");\n```\n上面代码经测试,最终只会生成一个test.js,没有0.js,  倒换顺序也一样\n\n# 实现原理\n我们就用上面的demo,分步骤讲解下打包后的代码\n## 入口\n```js [toggle]\n(function (modules) {\n   ...\n})({\n  \"./src/index.js\": function (module, exports, __webpack_require__) {\n    // 按需加载\n    const a = __webpack_require__\n      .e(1)\n      .then(__webpack_require__.t.bind(null, \"./src/title.js\", 7));\n    const b = __webpack_require__\n      .e(0)\n      .then(__webpack_require__.bind(null, \"./src/title-es.js\"));\n    console.log(a, b);\n    a.then((res) => {\n      console.log(res, \"res-commonjs\");\n    });\n    b.then((res) => {\n      console.log(res, \"res-es\");\n    });\n  },\n});\n```\n我们可以看到\n- 入参只有入口js,按需(import)引入的js不会出现在入口入参中,只会变成为`__webpack_require__.e(1).then(__webpack_require__.t.bind(null, \"./src/title.js\", 7))`\n- import('xx')转换为promise\n```js\n// commonjs模块 \n// const a = import(\"./title\");\n__webpack_require__.e(1)  // 这里1是打包后的文件名1.js,如果用了魔法注释,就是修改后的文件名\n                   .then(__webpack_require__.t.bind(null, \"./src/title.js\", 7)) // promise \n// es模块        \n// const b = import(\"./title-es\");\n__webpack_require__.e(0)  // 这里0是打包后的文件名0.js\n                   .then(__webpack_require__.bind(null, \"./src/title-es.js\"))  // promise \n```\n__webpack_require__我们上节讲过(手动实现require函数),接下来我看下 `__webpack_require__.e`\n\n## __webpack_require__.e 动态加载chunk\n> 核心方法: 用来动态加载模块chunk\n```js [toggle]\n//  未加载:undefined     chunk not loaded\n//  预加载/预获取:null    chunk preloaded/prefetched\n//  正在加载中:Promise    chunk loading\n//  加载成功:0           chunk loaded\n//  存放chunk的加载状态\nvar installedChunks = {\n  main: 0, // 默认主入口模块加载成功\n};\n// 动态加载模块\n__webpack_require__.e = function requireEnsure(chunkId) {\n  var promises = [];\n  var installedChunkData = installedChunks[chunkId];\n  if (installedChunkData !== 0) { // 模块!==加载成功\n    if (installedChunkData) { // 有值肯定是promise,表示正在加载模块\n      promises.push(installedChunkData[2]);\n    } else {\n      // 第一次肯定是undefined-未加载\n      // 为模块创建一个promise\n      var promise = new Promise(function (resolve, reject) {\n        installedChunkData = installedChunks[chunkId] = [resolve, reject]; // 缓存模块\n      });\n      promises.push((installedChunkData[2] = promise)); // [resolve,reject,promise]\n\n      // 开始加载模块 start chunk loading\n      var script = document.createElement(\"script\");\n      var onScriptComplete;\n\n      script.charset = \"utf-8\";\n      script.timeout = 120;\n      // __webpack_require__.p  是 webpack.config.js中配置的output.publicPath\n      script.src = __webpack_require__.p + \"\" + chunkId + \".js\";\n\n      // create error before stack unwound to get useful stacktrace later\n      var error = new Error();\n      onScriptComplete = function (event) {\n        // avoid mem leaks in IE.\n        script.onerror = script.onload = null;\n        clearTimeout(timeout); // 清除120s 定时器\n        var chunk = installedChunks[chunkId]; // 加载状态\n        if (chunk !== 0) {\n          if (chunk) {\n            var errorType =\n              event && (event.type === \"load\" ? \"missing\" : event.type);\n            var realSrc = event && event.target && event.target.src;\n            error.message =\n              \"Loading chunk \" +\n              chunkId +\n              \" failed.\\n(\" +\n              errorType +\n              \": \" +\n              realSrc +\n              \")\";\n            error.name = \"ChunkLoadError\";\n            error.type = errorType;\n            error.request = realSrc;\n            chunk[1](error);\n          }\n          installedChunks[chunkId] = undefined;\n        }\n      };\n      // 定时器开始, 如果120s后执行了,说明定时器没有被清除, 加载超时了\n      var timeout = setTimeout(function () {\n        onScriptComplete({ type: \"timeout\", target: script });\n      }, 120000);\n      script.onerror = script.onload = onScriptComplete;\n      document.head.appendChild(script);\n    }\n  }\n  return Promise.all(promises);\n};\n```\ndemo代码`__webpack_require__.e(1)`逻辑梳理如下:\n- 全局变量`installedChunks` 用来缓存模块加载状态, 初始化默认 `main`主入口模块,状态为`0`表示加载成功\n  - `undefined`: 未加载\n  - `null`: 预加载/预获取\n  - `Promise`: 正在加载中\n  - `0`: 加载成功\n- 判断`installedChunks[chunkId]`状态是否为0, 第一次肯定不为0,是undefined\n  - new一个promise(只为了等待加载js的pending用), `installedChunks[chunkId]=[resolve, reject, promise]`,同时定义promises数组存入该promise.\n  - document.createElement创建script,然后插入head标签中开始加载chunkId对应的模块. 同时开始120s的定时器超时.\n  - 最后 `return Promise.all(promises)`\n\n我们加载了chunk,那加载成功后,如后回调?\n\n## window.webpackJsonp桥回调函数\nwebpack是在window上定义了一个桥(window.webpackJsonp)用来存放执行加载成功的回调.\n```js\n// main.js\nwindow[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\nwebpackJsonp.push = ([chunkIds,moreModules])=> {\n    var moduleId,\n      chunkId,\n      i = 0,\n      resolves = [];\n    //  标记为0，到此表示加载成功\n    for (; i < chunkIds.length; i++) {\n      chunkId = chunkIds[i];\n      const installedChunksData = installedChunks[chunkId]; // [resolve, reject, promise]\n      const resolve = installedChunksData[0];\n      resolves.push(resolve);\n      installedChunks[chunkId] = 0; // 标记为0，到此表示加载成功\n    }\n    // 合并到modules参数中\n    for (moduleId in moreModules) {\n      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n        modules[moduleId] = moreModules[moduleId];\n      }\n    }\n    // 依次执行resolve方法从而触发后面then(shift-删除数组中第一个元素，并返回)\n    while (resolves.length) {\n      resolves.shift()();\n    }\n};\n```\n- `window[\"webpackJsonp\"]`是一个回调函数桥, 接收模块id和模块对象, chunkIds是模块id, moreModules是模块对象\n- 该桥定义push方法,`让chunk来调用`传入.(因为各个chunk都是独立文件,通过window定义变量操作就方便了)\n结合下面chunk调用push,我们理下逻辑:\n  - 标记模块加载成功: `installedChunks[chunkId] = 0`\n  - 将模块对象合并到我们上节课讲的自执行函数的modules参数中,因为初始化入参只包含了入口模块对象(非动态加载模块对象), 合并后就包含了各个chunk对象了\n  - 循环执行`resolve`方法用来触发`__webpack_require__.e`的then\n\n\n## chunk\n我们看下分离出的chunk代码:\n```js\n// 1.js\nwindow[\"webpackJsonp\"].push([\n  [1], // chunkId-生成的chunk文件名\n  // 上节课讲的入口加载的各个模块对象\n  {\n    \"./src/title.js\": function (module, exports) {\n      module.exports = {\n        title: \"title\",\n        age: \"age\",\n        age1: \"age1\",\n      };\n    },\n  },\n]);\n```\n\n## __webpack_require__.t统一返回chunk对象\n> 主要目的是将commonjs转换为es模块(增加了default属性), 因为es模块是有default属性, 为了和他一致,这样通过import的then拿到的返回格式一样.\n```js [toggle]\n// mode & 1: value is a module id, require it value是一个模块id,需要__webpack_require__加载\n// mode & 2: merge all properties of value into the ns 合并value的所有属性到ns对象 中\n// mode & 4: return value when already ns object 如果ns是一个对象, 直接返回\n// mode & 8|1: behave like require 如果是8按位或1(即 1000 | 0001 === 1001 即 十进制9 ), 和require方法一样\n__webpack_require__.t = function (value, mode) {\n  //    value是一个模块id,需要__webpack_require__加载\n  if (mode & 1) value = __webpack_require__(value);\n  // value是es模块,直接返回\n  if (mode & 8) return value;\n  // value已经是一个ns对象,直接返回\n  if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n    return value;\n  var ns = Object.create(null);\n  __webpack_require__.r(ns);\n  Object.defineProperty(ns, \"default\", { enumerable: true, value: value });\n  if (mode & 2 && typeof value != \"string\")\n    for (var key in value)\n      __webpack_require__.d(\n        ns,\n        key,\n        function (key) {\n          return value[key];\n        }.bind(null, key)\n      );\n  return ns;\n};\n```\n- `__webpack_require__.t`方法接收两个参数, 第一个是模块id, 第二个是模式, 模式是二进制位, 用来判断是否需要转换模块\n- 对于common模块主要是创建空对象,然后default保存整个对象, 每个属性合并过去, 增加`__esModule: true` `Symbol(Symbol.toStringTag): Module`,最后return这个对象\n再看下运行结果(上面已经看过的图):\n<img src=\"images/1.jpg\" width=\"50%\"/>\n\n# 总结\n结合{% post_link webpack4/6.手写webpack 手写webpack %}讲解,我们来理一下整体流程:\n- 编译的时候, 在normalModuleFactory中的ast解析中,判断import(xx)引入,将ast改成\n```js\n nodePath.replaceWithSourceString(`\n  __webpack_require__.e(\"1\").then(__webpack_require__.t.bind(null,\"./src/title.js\"))\n`);\n// 1就是chunkName打包后的文件名\n```\n- 在最后生成chunk文件的时候,判断async,就通过chunkTemplate为chunk生成代码\n```js\n(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[\"<%-chunkName%>\"], {\n    <%\n    for(let module of modules)\n    {%>\n        \"<%-module.moduleId%>\":\n        (function (module, exports, __webpack_require__) {\n          <%-module._source%>\n        }),\n    <%}\n  %> \n  }]);\n```\n- main.js中定义了`__webpack_require__.e`方法和`__webpack_require__.t`方法.\n  其中`.e方法`就是用来实现动态加载的\n  - 定义installedChunks对象`存储模块加载状态`, 默认为0-加载成功, 未加载:undefined 正在加载中:Promise  预加载/预获取:null\n  - 定义window[\"webpackJsonp\"]=([chunkIds,moreModules])=>{}`桥方法`,用来供`模块加载成功调用`\n  - 动态`创建script`然后插入head标签中`开始加载模块`(每个模块都new一个promise只用来pending),并写死120s倒计时, 模块加载成功时, 模块内部就会调用`window[\"webpackJsonp\"].push(模块)`方法\n  - `更改`模块`加载状态为0`并合并到main.js的`入参`中,然后执行promise的resolve方法\n\n- 此时已经完成了动态加载,但为了`统一`我们import(xx模块可能是es/common)`返回格式`, 就用`.t`方法, 都`统一为es格式`\n  - common模块: 创建一个空对象,然后default保存整个对象, 每个属性放进去, 增加`__esModule: true`和`Symbol(Symbol.toStringTag): Module`,最后return这个对象\n  - es不变(编译的时候会直接把代码改成和上面一样的格式)直接return出去\n","categories":["webpack4"]},{"title":"1.打包文件分析","url":"/ypf-blog/2024/12/02/webpack4/1.打包文件分析/","content":"# 初始化工程目录\n```bash\nnpm install webpack webpack-cli html-webpack-plugin -D\n```\n```js\n// webpack.config.js\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n  mode: \"development\", // or 'production'打包模式\n  devtool: false, // 是否生成source map \n  entry: \"./src/index.js\", // 入口文件\n  output: {\n    // filename: \"bundle.js\", // 打包后的文件名\n    path: path.resolve(__dirname, \"dist\"), // 输出路径(只能是绝对路径,不能是相对路径)\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \"./src/index.html\", // 指定模板文件路径\n    }),\n  ],\n};\n```\n# commonjs加载commonjs模块\n入口文件\n```js\n// index.js\nlet title=require('./title')\nconsole.log(title);\n```\n依赖模块\n```js\n// title.js\nmoudle.exports = \"title\";\n```\n我们运行`npm run build`看下打包后的js, 这里我们删除了注释、以及暂时用不到的代码,只保留了最核心的代码.\n\n## module.exports和exports和this\n###  module.exports和exports\n在看核心代码之前,我们先来分析下 exports 和 module.exports 的区别.\n- exports本质上是对module.exports的引用, 所以 exports和module.exports是等价的.其默认值是 `{}`, 但在使用上存在部分差异.\n```js\nconsole.log(exports === module.exports,exports, module.exports); // true {} {}\n```\n- exports用来导出多个模块, module.exports用来导出单个模块.\n```js\nexports.a=1; exports.b=2;\n// 等同于\nmodule.exports={a:1,b:2}\n```\n- exports和module.exports都可以添加属性.\n```js\nexports.a=1; module.exports.b=2;\n// 等同于\nmodule.exports={a:1,b:2}\n```\n- exports和module.exports一起用, 如果是`module.exports=`而不是上面的添加属性, 则只有module.exports起作用.在模块加载时，require返回的是module.exports，而不是exports\n```js\n// test.js\nmodule.exports=2;\nexports.a=1; // 不起作用, 和上面互换顺序也是同样结果\n// index.js\nconst res=require('./test')\nconsole.log(res) // 2\n```\n\n### this\n\n- this指向当前模块, 而不是全局对象. 函数中的this是全局对象, 而不是当前模块.(如果是构造函数调用,此时this还是js中的实例)\n```js\nconsole.log(this); // {}\nconsole.log(this===global); // false\nconsole.log(this===module.exports); // true\nconsole.log(this===exports); // true\nfunction test(){\n    console.log(this===global); // true\n}\ntest()\n```\n- this指向当前模块, 相当于exports.a = 1 或者 module.exports.a = 1\n```js\n// test.js\nthis.a=1\n// index.js\nconst res=require('./test')\nconsole.log(res) // {a:1}\n```\n\n- global是全局对象,在上面定义的属性, 任意模块都可以访问,不需要导出\n```js\n// test.js\nglobal.a=1\n// index.js\nconst a=require('./a')\nconsole.log(a) {}\nconsole.log(global.a) // 1\n```\n## 核心代码\n举个例子:\n```js\n// title.js\nmoudle.exports = \"title\";\n\n// index.js 入口文件\nlet title=require('./title')\nconsole.log(title); // title\n```\n打包后的js文件,我们删除掉暂时用不到的代码, 来分析下核心代码:\n```js\n// 自执行函数\n(function (modules) {\n  var installedModules = {}; // 模块缓存\n  // 自己实现一个require方法,浏览器没有require(基于commonjs规范)\n  function __webpack_require__(moduleId) {\n    //  判断缓存中有没有该模块\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // 创建模块对象,并且放到缓存中\n    var module = (installedModules[moduleId] = {\n      i: moduleId, // 模块id (id)\n      l: false, // 是否已经加载过了(loaded)\n      exports: {}, // 导出对象,默认空对象\n    });\n\n    // 执行模块方法 \n    modules[moduleId].call(\n      module.exports, // this指向自定义模块导出对象 \n      module,\n      module.exports,\n      __webpack_require__\n    );\n\n    // 标记该模块已经加载过\n    module.l = true;\n\n    // 返回模块导出对象\n    return module.exports;\n  }\n  return __webpack_require__(\"./src/index.js\"); // 加载入口文件\n})({\n  \"./src/index.js\": function (module, exports, __webpack_require__) {\n    let title = __webpack_require__(\"./src/title.js\");\n    console.log(title);\n  },\n\n  \"./src/title.js\": function (module, exports) {\n    moudle.exports = \"title\";\n  },\n});\n```\n我们梳理下思路:\n1. 打包后是一个**自执行函数**\n   - 函数的参数是一个对象, 包含所有require过的模块\n   - key是模块的相对路径(以项目根目录为起点, 实际是执行打包时候的目录,一般都是根目录打包)\n   - value是一个函数, 函数体的内容就是模块的源代码, 只不过因为浏览器没有require方法, 所以变成了自定义的__webpack_require__方法用于加载模块.\n2. 自执行函数执行时\n   - **初始化已加载模块缓存**: `var installedModules = {};`\n   - **定义自定义的require方法**: `function __webpack_require__(moduleId) {...}`\n   - **return加载入口文件开始执行**: `return __webpack_require__(\"./src/index.js\")`\n3. 因为调用__webpack_require__,入参是入口模块path, 此时**开始执行__webpack_require__函数**\n   - **判断缓存中有没有该模块**: 如果有,则直接返回该模块的exports对象, 否则继续执行\n   - **初始化定义模块对象并放入缓存中**: 有3个属性,(模块id(即path)、是否加载过、导出对象(默认为空对象))\n  ```js\n  // 创建模块对象,并且放到缓存中\n  var module = (installedModules[moduleId] = {\n    i: moduleId, // 模块id (id)\n    l: false, // 是否已经加载过了(loaded)\n    exports: {}, // 导出对象,默认空对象\n  });\n  ```\n   - **执行对应模块key方法**: 通过call方法,将this指向自定义模块导出对象module.exports,并传入模块对象module、模块导出module.exports、自定义require方法,因为模块对象模块导出对象是自己定义的,所以相当于原来导出使用的这2个key就变成自己定义的了.\n      - 执行对应模块函数时候,里面如果有__webpack_require__继续**递归执行**\n   - **标记该模块已经加载过**: `module.l = true;`\n   - **返回模块导出对象**: `return module.exports;`\n\n**注**: 改变this指向,是因为node.js中的commonjs模块, `this===module.exports`, 所以我们指向自己实现的module.exports\n\n<img src=\"images/1.jpg\" height=\"500\"/>\n\n# commonjs加载es模块\n\n## Symbol.toStringTag\n`Symbol.toStringTag`用于自定义对象类型.当使用 `Object.prototype.toString`或者`toString()` 方法时，返回该类型。\n- JavaScript 语言在 ES6 规范中引入了 Symbol 类型，它是一种原始数据类型，用于创建唯一的标识符.Symbol 对象是不可改变且唯一的，适合用作对象属性的键。除了作为对象的属性键之外，Symbol 还有许多静态属性, `Symbol.toStringTag` 是其中一个。\n  \n```js\nconst a = document.createElement(\"button\");\nconsole.log(a.toString()); // [object HTMLButtonElement]\nconsole.log(Object.prototype.toString.call(a)); // [object HTMLButtonElement]\nconsole.log(a[Symbol.toStringTag]) // HTMLButtonElement\n\nconst a=new Map()\nconsole.log(a.toString()); // [object Map]\nconsole.log(Object.prototype.toString.call(a)); // [object Map]\nconsole.log(a[Symbol.toStringTag]) // Map\n\nconst a={}\nconsole.log(a.toString()); // [object Object]\nconsole.log(Object.prototype.toString.call(a)); // [object Object]\nconsole.log(a[Symbol.toStringTag]) // undefined 不能访问\n```\n上面代码我们可以看到有些是可以直接访问`Symbol.toStringTag`, 但是有些是访问不到的.\n### 自定义对象类型\n```js\n// 自定义前\nclass MyClass {}\nconst myObj = new MyClass();\nconsole.log(myObj.toString()); // [object Object]\n// 自定义后\nclass MyClass {\n  get [Symbol.toStringTag]() {\n    return \"foobar\";\n  }\n}\nconst myObj = new MyClass();\nconsole.log(myObj.toString()); // [object foobar]\nconsole.log(myObj)\n```\n<img src=\"images/2.jpg\" width=\"80%\"/>\n\n自定义前的图就不截了,是看不到 `Symbol(Symbol.toStringTag)`的\n\n```js\n// 自定义前\nconst obj={}\nconsole.log(obj.toString()) // [object Object]\nconsole.log(obj[Symbol.toStringTag]) // undefined\nconsole.log(obj)\n\n// 自定义后\nconst obj1={}\nObject.defineProperty(obj1,Symbol.toStringTag,{\n  value:'foobar'\n})\nconsole.log(obj1.toString()) // [object foobar]\nconsole.log(obj1[Symbol.toStringTag]) // foobar\nconsole.log(obj1)\n```\n<img src=\"images/3.jpg\" width=\"80%\"/>\n\n\n## 核心代码\n举个例子:\n```js\n// title.js\nmoudle.exports = \"title\";\n// title-es.js\nlet a=\"title\"\nexport default a\nexport const age = 'age'\nexport const age1 = 'age1'\n\n// index.js 入口文件\nlet title=require('./title')\nlet titleEs=require('./title-es')\nconsole.log(title);\nconsole.log(titleEs);\n```\n<img src=\"images/4.jpg\" width=\"80%\"/>\n\n我们看打印结果\n- title,打印的是我们上面讲过的title\n- title-es,打印的是一个对象,对象中有命名导出`age、age1`, 默认导出`default`,以及增加了`__esModule、Symbol(Symbol.toStringTag)属性`,所以webpack最终是**将es模块编译成commonjs模块**的.\n\n打包后的js文件,我们删除掉暂时用不到的代码, 来分析下核心代码:\n```js [toggle]\n(function (modules) {\n  var installedModules = {};\n  function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    var module = (installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {},\n    });\n    modules[moduleId].call(\n      module.exports,\n      module,\n      module.exports,\n      __webpack_require__\n    );\n    module.l = true;\n    return module.exports;\n  }\n  __webpack_require__.d = function (exports, name, getter) {\n    // 判断exports有没有该属性\n    // 为什么要用__webpack_require__封装成函数,不直接用Object.prototype.hasOwnProperty判断,目的是为了减少打包体积,因为可能其他地方也要判断, 封装成函数都调用该函数, 所以减少了打包体积\n    if (!__webpack_require__.o(exports, name)) {\n      // 定义该属性\n      Object.defineProperty(exports, name, { enumerable: true, get: getter });\n    }\n  };\n\n  // define __esModule on exports 在导出对象上定义__esModule属性\n  // 1.创建模块对象\n  // 2.增加__esModule属性表示该模块是一个es模块\n  __webpack_require__.r = function (exports) {\n    if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n      Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n      // 相当于 export[Symbol.toStringTag]=\"Module\"\n      // 目的: 当使用 Object.prototype.toString.call(exports), 打印是 \"[object Module]\"表示是一个模块对象\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // 相当于 exports.__esModule=true\n    // 目的: 如果exports的对象有 __esModule 属性, 表示这个模块打包前是一个es模块, 因为ewbpack不管什么模块,最终都会打包成commonjs模块, 所以需要知道原来是什么模块,通过该属性来区分\n  };\n  // 判断对象有没有该属性\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  return __webpack_require__((__webpack_require__.s = \"./src/index.js\"));\n})({\n  \"./src/index.js\": function (module, exports, __webpack_require__) {\n    let title=__webpack_require__(\"./src/title.js\")\n    let titleEs=__webpack_require__(\"./src/title-es.js\")\n    console.log(title);\n    console.log(titleEs);\n  },\n  \"./src/title-es.js\": function (\n    module,\n    __webpack_exports__,\n    __webpack_require__\n  ) {\n    \"use strict\";\n    // 1.创建模块对象 2.增加__esModule属性表示该模块是一个es模块\n    __webpack_require__.r(__webpack_exports__);\n\n    // 处理命名导出,如 export const name=''\n    __webpack_require__.d(__webpack_exports__, \"age\", function () {\n      return age;\n    });\n    __webpack_require__.d(__webpack_exports__, \"age1\", function () {\n      return age1;\n    });\n\n    // 处理默认导出,如 export default\n    let a = \"title\";\n    __webpack_exports__[\"default\"] = a;\n    const age = \"age \";\n    const age1 = \"age1\";\n  },\n  \"./src/title.js\": function (module, exports) {\n    module.exports = \"title\";\n  },\n});\n```\n我们梳理下上面逻辑:\n- 对于es模块,会将module.exports变成`模块对象`, 并且增加`__esModule`属性, 表示该模块是一个es模块, 因为webpack不管什么模块,最终都会打包成commonjs模块, 所以需要知道原来是什么模块,通过该属性来区分\n- 处理`命名导出`, 即在exports上增加对应属性\n- 处理`默认导出`, 即在exports上增加default属性\n- __webpack_require__和上面的一模一样,没有变化\n\n# es模块加载es模块\n\n举个例子:\n```js\n// title-es.js\nlet a=\"title\"\nexport default a\nexport const age = 'age'\nexport const age1 = 'age1'\n\n// index.js 入口文件\nimport a, {age,age1} from './title-es'\nconsole.log(a,age,age1); // title age age1\n```\n\n## 核心代码\n```js [toggle]\n(function (modules) {\n  var installedModules = {};\n  function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    var module = (installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {},\n    });\n    modules[moduleId].call(\n      module.exports,\n      module,\n      module.exports,\n      __webpack_require__\n    );\n    module.l = true;\n    return module.exports;\n  }\n  __webpack_require__.d = function (exports, name, getter) {\n    if (!__webpack_require__.o(exports, name)) {\n      Object.defineProperty(exports, name, { enumerable: true, get: getter });\n    }\n  };\n  __webpack_require__.r = function (exports) {\n    if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n      Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n  };\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  return __webpack_require__((__webpack_require__.s = \"./src/index.js\"));\n})({\n  \"./src/index.js\": function (\n    module,\n    __webpack_exports__,\n    __webpack_require__\n  ) {\n    \"use strict\";\n    __webpack_require__.r(__webpack_exports__); // 声明es模块(准确来说含有es模块就会有该声明, 因为可以混用)\n    var _title_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/title-es.js\"); // 使用编译后的commonjs对象\n    console.log(\n      _title_es__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n      _title_es__WEBPACK_IMPORTED_MODULE_0__[\"age\"],\n      _title_es__WEBPACK_IMPORTED_MODULE_0__[\"age1\"]\n    );\n  },\n\n  \"./src/title-es.js\": function (\n    module,\n    __webpack_exports__,\n    __webpack_require__\n  ) {\n    \"use strict\";\n    __webpack_require__.r(__webpack_exports__);\n    __webpack_require__.d(__webpack_exports__, \"age\", function () {\n      return age;\n    });\n    __webpack_require__.d(__webpack_exports__, \"age1\", function () {\n      return age1;\n    });\n    let a = \"title\";\n    __webpack_exports__[\"default\"] = a;\n    const age = \"age\";\n    const age1 = \"age1\";\n  },\n});\n```\n我们梳理下上面逻辑:\n- 声明es模块(准确来说含有es模块就会有该声明, 因为可以混用)\n- 因为我们上面讲了es模块会转换为commonjs模块,所以在引入该模块的时候,这里就直接使用的是编译后的commonjs对象.\n\n# es模块加载commonjs模块\n\n举个例子:\n```js\n// title.js\nmodule.exports = {\n  title: \"title\",\n  age: \"age\",\n  age1:'age1'\n};\n\n// index.js 入口文件\nimport a, {age,age1} from './title'\nconsole.log(a,age,age1); // {title,age,age1} age age1\n```\n\n## 核心代码\n```js [toggle]\n(function (modules) {\n  var installedModules = {};\n  function __webpack_require__(moduleId) {\n    ...\n  }\n  __webpack_require__.d = function (exports, name, getter) {\n    if (!__webpack_require__.o(exports, name)) {\n      Object.defineProperty(exports, name, { enumerable: true, get: getter });\n    }\n  };\n  __webpack_require__.r = function (exports) {\n    if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n      Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n  };\n  // 获取默认导出(es取default, commonjs直接取对象)\n  __webpack_require__.n = function (module) {\n    // 注意这里的module不是__webpack_require__中的的module,是module.exports,\n    var getter =\n      module && module.__esModule // es模块\n        ? function getDefault() {\n            return module[\"default\"];\n          }\n        : function getModuleExports() {\n            // commonjs模块\n            return module;\n          };\n    //   定义a属性,值是上面的兼容性导出(为什么是a?不是b? 这里是webpack为了代码少, 就定义了一个字母, 也可以改成b没任何区别)\n    __webpack_require__.d(getter, \"a\", getter);\n    return getter;\n  };\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n\n  return __webpack_require__(\"./src/index.js\");\n})({\n  \"./src/index.js\": function (\n    module,\n    __webpack_exports__,\n    __webpack_require__\n  ) {\n    \"use strict\";\n    __webpack_require__.r(__webpack_exports__);\n    var _title__WEBPACK_IMPORTED_MODULE_0__ =\n      __webpack_require__(\"./src/title.js\");\n    var _title__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(\n      _title__WEBPACK_IMPORTED_MODULE_0__\n    );\n    // es加载common\n    console.log(\n      _title__WEBPACK_IMPORTED_MODULE_0___default.a,\n      _title__WEBPACK_IMPORTED_MODULE_0__[\"age\"],\n      _title__WEBPACK_IMPORTED_MODULE_0__[\"age1\"]\n    );\n  },\n\n  \"./src/title.js\": function (module, exports) {\n    module.exports = {\n      title: \"title\",\n      age: \"age\",\n      age1: \"age1\",\n    };\n  },\n});\n```\n我们梳理下上面逻辑:\n\n- 因为入口依赖commonjs, commonjs就是一个对象, 通过`.o `方法传入该对象, 做兼容处理(es取default, commonjs直接取对象)\n  \n# 总结\n- webpack无论什么模块都会转换为commonjs模块\n- commonjs不处理,原样输出. es模块编译成commonjs就是变成一个对象(里面有default、命名导出的属性、__esModule )以及模块类型 `[object Module]`\n- 无论原先使用require还是import引入,都会变成 `__webpack_require__(xxx)`引入\n- 先加载入口,再加载依赖","categories":["webpack4"]},{"title":"监控原理","url":"/ypf-blog/2024/10/12/monitor/监控原理/","content":"# 搭建上报框架\n我们定义一个基本上报框架结构:\n```js\n// https://www.npmjs.com/package/user-agent\nconst userAgent = require(\"user-agent\");\nfunction getExtraData() {\n  return {\n    userAgent: userAgent.parse(navigator.userAgent), // 浏览器信息\n    url: window.location.href, // 当前页面url\n    title: document.title, // 页面标题\n    timestamp: Date.now(), // 时间戳\n  };\n}\nclass SendTracker {\n  constructor(options) {\n    this.url = \"\"; // 上报接口地址\n  }\n  send(log = {}) {\n    const data = {\n      ...getExtraData(),\n      ...log,\n    };\n    console.log(data, \"上报\");\n    this.sendImg(data)\n  }\n  sendImg(data) {\n    const img = new Image();\n    img.src = this.url + \"?d=\" + JSON.stringify(data);\n    img.onload = function () {\n      // console.log(\"img onload\");\n    };\n    img.onerror = function (error) {\n      console.log(\"img onerror\");\n    };\n  }\n}\nexport default new SendTracker();\n```\n\n# 监控错误\n## js执行错误+资源加载错误\n### 举个🌰:\n```html\n<button onclick=\"showError('js')\" id=\"a\">js</button> // js执行错误\n<script src=\"/a.js\"></script>  // 资源加载错误 \n<script>\nfunction showError(type) {\n  window.test.a = 1;\n  // 或者主动抛出错误\n  // throw new Error('js error')\n}\n</script>\n```\njs执行错误\n<img src=\"images/2.jpg\" width=\"100%\"/>\n资源加载错误\n<img src=\"images/3.jpg\" width=\"100%\"/>\n\n### 实现\n```js\n  // 监听全局未捕获的错误\n  window.addEventListener(\"error\", function (e) {\n    let lastEvent = getLastEvent(); // 最后一个交互事件\n    let errorType='jsError'\n    if(e.target && (e.target.src || e.target.href)){ // 说明是资源加载错误\n      lastEvent=e\n      errorType='resourceError'\n    } \n    let log = {\n      kind: \"stability\", // 监控指标大类\n      type: \"error\", // 监控指标小类\n      errorType, // 错误类型-全局未捕获的错误\n      message: e.message, // 报错信息\n      filename: e.filename, // 错误文件\n      position: `${e.lineno}:${e.colno}`, // 错误行列\n      // 处理前: \"TypeError: Cannot set properties of undefined (setting 'a')\\n    at showError (http://localhost:9000/:15:30)\\n    at HTMLButtonElement.onclick (http://localhost:9000/:9:39)\"\n      stack: e.error&&e.error.stack?formatStack(e.error.stack):null, // 错误堆栈\n      selector: lastEvent ? getSelector(lastEvent) : \"\", //  最后一个交互事件对应的元素\n    };\n    tracker.send(log)\n  },true); // true代表在捕获阶段调用,false代表在冒泡阶段捕获,使用true或false都可以\n```\n主要核心点:\n- 格式化堆栈信息,**formatStack**\n- 获取用户操作哪个dom节点报的错,**getSelector(lastEvent)**\n\n### formatStack\n```js\n// 格式化堆栈信息\nfunction formatStack(stack) {\n  return stack\n    .split(\"\\n\")\n    .slice(1) // 删除message,已经有e.message属性了\n    .map((item) => item.replace(/^\\s+at\\s+/g, \"\"))\n    .join(\"^\");\n}\n```\n### lastEvent\n```js\nlet lastEvent;\n[\"click\", \"touchstart\", \"keydown\", \"mousedown\", \"mouseover\"].forEach(function (\n  eventType\n) {\n  window.addEventListener(\n    eventType,\n    function (e) {\n      lastEvent = e;\n    },\n    {\n      capture: true, //捕获阶段获取\n      passive: true, //true: 不阻止默认事件\n      //   once: false, //事件是否只执行一次\n    }\n  );\n});\nexport default function(){\n    return lastEvent;\n}\n```\n主要原理就是监听常见用户操作,获取event\n### selector\n```js\n// https://segmentfault.com/a/1190000043414306\n// 获取真实dom数组\nconst composedPath = (e) => {\n  // 当前有直接return\n  let pathArr = e.path || (e.composedPath && e.composedPath()); // 优先判断 Event.composedPath() 方法是否为空数组\n  if ((pathArr || []).length) {\n    return pathArr;\n  }\n  // 不存在则遍历target节点\n  let target = e.target;\n  e.path = [];\n  while (target.parentNode !== null) {\n    e.path.push(target);\n    target = target.parentNode;\n  }\n  // 最后在add进去 document 与 window对象\n  e.path.push(document, window);\n  return e.path;\n};\n// 格式化成字符串\nexport default function getSelector(event) {\n  const path = composedPath(event);\n  return path\n    .reverse()\n    .filter((el) => {\n      return el !== document && el !== window; // 去除document 和 window\n    })\n    .map((el) => {\n      let selector = \"\";\n      if (el.id) {\n        selector = `#${el.id}`;\n      } else if (el.className) {\n        selector = el.className\n          .split(\" \")\n          .map((c) => `.${c}`)\n          .join(\"\");\n      } else {\n        selector = el.nodeName.toLowerCase();\n      }\n      return selector;\n    })\n    .join(\" \");\n}\n```\n\n- e.path谷歌已经移除, e.composedPath()有的浏览器没有该属性,不是标准方法\n- 我们通过e.target一层层网上找parentNode存数组里面\n- 最后将el数组通过`getSelector`格式化成字符串\n\ne.composedPath()以及自己实现composedPath函数的打印结果如下图:\n<img src=\"images/1.jpg\" width=\"50%\"/>\n\n## promise错误\n\n### 举个🌰:\n```html\n<button onclick=\"showError('promise')\" class=\"promise a\">promise</button>\n<script>\n  function showError(type) {\n    new Promise((resolve, reject) => {\n         window.test.a = 1;\n          // 或者主动抛出错误\n          // reject(\"error\"); \n          // reject({\n          //     a:1\n          // }) // 注意, reject对象,e.message是undefined,其他信息都有, 所以reject最后抛出字符串\n      }).then(() => {\n        console.log(1);\n      })\n      // 注意,如果加上catch,上面不会被捕获,因为已经catch了\n      // .catch(()=>{})\n  }\n</script>\n```\n<img src=\"images/4.jpg\" width=\"100%\"/>\n\n### 实现\n```js\n  // 监听promise错误(如果有catch不会触发下面函数, 没有catch才会触发)\n  window.addEventListener(\"unhandledrejection\", function (e) {\n    let lastEvent = getLastEvent(); // 最后一个交互事件\n    let message;\n    let lineno;\n    let colno;\n    let filename;\n    let stack;\n    const reason = e.reason;\n    if (typeof reason === \"string\") {\n      message = reason;\n    } else if (typeof reason === \"object\") {\n      message = reason.message;\n      // \"TypeError: Cannot set properties of undefined (setting 'a')\\n    at http://localhost:9000/:18:34\\n    at new Promise (<anonymous>)\\n    at showError (http://localhost:9000/:17:18)\\n    at HTMLButtonElement.onclick (http://localhost:9000/:10:44)\"\n      if (reason.stack) {\n        const matchResult= reason.stack.match(/at\\s+(.+):(\\d+):(\\d+)/);\n        filename = matchResult[1];\n        lineno = matchResult[2];\n        colno = matchResult[3];\n        stack = formatStack(reason.stack);\n      }\n    }\n    const log={\n      kind: \"stability\", // 监控指标大类\n      type: \"error\", // 监控指标小类\n      errorType: \"promiseError\", // 错误类型-全局未捕获的错误\n      message, // 报错信息\n      filename, // 错误文件\n      position: `${lineno}:${colno}`, // 错误行列\n      // \"TypeError: Cannot set properties of undefined (setting 'a')\\n    at showError (http://localhost:9000/:15:30)\\n    at HTMLButtonElement.onclick (http://localhost:9000/:9:39)\"\n      stack, // 错误堆栈\n      selector: lastEvent ? getSelector(lastEvent) : \"\", //  最后一个交互事件对应的元素\n    }\n    tracker.send(log)\n  });\n```\n- 只要加catch就不会触发unhandledrejection\n- reject最好传字符串, 传其他e.meesage是undefined\n\n## XHR请求\n\n### 实现\n```js\nexport function injectXhr() {\n  let XMLHttpRequest = window.XMLHttpRequest;\n  let oldOpen = XMLHttpRequest.prototype.open;\n  XMLHttpRequest.prototype.open = function (method, url, async) {\n    // 过滤掉上报日志的接口, 要不就死循环了\n    if (!url.match(/dig.gif/)) {\n      this.logData = {\n        method,\n        url,\n        async,\n      };\n    }\n    return oldOpen.apply(this, arguments);\n  };\n  let oldSend = XMLHttpRequest.prototype.send;\n  XMLHttpRequest.prototype.send = function (body) {\n    if (this.logData) {\n      let startTime = Date.now(); // 开始请求时间\n      const handler = (type) => {\n        return (event) => {\n          let duration = Date.now() - startTime; // 请求耗时\n          let status = this.status; // 状态码 如 200 404 500\n          let statusText = this.statusText; // 状态码对应的文本 如 \"OK\" \"Not Found\" \"Internal Server Error\"\n          const log = {\n            kind: \"stability\", // 监控指标大类\n            type: \"xhr\", // 小类\n            xhrType: type, // 请求类型 如 load error abort\n            apiUrl: this.logData.url, // 请求路径\n            status: status + \"-\" + statusText, // 状态码 - 状态码文本\n            duration, // 请求耗时\n            reqData: body || \"\", // 请求参数\n            resData: this.response ? JSON.stringify(this.response) : \"\", // 响应数据\n          };\n          tracker.send(log);\n        };\n      };\n      this.addEventListener(\"load\", handler(\"load\"), false); // 监听请求完成(包含成功、失败),比如失败500\n      this.addEventListener(\"error\", handler(\"error\"), false); // 监听请求失败\n      this.addEventListener(\"abort\", handler(\"abort\"), false); // 监听请求中断\n    }\n    return oldSend.apply(this, arguments);\n  };\n}\n```\n- 重写xhr的open、send方法, 复制旧的, XMLHttpRequest.prototype.open=自己的, 里面加逻辑后,调用旧的执行,通过apply传入所有参数\n- 监听load、error、abort事件计算请求耗时\n- 请求耗时计算: 在send中记录开始时间, 在请求结束(上面3个事件)用当时时间-开始时间即可.\n\n**fetch拦截类似,也是重写fetch方法**\n## 白屏\n所谓白屏,就是页面啥都没有,相当于只有body(注意:骨架屏不算白屏, 算有内容)\n\n### 实现\n\n```js\n// https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint\nexport function blankScreen() {\n  const wrapperElArr = [\"html\", \"body\", \"#app\"]; // 容器元素\n  let emptyPoint = 0; // 空白点个数\n  function getSelector(el) {\n    let selector = \"\";\n    if (el.id) {\n      selector = `#${el.id}`;\n    } else if (el.className) {\n      selector = el.className\n        .split(\" \")\n        .map((c) => `.${c}`)\n        .join(\"\");\n    } else {\n      selector = el.nodeName.toLowerCase();\n    }\n    return selector;\n  }\n  function isWrapper(el) {\n    let selecter = getSelector(el);\n    if (wrapperElArr.indexOf(selecter) > -1) {\n      emptyPoint++;\n    }\n  }\n  // 执行blankScreen问题, 因为js放到head执行,dom肯定没有,所以需要onload执行\n  onload(() => {\n    for (let i = 1; i < total; i++) {\n      const total=20 // 每条轴采样点个数\n      const xElements = document.elementsFromPoint(\n        (window.innerWidth / total) * i,\n        window.innerHeight / 2\n      );\n      const yElements = document.elementsFromPoint(\n        window.innerWidth / 2,\n        (window.innerHeight / total) * i\n      );\n      //   左45度 (因为只有x、y)有时候不是白屏,仍会当成白屏. 比如就屏幕前1/3高度有元素, x检测不到, y轴的9个点都刚好在行内元素行上,就当成body了\n      const xElements45 = document.elementsFromPoint(\n        (window.innerWidth / total) * i,\n        (window.innerHeight / total) * i\n      );\n      isWrapper(xElements[0]);\n      isWrapper(yElements[0]);\n      isWrapper(xElements45[0]);\n    }\n   if (emptyPoint >= (total-1)*3) { // 所以上面3条轴,采样点总共57个点\n      let centerEl = document.elementsFromPoint(\n        window.innerWidth / 2,\n        window.innerHeight / 2\n      );\n      tracker.send({\n        kind: \"stability\", // 监控指标大类\n        type: \"blank\", // 小类\n        emptyPoint, // 空白点个数\n        screen: window.screen.width + \"*\" + window.screen.height,\n        viewpoint: window.innerWidth + \"*\" + window.innerHeight,\n        selector: getSelector(centerEl[0]), // 中心点\n      });\n    }\n  });\n}\nexport default function onload(callback) {\n  if (document.readyState === \"complete\") {\n    callback();\n  } else {\n    window.addEventListener(\"load\", function () {\n      callback();\n    });\n  }\n}\n```\n- `document.elementsFromPoint(x,y)`用来获取执行位置的元素\n- 我们通过取样屏幕中心x、y轴,各取9个点,判断这18个点,如果是容器元素,说明是白屏.\n- 因为js放到head执行,获取dom采样点肯定没有,所以需要onload执行\n- 上面采样用的横竖2条中心轴,但是存在(比如就屏幕前1/3高度有元素是行内元素, x检测不到, y轴检测不到,就当成body了),所以上面加了个左45度\n-  白屏的指标也统计了屏幕分辨率`window.screen.width + \"*\" + window.screen.height`\n-  白屏的指标也统计了文档即视口分辨率 `window.innerWidth + \"*\" + window.innerHeight`\n\n我们把html的dom注释掉看看效果\n<img src=\"images/5.jpg\" width=\"100%\"/>\n\n# 监控性能指标(耗时)\n做性能分析，不管是在本地，还是通过工具，最重要的是要有数据支撑。目前，w3c 对性能相关数据,已经有了详尽的分类标准. 下图就来自于 [w3c](https://www.w3.org/TR/navigation-timing/)\n<img src=\"images/performance-0.png\" width=\"100%\"/>\n这个加载过程模型，是[web 性能工作组](https://www.w3.org/webperf/) 早在 2012 年就针对页面加载过程制定的，定义了从上一个页面结束，到下一个页面从开始加载到完成加载的整个过程。基于这个模型，我们可以获取到页面加载过程中各个阶段的耗时情况，然后分析出页面加载性能。\n\n## 加载阶段描述\n\n### 初始化阶段\n  \n事件 | 描述\n---|---\nnavigationStart | 用户完成卸载前一个文档的时间点。\nredirectStart | 重定向开始时间。如果页面没有重定向，该值为0。\nredirectEnd | 重定向结束时间(表示**最后一次**重定向)。如果页面没有重定向，该值为0。\n\n### 请求阶段\n  \n事件 | 描述\n---|---\nfetchStart | 浏览器开始请求页面的时刻。\ndomainLookupStart | 查询DNS的开始时刻。如果请求没有发起DNS请求，如keep-alive、缓存等，则返回fetchStart的时间点。\ndomainLookupEnd | 查询DNS的结束时刻。如果没有发起DNS请求，如keep-alive、缓存等，则返回fetchStart的时间点。\nconnectStart | 当浏览器开始与服务器连接时的时刻。如果没有建立连接，如请求是keep-alive、缓存等，那么它的值等同于domainLookupEnd。\nsecureConnectionStart | 如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0。\nconnectEnd | 当浏览器端完成与服务器端建立连接的时刻。如果没有建立连接，如请求是keep-alive、缓存等，那么它的值等同于domainLookupEnd。\nrequestStart | 浏览器开始向服务器发送 HTTP 请求数据包时刻。\nresponseStart | 指浏览器收到从服务器（或缓存、本地资源）响应回的第一个字节的数据的时刻。\nresponseEnd | 指浏览器收到从服务器端（或缓存、本地资源）响应回的最后一个字节的数据的时刻。\n\n### 解析渲染阶段\n  \n事件 | 描述\n---|---\ndomLoading | 浏览器即将开始解析第一批收到的 HTML 文档字节(即 Document.readyState 属性变为 loading，相应的 readystatechange 事件触发时)。\ndomInteractive | 浏览器完成DOM解析的时间点,准备开始加载内嵌资源(比如外链css、js等)的时间点。(即 Document.readyState 的属性为 interactive，相应的 readystatechange 事件触发时.时间上和 DOMContentLoaded 同时发生，不过顺序在它之前.)\ndomContentLoaded | 在 html 文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都执行完毕后触发，也就是jQuery中的 $(document).ready事件. 但图片、video、audio、flash、iframe资源尚未加载\ndomComplete | 所有处理完成，并且网页上的所有资源（图像等）都已下载完毕，也就是说，加载转环已停止旋转, 表示网页及其所有子资源都准备就绪的时间点。即 Document.readyState 变为 complete 且相应的 readystatechange 事件被触发时\nloadEventStart | 作为每个网页加载的最后一步，浏览器会触发 onload 事件，以便触发额外的应用逻辑。\nloadEventEnd | onload 事件 执行完成。 许多 JavaScript 框架都会等待onload事件发生后，才开始执行它们自己的逻辑。因此，浏览器会捕获 loadEventStart 和 loadEventEnd 时间戳来追踪执行所花费的时间。\n\n#### document.readyState\n该属性描述了文档的加载状态，发生变化时，会在 document 对象上触发 readystatechange 事件。有3种状态：\n\n- loading 正在加载\n- interactive 文档已被解析，loading 状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载，会在 document 和 window 对象上触发 DOMContentLoaded 事件。\n- complete 所有资源完成加载，会在 window 对象上触发 load 事件。\n#### 浏览器页面渲染过程\n1. 浏览器与服务器建立 TCP 连接发送 HTTP 请求，获取 HTML 文档并开始从上到下解析，构建 DOM。\n2. 在构建 DOM 过程中：\n- 如果遇到外联的 css 文件，下载文件并执行构建 CSSOM，此过程不影响 DOM 构建，但在完成之前会阻止页面渲染。\n- 如果遇到外联的 js 文件，则暂停构建 DOM，\n\n- 若在这之前的 css 文件已加载完毕且 CSSOM 构建完成，则合并已经构建好的 DOM 与 CSSOM 并渲染到页面上\n- 之后等 js 文件下载并执行后，然后继续构建后边的 DOM。\n3. 完成文档解析后，将 DOM 和 CSSOM 进行关联和映射，生成 Render Tree 渲染页面。\n4. 当所有同步的 js 代码执行完毕后，会在 document 和 window 对象上触发 DOMContentLoaded 事件，此时对应 document.readyState === 'interactive'。\n5. 当所有资源完成加载后，会在 window 对象上触发 load 事件，此时对应 document.readyState === 'complete'。\n\n## 各阶段计算公式\n<img src=\"images/performance-1.png\" width=\"100%\"/>\n\n经过上面各个字段的说明，可以清晰得出以下公式。\n\n事件 | 计算公式 | 描述\n---|--- | ---\nRedirect | redirectEnd - redirectStart | 重定向耗时\nAppCache | domainLookupStart - fetchStart | 浏览器缓存耗时(比如静态资源缓存)\nDNS | domainLookupEnd - domainLookupStart | DNS解析耗时\nTCP | connectEnd - connectStart | TCP连接耗时\nSSL | connectEnd - secureConnectionStart | SSL耗时 (TCP包含SSL)\n**TTFB** | responseStart - navigationStart | 首字节到达时间(time to first byte,浏览器从服务器接收到第一个字节的时间,起点选择navigationStart 是为了和web-vitals规范保持一致,也可以用fetchStart)\nResponse | responseEnd - responseStart | 响应完成耗时\nDomParse | domInteractive - domLoading | Dom解析完成耗时(即 DOM 树构建完成的时长)\nDomReady | domContentLoaded - domLoading | Dom挂载完成总耗时,即domContentLoaded\nresourceLoad | loadEventStart - domContentLoaded | 资源加载耗时,**可观察资源流是否过大**\nDomProcessing | domComplete - domLoading | 整个dom进程的总耗时\nonLoad | loadEventEnd - loadEventStart | onload 事件执行耗时\nLoad  | loadEventEnd - navigationStart | 页面完全加载总时间\n\n<img src=\"images/performance-2.png\" width=\"80%\"/>\n通过下面代码可以计算上面指标\n```js\n const timing =\n      (performance.getEntriesByType &&\n        performance.getEntriesByType(\"navigation\")[0]) ||\n      performance.timing; // 官方显示performance.timing属性已经弃用，但是实测最新浏览器仍支持\n```\n\n## 用户体验指标(耗时)\n### 页面何时开始渲染(FP)\n- FP, first paint, 表示页面第一个像素点绘制时刻,一般认为该指标是白屏时间. 比如body背景色. FCP是有第一个dom渲染.\n```js\n    performance.getEntries().filter(item => item.name === 'first-paint')[0];  // 获取 FP 时间\n    // 也可以通过 performanceObserver 的方式获取\n    var observer = new PerformanceObserver(function(list, obj) {\n        var entries = list.getEntries();\n        entries.forEach(item => {\n            if (item.name === 'first-paint') {\n                ...\n            }\n            if (item.name === 'first-contentful-paint') {\n                ...\n            }\n        })\n    });\n    observer.observe({type: 'paint'});\n```\n### 页面何时渲染内容(FCP、LCP、FMP、SI)\n- FCP, first contentful paint, 首次内容绘制时间，表示第一个dom渲染到浏览器的时间,比如文本、图片、视频等。\n```js\n    performance.getEntries().filter(item => item.name === 'first-contentful-paint')[0];  // 获取 FCP 时间\n```\n- LCP, largest contentful paint, 最大内容绘制时间，表示浏览器将最大的内容渲染到屏幕的时间，和 FMP 类似，但只聚焦页面首次加载时最大元素的绘制时间点\n```js\nnew PerformanceObserver((entryList) => {\n    for (const entry of entryList.getEntries()) {\n        console.log('LCP candidate:', entry.startTime, entry);\n    }\n}).observe({type: 'largest-contentful-paint', buffered: true});\n```\n- FMP, first meaningful paint, 首次有意义内容绘制时间. (已经**废弃**的性能指标,因为该指标的定义依赖于特定于浏览器的实现细节，这意味着它不能标准化,所以官方并没有提供有效的获取 FMP 的接口,无法计算)\n- SI, speed index, 速度指标, lighthouse 面板中的六大指标之一，用于衡量页面加载期间内容的绘制速度，值越小约好.SI 和 FMP 一样，官方也没有提供有效的获取接口，只能通过 lighthouse 面板来查看，不作为 Sentry 等工具做性能分析的指标。\n### 页面何时可以交互(TTI、TBT)\n- TTI, time to ineractive, 可交互时间， lighthouse 面板中的六大指标之一, 用于测量页面从开始加载到主要资源完成渲染，并能够快速、可靠地响应用户输入所需的时间, 值越小约好.\n和 FMP、SI 一样，官方并没有提供获取 TTI 的有效接口，只能通过 lighthouse 面板来查看，不会作为日志平台来进行性能分析的指标。\n- TBT, total blocking time，总的阻塞时间， lighthouse 面板中的六大指标之一，用于测量 FCP 到 TTI 之间的总的阻塞时间，值越小约好。官方资料: [TBT](https://web.dev/lighthouse-total-blocking-time/)。\n和 TTI 一样，官方也没有提供获取 TBT 的有效接口，只能通过 lighthouse 面板来查看，不会作为 Sentry 做性能分析的指标。\n### 交互是否有延迟(FID)\n- FID，first input delay, 首次输入延迟，测量从用户第一次与页面交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对交互作出响应所经过的时间.\n```js\nnew PerformanceObserver((entryList) => {\n  for (const entry of entryList.getEntries()) {\n    const delay = entry.processingStart - entry.startTime;\n    console.log('FID candidate:', delay, entry);\n  }\n}).observe({type: 'first-input', buffered: true});\n```\n### 页面视觉是否流畅(CLS)\n- CLS, cumulative layout shift, 累计布局偏移(视觉不稳定/流畅性)，测量页面在加载过程中，元素位置在屏幕上的移动程度，值越大，页面视觉不流畅。\n解释下:我们在浏览网页时可能会遇到这样的情况：当我们正聚精会神地阅读网页内容时，突然发现内容在没有任何预警的情况下被挤到了另一个位置。更糟糕的是，当您准备点击一个链接或按钮时，正巧在手指按下的瞬间，链接突然移位，导致您误点到其他内容。通常情况下，这样的网站会给用户带来极差的体验，甚至瞬间的位移错误交互可能造成一定程度的破坏。\n通常，页面元素发生意外偏移的原因包括异步资源加载以及在 DOM 元素上方动态插入新的元素等。具体而言，这些偏移可能源于图片或视频元素尺寸未设置、不受控的第三方广告引入或者小组件自身大小的动态调整。\n因此，我们需要一个指标来度量意外偏移对用户“视觉稳定性”产生的影响。\n```js\nnew PerformanceObserver(function(list) {\n    var perfEntries = list.getEntries();\n    for (var i = 0; i < perfEntries.length; i++) {\n        ...\n    }\n})observe({type: 'layout-shift', buffered: true});\n```\n所以:\n- 不要在现有内容之上插入内容，除非是为了响应用户交互。\n- 多用 transform animations，而不是触发布局变化的animations properties。\n- 在图片和视频元素中包含大小属性，或者用 CSS 长宽比框之类的东西保留所需的空间。\n具体实现可以参考 https://wukongdoc.tingyun.com/browser/metric/CLS.html\n### 总结\n- 如果是本地通过 lighthouse 进行性能分析，会使用 6 大指标: FCP、LCP、SI、TTI、TBT、CLS。这些指标涵盖了页面渲染、交互和视觉稳定性情况。\n- 如果是通过 Sentry 等工具进行性能分析，会使用 4 大指标: FCP、LCP、FID、CLS。这些指标也涵盖了页面渲染、交互、视觉稳定性情况。之所以选这四个指标，原因想必大家也知道，就是这四个指标的数据可以通过 performanceObserver 获取。\n\n# 监控业务business\n\n## pv、uv\n- pv: 展示统计周期内页面访问量，即用户访问页面的总次数。\n```js\nexport function pv() {\n  var connection = navigator.connection;\n  tracker.send({\n    kind: \"business\",\n    type: \"pv\",\n    effectiveType: connection.effectiveType, //网络环境\n    rtt: connection.rtt, //往返时间\n    screen: `${window.screen.width}x${window.screen.height}`, //设备分辨率\n  });\n}\n```\n**注意,如果是vue的hash变化,需要监听`window.addeventlistener(“hashchange”,()=>()`事件,再次调用pv统计**\nuv: 展示统计周期内指定页面用户访问次数。\n一般通过服务器端来统计.如某一天,某个页面用户访问量(一般根据token来判断)\n\n\n## 页面停留时间\n- 页面停留时间，即用户在页面停留的时间。\n```js\nexport function stay() {\n  let startTime = Date.now();\n  // 在页面卸载时发送页面停留事件\n  window.addEventListener(\n    \"beforeunload\",\n    (event) => {\n    // event.returnValue = '你确定要离开这个页面吗？'; // 设置returnValue属性以显示提示信息\n      let stayTime = Date.now() - startTime;\n      tracker.send({\n        kind: \"business\",\n        type: \"stayTime\",\n        stayTime,\n      });\n    },\n    false\n  );\n}\n```\n## 长任务(页面卡顿)\n如果一个任务在主线程上运行超过 50 毫秒，那么它就是 Long task。我们根据该指标可以观测某段js运行的时间\n```js\n/**\n * 可以理解为异步执行\n * requestIdleCallback 是浏览器空闲时会自动执行内部函数\n * requestAnimationFrame 是浏览器必须执行的\n * 关于 requestIdleCallback 和  requestAnimationFrame 可以参考 https://www.cnblogs.com/cangqinglang/p/13877078.html\n */\nexport default function longTask() {\n  new PerformanceObserver((list) => {\n    list.getEntries().forEach((entry) => {\n      if (entry.duration > 100) {\n        let lastEvent = getLastEvent();\n        requestIdleCallback(() => {\n          tracker.send({\n            kind: \"experience\",\n            type: \"longTask\",\n            eventType: lastEvent.type,\n            startTime: formatTime(entry.startTime), // 开始时间\n            duration: formatTime(entry.duration), // 持续时间\n            selector: lastEvent\n              ? getSelector(lastEvent)\n              : \"\",\n          });\n        });\n      }\n    });\n  }).observe({ entryTypes: [\"longtask\"] });\n```\n# sourceMap\n由于报错是**压缩代码的行列**,所以我们需要映射文件解析源代码.\n一般来讲，线上产物中会把 SourceMap 去除，除了为了加速构建过程，更重要的是避免有开发经验的人直接在浏览器中「阅读源码」。现在需要sourceMap来定位到源代码:\n- webpack配置`source-map`, 打包后将sourceMap传到某个私有的地址（如 CDN 或 OSS）,此时日志平台可以获取私有地址上传的sourceMap做映射.但是谷歌控制台能否看到源码错误,有以下几种方案:\n  - 不删除map文件, 不安全,谷歌控制台直接可以看到源码.\n  - 打包完使用`rimraf包`删除掉map文件.谷歌控制台不可以看到源码.因为sourceMappingURL指向的是和js同级路径,找不到了. 此时可以使用charles转发sourceMappingURL到私有云即可.\n  - 不删除map文件, 但打包的时候将`sourceMappingURL`改为上传的地址.服务端控制外部不能访问到sourcemap,内部才能访问. 这样连接内网,谷歌控制台才可以直接看到源代码,外网不可见.\n<img src=\"images/6.png\" width=\"50%\"/>\n  - 不删除map文件,也不修改`sourceMappingURL`,服务端控制外部不能访问到map后缀文件,内部才能访问. 这样连接内网,谷歌控制台才可以直接看到源代码,外网不可见.\n\n- webpack配置`hidden-source-map`, 因为没有`sourceMappingURL`，所以不用删除.谷歌控制台不可以看到源码.\n   - 我们可以通过时间谷歌插件添加`Http Header：sourcemap`来实现. [如何在线上使用 SourceMap](https://zhuanlan.zhihu.com/p/674981525)\n   - 也可以在控制台一个一个添加sourcemap来看源代码, 但是不推荐, 因为每次都得手动添加.并且刷新一下就得重新添加.\n\n## 实现sourceMap转换源代码\n原理: 调用`source-map包`通过 map文件代码+压缩文件代码的报错`行、列转化为`源代码\n```js\nvar sourceMap = require(\"source-map\");\nlet fs = require(\"fs\");\nconst getSource = async (sourcemap, line, column) => {\n  try {\n    const consumer = await new sourceMap.SourceMapConsumer(\n      JSON.parse(sourcemap)\n    );\n    const originalInfo = consumer.originalPositionFor({ line, column }); // 获取源代码信息(注意行列需要为number类型, 字符串类型会报错)\n    console.log(originalInfo);\n    const originFileContent = consumer.sourceContentFor(originalInfo.source); // 获取源代码整个文件内容\n    return {\n      originFileContent,\n      line: originalInfo.line,\n      column: originalInfo.column,\n      originFileName: originalInfo.source,\n    };\n  } catch (e) {\n    console.log(e);\n    // ElMessage.error(\"sourcemap解析失败\");\n  }\n};\nconst sourceFileUrl = \"../dist/js/app.72b4fccd.js.map\";\nconst sourceFileContentStr = fs.readFileSync(sourceFileUrl, \"utf-8\");\ngetSource(sourceFileContentStr, 1, 6040).then(origin=>{\n    console.log(origin) // 源代码,这里包含整个报错文件的源代码\n})\n```\n## 只展示6行报错\n一般我们展示, 只展示6行报错(前2行、报错行高亮、后2行),所以我们对上面的代码进行格式化\n```html\n  <div v-html=\"preLine(origin)\"></div>\n```\n```js\nfunction preLine(origin) {\n  const line = origin.line;  // 错误的行号\n  // 先获取源码有多少行\n  const originCodeLine = origin?.originFileContent?.split(\"\\n\");\n  const len = originCodeLine.length - 1;\n  const start = line - 3 >= 0 ? line - 3 : 0; \n  const end = start + 5 >= len ? len : start + 5; // 最多展示6行\n  let newLines = [];\n  for (var i = start; i <= end; i++) {\n    const content = i + 1 + \".    \" + encodeHTML(originCodeLine[i]);\n    newLines.push(\n      `<div class='code-line ${\n        i + 1 == line ? \"hightlight\" : \"\" // 高亮错误行\n      }'>${content}</div>`\n    );\n  }\n  return newLines.join(\"\");\n}\nfunction encodeHTML(str) {\n  if (!str || str.length == 0) return \"\";\n  return str\n    .replace(/&/g, \"&#38;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/'/g, \"&#39;\");\n}\n```\n# 接入方式\n\n1. JavaScript方式: 我们可以打包成一个js文件,放到html最上面(必须置于其它脚本之前),否则嵌码JS前面的数据获取不到。\n2. npm方式: 因为是在main.js引入, 所以有些资源加载错误无法捕获到.\n   \n\n# 上报方式\n## sendBeacon\nNavigator.sendBeacon 是一个用于发送少量数据到服务器的 API.\n```js\nconst res=navigator.sendBeacon(url, data); // data可以是 `ArrayBufferView` 或`Blob`, `DOMString即String` 或者`FormData`类型的数据。\n// res 返回一个 Boolean值，如果返回 true，则表示数据已经放入队列并且在将来某个时间点会进行传输。\n// 如果返回 false，则表示数据无法放入队列，可能因为队列已满或者网络问题。\n```\n- sendBeacon 方法的设计目标是确保数据在页面卸载时能够可靠地发送。浏览器会在后台继续尝试发送数据，即使页面已经关闭或正在导航到新页面\n- 发送是post请求, 是异步的，但不返回任何信息给调用者，无法处理服务器的响应。只能判断出是否放入浏览器任务队列，不能判断是否发送成功。\n- 非阻塞的，不会阻碍页面的卸载过程\n- 也会有跨域问题,除非服务器设置了适当的 CORS 头。\n- 一般上报不超过64k\n- 一般浏览器都支持, ie不支持,谷歌版本>=39\n  \n我们测试`navigator.sendBeacon('http://localhost:3000/log', 'test')`, 在控制台可以看到`ResourceType为ping`,但是看到请求头和正常post接口没任何区别,仍是post请求。\n<img src=\"images/7.jpg\" width=\"100%\"/>\n\n## xhr上报\n- 这种方法有一个问题，就是在页面卸载或刷新时进行上报的话，请求可能会在浏览器关闭或重新加载前还未发送至服务端就被浏览器 cancel 掉，导致数据上报失败。\n- 可以将 ajax 请求改为同步方法，这样就能保证请求一定能发送到服务端. 但是同步就会阻塞页面关闭或重新加载的过程，这样就会影响用户体验。\n```js\nconst syncReport = (url, { data = {}, headers = {} } = {}) => {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', url, false); // false表示同步请求(不异步)\n  xhr.withCredentials = true;\n  Object.keys(headers).forEach((key) => {\n    xhr.setRequestHeader(key, headers[key]);\n  });\n  xhr.send(JSON.stringify(data));\n};\n```\n\n## img上报\n- 我们可以通过在 beforeunload 事件处理器中创建一个图片元素并设置它的 src 属性的方法来延迟卸载以保证数据的发送，因为绝大多数浏览器会延迟卸载以保证图片的载入(load事件)，所以数据可以在卸载事件中发送。不过beforeunload在移动端貌似不兼容,不会触发.\n- 日志接口域名最好和当前页面域名不一致,因为浏览器对同一个域名的最大并发连接数为6个，如果日志同时上报了6次以上，就会对同域名的业务造成影响；更坏的情况如页面有一些错误、网络连接质量质量不高会让日志上报阻碍页面渲染.所以日志上报可以像使用CDN服务一样，使用单独域名和日志处理服务.(不同域名,最好在head头增加dns-prefetch预解析)\n- 因为使用img,所以支持跨域,不过是get方法, 最长字符一般是2000个字符,一个英文字符占一个字节Byte,汉字占2字节. 1kb=1024字节Byte,所以一般不建议超过2kb\n- 使用图片,就是浏览器禁止script,也不影响请求\n\n## gif图片上报\n- gif图片部署在nginx上,就能记录到请求的信息. 然后定时任务去读取nginx日志(比如**每分钟拉一次**),存入数据库.可以对数据进行清洗(格式化)\n- nginx的图片采用1X1的透明图,相比较于jpg，gif图更小，合法的 GIF 只需要 43 个字节.\n- 和上面image不同的是,这个是通过nginx的日志来处理.(官方测试Nginx能够支持5万并发链接,实际生产环境中可以支撑2-4万并发连接数).而上面的是通过image的get请求发接口而已.\n\n  \n# 总结\n## 上报方式\n优雅降级\nsendBeacon > image > xhr\n判断如果浏览器支持sendBeacon,且上报数据小于64k(sendBeacon最大支持64k),使用sendBeacon上报(但是只能post接口). 注意还需要根据res判断是否加入队列成功.\n否则判断上报数据 < 2k, 使用image上报(get请求最多2000字符). \n否则使用xhr上报.\n```js\n/**\n * 判断对象是否超过指定kb大小\n * @param object 源对象\n * @param limitInKB 最大kb\n */\nexport function isObjectOverSizeLimit(\n  object: object,\n  limitInKB: number\n): boolean {\n  const serializedObject = JSON.stringify(object)\n  const sizeInBytes = new TextEncoder().encode(serializedObject).length\n  const sizeInKB = sizeInBytes / 1024\n  return sizeInKB > limitInKB\n}\n```\n## 上报频率\n- pv: 就是上报一次, 所以我们不需要上报频率.\n- 性能监控:onload完, 上报一次, 所以我们不需要上报频率.(最好onload完加个1s的延时,因为onload完不加延时,有时performance获取的fp、fcp都可能获取不到)\n- 错误监控: 每次调用上报方法的时候,先塞入数组中,去重,然后setTimeout(比如3s)上报.这相当于把多次合并为一次上报，以降低对服务器的压力。\n   如何对同一个错误去重? 我们可以根据错误信息、错误文件、行、列、页面url组合一起做为唯一标识进行去重.\n- 接口错误: 不去重.\n- 静态资源监控: 上报一次, 所以我们不需要上报频率.\n\n## sourceMap\n- 项目打包的时候同时将sourcemap打包到上传服务器, 做一个监控页面, 通过接口获取报错行列、报错文件.map,然后渲染源代码.\n- 不做多版本sourcemap,因为sourcemap每次打包都是新的, 老的报错如果渲染过源代码就存下来.\n\n# vue错误上报\n`window.addEventListener(\"error\",()=>{})`只能监听js的错误, vue的错误是组件的错误, 监听不到, 需要vue提供的方法处理.\n测试了下:\n- vue普通代码报错(template和jsx):  addEventListener监听不到, vue的errorHandler可以监听到\n- vue Promise代码报错(template和jsx):  unhandledrejection可以监听到, vue的errorHandler不能监听到\n- main.js代码报错(普通和promise), addEventListener和unhandledrejection可以监听到, vue的errorHandler不能监听到\n**所以使用vue的errorHandler**\n- 可以捕获error捕获不到的vue错误,其他错误原生js可以正常捕获.\n- vue的errorHandler方法,返回的error对象, 信息只有message、stack.但第三个参数可以知道是钩子的名称, 比如created,mounted等.如下图\n<img src=\"images/8.jpg\" width=\"100%\"/>\n\n\n## Vue2\n```js\nVue.config.errorHandler = function (err, vm, info) {\n  send(err) // 上报错误信息\n}\n```\n## Vue3\n```js\nconst app = createApp(App);\napp.config.errorHandler = function (err, vm, info) {\n   send(err) // 上报错误信息\n};\napp.mount('#app');\n```\n> [web-tracing](https://m-cheng-web.github.io/web-tracing/guide/spotlight)\n> [腾讯三面：说说前端监控平台/监控SDK的架构设计和难点亮点](https://juejin.cn/post/7108660942686126093?searchId=202411211542117B97BF46B14987073FA1)\n> [DOM 和 CSSOM](https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/)\n> [浅谈浏览器页面渲染过程 load 与 DOMContentLoaded 事件](https://segmentfault.com/a/1190000021713604)\n> [听云](https://wukongdoc.tingyun.com/browser/metric/timing.html?q=)\n> [听云](https://wukongdoc.tingyun.com/browser/introduce/principle.html?h=navigation)\n> [使用 Performance API 获取页面性能](https://juejin.cn/post/6973567030528065573)\n> [页面CLS 优化实践](https://blog.itpub.net/70024924/viewspace-2992688/)\n> [使用 Sentry 做性能监控 - 原理篇](https://juejin.cn/post/7148364027817623589#heading-7)\n> [前端异常上报](https://juejin.cn/post/6908506976674807815#heading-5)\n> [使用sendBeacon进行前端数据上报](https://blog.csdn.net/qq_63358859/article/details/139849910)","categories":["monitor"]},{"title":"git rebase变基","url":"/ypf-blog/2024/10/09/git/git rebase变基/","content":"## 语法\n\n```bash\ngit rebase -i [startHash] [endHash]  # 左开右闭,所以不包含第一次, endHash可以省略\ngit rebase -i --root  # 从第一次开始\ngit rebase -i HEAD~2 # 最近2个commit\n```\n执行完上面命令,会出现 startHash+1 - endHash之间的commit, 默认是pick, 可以修改执行不同的操作, 执行完后, 被操作的某个git记录,会变更为最新的日期\n<img src=\"images/2.jpg\" width=\"50%\" height=\"50%\" />\n\n命令 | 缩写 | 含义\n-|-|- \npick \t| p\t| 保留该 commit不变\nreword\t| r\t| 保留该 commit，但需要修改该 commit 的注释\nedit\t| e\t| 保留该 commit, 但我要停下来修改(不仅仅修改注释)\nsquash\t| s\t| 将该 commit合并到前一个 commit\nfixup\t| f\t| 将该 commit合并到前一个 commit，但不要保留该提交的注释信息\nexec\t| x\t| 执行 Shell 命令\ndrop\t| d\t| 丢弃该 commit\n\n所以我们需要通过`git log` 查看hash值, 常用的命令有:\n```bash\ngit log --pretty=format:'%h: %s' # 只显示短hash和commit信息\ngit log --oneline  # 只显示短hash和commit信息, 和上面区别是: 如果有其他分支合并过来的commit会在hash后显示分支\n```\n**注意: git rebase 执行完的git记录比较特殊,是正序的, 和git log的显示顺序是相反的**\n## 合并连续commit(squash)\n假设我们有4次提交记录, 想要将最后3次合并到第一次.\n<img src=\"images/1.jpg\" width=\"50%\" height=\"50%\" />\n1. 执行`git rebase -i --root`\n   \n因为是左开区间, 所以我们需要找到 **目标commit的上一个**,所以这里要找到第一次的上一次, 但是已经到头了,所以需要找到根节点.\n<img src=\"images/2.jpg\" width=\"50%\" height=\"50%\" />\n2. 将234行的`pick`改为`s`或者 `squash`, 保存退出.就会将234合并到1.\n   \n## 合并不连续commit(squash)\n上面我们是合并连续的commit, 现在假设我们要将3合并至1. \n1. 执行`git rebase -i --root`\n2. 要先进行`排序`,将3排到1后面. (vim中剪切排序是 `dd-剪切 p-粘贴`到某一行后面),所以我们是在3执行dd,然后定义到1,执行p.\n3. 再将3改为S保存退出. (因为s命令是合并到前一次的, 所以我们要移动到一起才行)\n\n**注意:**\n无论连续不连续合并, 如果上面执行S保存退出后,如果存在冲突时需要\n1. 先解决冲突\n2. 执行`git add .`\n3. `git rebase --continue`\n   \n## 修改某次commit(edit)\n假设我们有4次提交记录,想直接在第一次记录上修改.\n<img src=\"images/3.jpg\" width=\"50%\" height=\"50%\" />\n1. 我们把第一行修改为` e `保存退出,此时代码会还原到第一次提交记录. 可以看下图commitid也是第一次, 命令行显示的是commitid也不是分支了.\n<img src=\"images/4.jpg\" width=\"50%\" height=\"50%\" />\n2. 修改完后, 执行`git add .`, 然后执行`git rebase --continue`, 会弹出窗口,此时还可以在窗口中修改commit信息. 保存退出即可, 同样有冲突解决冲突重新add, continue即可\n\n\n","categories":["git"]},{"title":"1.eslint配置、插件","url":"/ypf-blog/2024/09/11/eslint/1.eslint配置、插件/","content":"[eslint官网](https://eslint.nodejs.cn/docs/latest/use/getting-started)\n## 安装\n1. 新建eslint文件夹\n```js\neslint\n  - packages\n  pnpm-lock.yaml\n```\n其中`pnpm-lock.yaml`内容如下\n```js\npackages:\n  - \"packages/*\"\n```\n2. 初始化项目\n```js\npnpm init   // 1.初始化package.json\npnpm create @eslint/config@latest // 2.初始化eslint配置以及node_modules依赖\n```\n执行`pnpm create @eslint/config@latest`命令会弹窗一系列交互选择,\n最后生成eslint的配置文件,以及package.json安装了`eslint、@eslint/js、globals`三个包\n<img src=\"images/1.jpg\" width=\"80%\" height=\"80%\" />\n\n因为现在官方于2024.02.24发布了9.x版本,但是实际项目很多用的都是8.x版本, 两个版本配置文件变化较大,所以使用8.x版本最后一个版本8.57.0来讲解.\n\n**因为上面命令创建的是新版本,所以就不能使用上面的命令创建配置文件以及依赖了**\n\n## 手动配置旧版本\n3. 手动创建配置文件`.eslintrc.js`\n```js\nmodule.exports = {\n  root: true, // 多个配置文件,默认eslint会一直找父级目录的配置文件,都会生效, 所以如果我们只想让当前配置文件生效,其他配置文件不生效,所以这里设置为true,就不会往上找了\n  // 当前可以使用哪个环境的全局变量,不配置会检测标红\n  env: {\n    browser: true, // 表示可以使用 window/document等浏览器全局变量,document就是window的一个属性\n    // es2015: true, // 表示可以使用 ES6 语法,如 let、const、箭头函数等\n    es2021: true, //  表示可以使用 ES12 语法,如 async/await等 https://zh-hans.eslint.org/docs/latest/use/configure/language-options#\n    node: true, // 表示可以使用 node 环境的全局变量,如 require、module、exports、process写法等\n  },\n  // extends用于继承别人写好的rule规则\n  extends:[ \n    \"eslint:recommended\",\n    \"plugin:@typescript-eslint/recommended\",\n  ],\n  parserOptions: {\n    ecmaVersion: \"latest\", // 指定你想要使用的 ECMAScript 版本\n    sourceType: \"module\",   // 支持脚本类型为模块,否则不支持import/export写法\n    ecmaFeatures: {\n      jsx: true, // 支持jsx语法,否则不支持\n    },\n  },\n  rules: {\n    // 此处就会覆盖掉上面extends继承的规则\n    // 0/off-关闭规则  1/warn-开启规则并标黄 2/error 开启规则并标红\n    \"quotes\": [\"warn\", \"double\"],\n  },\n  globals: {\n    // 定义全局变量(比如是外部script引入的变量)\n    aa: \"writable\", //  readonly表示只读，不可修改，true/writable表示可修改\n  },\n  // 内部解析器,默认不传就是espree, 我们可以自定义解析器,如exprima. 我们随便改一个,比如test,执行npx eslint test.js命令就会去找该解析器,找不到就报错\n  parser: \"test\",\n  // 插件\n  plugins: [\n    // \"@typescript-eslint/eslint-plugin\"\n  ],\n  // parser: \"@typescript-eslint/parser\",\n};\n\n```\n4.package.json新增依赖,然后`pnpm install`\n```js\n\"devDependencies\": {\n  \"eslint\": \"8.57.0\",\n},\n```\n5. 执行检测\n```js\nnpx eslint test.js\n# OR\nnpx eslint --ext .jsx --ext .js lib/\n# OR\nnpx eslint --ext .jsx,.js lib/\n```\n\n### parserOptions.ecmaVersion和env中es的区别\n- ecmaVersion表示要检查代码的 ECMAScript 版本,是从语法层面解析的. 比如只开了ecmaVersion,不开env中es,下面代码会报错不识别\n```js\nvar a={\n    a(){\n    }\n}\n```\n- env中的es是用来表示能否使用es中的全局变量的, 所以使用了全局变量,还需要设置解析器才行.是不是感觉很多余, v9版本已经将这两个配置合并到一起了.\n- 官网文档上描述可以不设置ecmaVersion,只设置env,会自动设置ecmaVersion到对应版本 https://zh-hans.eslint.org/docs/latest/use/configure/language-options#\n- 我们可以在`packages/demo/node_modules/eslint/conf/globals.js`看到可以设置的es版本, es是向下兼容的,只设置一个即可.\n- 一般建议env和parserOptions.ecmaVersion都设置成一样的.\n\n### ts支持\n```js\npnpm install @typescript-eslint/parser typescript @typescript-eslint/eslint-plugin -D\n```\n- **@typescript-eslint/parser: ts解析器(注意设置成ts解析器,不用担心js无法解析, ts解析器是支持js的)**\n\n## extends、plugin、rules区别\n\n### 创建插件\n\n我们直接开发一个plugin来了解区别.\n```js\n# 安装脚手架模版工具\nnpm install -g yo generator-eslint\n\n# 生成eslint插件模版(初始化项目结构)\nyo eslint:plugin\n- What is your name? 插件作者 就是package.json中的author\n- What is the plugin ID? 插件名称, 就是package.json中的name, 会自动拼接上eslint-plugin-\n- Type a short description of this plugin: 插件描述, 就是package.json中的description\n- Does this plugin contain custom ESLint rules? 是否包含自定义规则\n- Does this plugin contain one or more processors?  是否包含处理器\n```\n生成的目录结构如下:\n<img src=\"images/2.jpg\" width=\"80%\" height=\"80%\" />\n\n我们来看下packages/eslint-plugin-test/lib/index.js的内容\n\n```js\n/**\n * @fileoverview 测试插件\n * @author ypf\n */\n\"use strict\";\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst requireIndex = require(\"requireindex\");\n//------------------------------------------------------------------------------\n// Plugin Definition\n//------------------------------------------------------------------------------\n// import all rules in lib/rules\nmodule.exports.rules = requireIndex(__dirname + \"/rules\");\n// 插件处理器,一般用于处理如vue等第三方语法\nmodule.exports.processors = {\n  // add your processors here\n    '.vue' : {\n      preprocess: (code, filename) => {\n      },\n      postprocess: (messages, filename) => {\n      }\n    }\n};\n```\n\n上面的逻辑很简单就是加载rules目录下的所有规则(看requireindex源码,是fs读取文件夹下的所有.js、.json、.node文件)\n\n**至此我们已经完成了一个最简单的插件结构.(插件里面引入了规则rule、processors等)**\n\n### 创建规则\n\n我们在插件的基础上创建一条规则, 比如我们插件名叫no-var, 即不能出现var 关键字\n```js\nyo eslint:rule\n- What is your name? 作者,和上面一样\n- Where will this rule be published 是插件还是官方核心, 自己肯定不开发官方插件,所以是插件false\n- What is the rule ID?  规则名称, 如no-var\n- Type a short description of this rule: 规则描述\n- Type a short example of the code that will fail: 错误示例,可以忽略\n```\n<img src=\"images/3.jpg\" width=\"80%\" height=\"80%\" />\n<img src=\"images/4.jpg\" width=\"80%\" height=\"80%\" />\n\n我们来看下packages/eslint-plugin-test/lib/rules/no-var.js的内容\n```js\n/**\n * @fileoverview 不能有var\n * @author ypf\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    type: null, // `problem`, `suggestion`, or `layout`\n    docs: {\n      description: \"不能有var\",\n      recommended: false,\n      url: null, // URL to the documentation page for this rule\n    },\n    fixable: null, // Or `code` or `whitespace`\n    schema: [], // Add a schema if the rule has options\n    messages: {}, // Add messageId and message\n  },\n\n  create(context) {\n    // variables should be defined here\n\n    //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    // any helper functions should go here or else delete this section\n\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      // visitor functions for different types of nodes\n    };\n  },\n};\n```\n我们编写规则的核心就是在create方法中通过ast编写规则逻辑,进行是否报错修复. 现在我们来编写`no-var`规则\n\n#### 查看要更改的代码ast结构\n\n[astexplorer](https://astexplorer.net/)\n<img src=\"images/5.jpg\" width=\"80%\" height=\"80%\" />\n\n#### context中操作ast\n```js\n module.exports = {\n  meta: {\n    type: `suggestion`, // `problem`, `suggestion`, or `layout` 插件的类型,和rule里面的type不是一个东西,只是用来标识该插件的类型\n    docs: {\n      description: \"不能有var\",\n      recommended: false, // 是否是被推荐的,一般自己的插件不用,是core官方包用的,可以删掉\n      url: null, // URL to the documentation page for this rule 该规则的在线文档地址,可以删掉\n    },\n    // fixable: null, // Or `code` or `whitespace`\n    fixable: 'code', // Or `code` or `whitespace` 修复的是代码还是空格\n    schema: [], // Add a schema if the rule has options\n    messages: {\n      noVar: \"不能有{{name}}\",\n    }, // Add messageId and message\n  },\n  create(context) {\n    const sourceCode = context.sourceCode; // 要用这个来修复代码\n    return {\n      VariableDeclaration: (node) => {\n        // console.log(node);\n        if (node.kind === \"var\") {\n          // 报告问题\n          context.report({\n            node,\n            // 传递给messageId的data\n            data: {\n              name: node.kind,\n            },\n            // message: \"不能有var\", 在上面的messages中定义messageId\n            messageId: \"noVar\",\n            fix: (fixer) => {\n              // 修复代码\n              const varToken = sourceCode.getFirstToken(node, {\n                // filter: (token) => token.value === \"var\", // 测试可以不写\n              });\n              console.log(varToken, \"varToken\");\n              return fixer.replaceText(varToken, \"let\");\n              // return fixer.replaceText(node, \"let\") // 这个会把 var a=1 整个直接替换为let, 所以要找到第一个token即 var\n            },\n          });\n        }\n      },\n    };\n  },\n};\n```\n- message和messageId至少要一个, 不能都写, 一般写messageId\n- context.report()执行代码检测到报告问题,代码会标红(需要编辑器安装eslint插件支持),如果传fix, 当我们执行`npx eslint [glob] --fix`就会执行fix方法进行修复.\n\n**我们在下面安装测试会截图可以看标红**\n\n#### 项目中安装插件测试\n```js\nmkdir demo  \ncd demo \npnpm init  \npnpm install eslint-plugin-test@workspace\ntouch test.js\nvim test.js 写入var a=1\ntouch .eslintrc.js \n```\n.eslintrc.js内容如下:\n```js\nmodule.exports = {\n  env: {\n    browser: true, // 表示可以使用 window/document等浏览器全局变量,document就是window的一个属性\n    es2021: true, //  表示可以使用 ES12 语法,如 async/await等\n    node: true, // 表示可以使用 node 环境的全局变量,如 require、module、exports、process等\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\", // 指定你想要使用的 ECMAScript 版本\n  },\n  // 插件\n  plugins: [\n    \"eslint-plugin-test\" // 或者省略eslint-plugin-直接写test\n  ],\n  // 必须写上rules执行npx eslint才会生效\n  // test下的no-var规则\n rules: {\n    \"test/no-var\": \"error\",\n  },\n};\n```\n**注意:**\n- 必须写上rules执行npx eslint才会生效,否则执行不会有任何反应\n- eslint只要检测到.eslintrc.js就可以在编辑上看到标红, 和执行npx eslint没任何关系,执行会在控制台报错\n\n<img src=\"images/6.jpg\" width=\"80%\" height=\"80%\" />\n上面的fix如果不写fix函数,点击没反应的\n\n现在我们执行下 `npx eslint test.js `,可以看到控制台报错\n<img src=\"images/7.jpg\" width=\"80%\" height=\"80%\" />\n执行`npx eslint test.js --fix`就会执行fix函数修复代码\n\n\n**所以plugin 和 rules 是必须一起使用的**\n\n### 创建extends\n\n上面我们每次使用的时候都要写plugin和rules,这样每次都要写很麻烦,我们可以创建extends,将plugin和rules包含在一起。使用只需要写extends即可。\n\n```js\n// 修改packages/eslint-plugin-test/lib/index.js 即插件js\nmodule.exports = {\n  rules: requireIndex(__dirname + \"/rules\"),\n  configs: {\n    // extends使用的名字,我们这里叫recommended\n    recommended: {\n      // 插件\n      plugins: [\n        \"test\", // 可以省略eslint-plugin-\n      ],\n      rules: {\n        \"test/no-var\": \"error\",\n      },\n    },\n  },\n};\n```\ndemo中使用\n```js\nmodule.exports = {\n  env: {\n    browser: true, // 表示可以使用 window/document等浏览器全局变量,document就是window的一个属性\n    es2021: true, //  表示可以使用 ES12 语法,如 async/await等\n    node: true, // 表示可以使用 node 环境的全局变量,如 require、module、exports、process等\n  },\n  parserOptions: {\n    ecmaVersion: \"latest\", // 指定你想要使用的 ECMAScript 版本\n  },\n  // 插件\n  // plugins: [\n  //   \"eslint-plugin-test\" // 或者省略eslint-plugin-直接写test\n  // ],\n  // 必须写上rules执行npx eslint才会生效\n  // test下的no-var规则\n//  rules: {\n//     \"test/no-var\": \"error\",\n//   },\n  extends: [\n    \"plugin:test/recommended\", // 表示使用test插件的recommended推荐规则, plugin:后不能有空格,否则不生效\n  ]\n};\n```\n\n**所以extends=plugin+rules**\n\n\n## node集成使用\n上面我们使用eslint必须依赖项目使用, 假如我们想封装一个脚手架,直接在任意项目执行检测修复呢? \n[node官网也有文档支持](https://eslint.nodejs.cn/docs/latest/integrate/integration-tutorial)\n\n```js\nimport { ESLint } from \"eslint\";\nimport ESLintPlugin from \"eslint-plugin-test\";\nexport default async function lint(patterns, fix) {\n  const eslint = new ESLint({\n    useEslintrc: false, // 不检测其他规则,只检测i18n规则, 不设置为false,则会检测项目中的.eslintrc.js文件规则\n    // 只检测js,jsx,vue文件\n    extensions: [\".js\", \".jsx\", \".vue\"],\n    fix: fix || false, // 是否自动修复\n    overrideConfigFile: null,\n    plugins: { 'eslint-plugin-test': ESLintPlugin }, // 必须写,下面的extends才能识别, 和配置文件那种不一样,配置文件那种只写extends就行,不用写plugins\n    overrideConfig: {\n      extends: [\n        \"plugin:test/recommended\", // 表示使用test插件的推荐规则, plugin:后不能有空格,否则不生效\n      ],\n    },\n  });\n  Loading.start(`检测中...`);\n  try {\n    // 检查文件\n    const results = await eslint.lintFiles(patterns);\n    if (!fix) {\n      // 判断是否有匹配到错误\n      const hasErrors = results.some(\n        (result) => result.messages && result.messages.length\n      );\n      if (!hasErrors) {\n        return Loading.succeed(`没有要修复的错误`);\n      }\n      Loading.succeed(`检测完成`);\n      // 如果没有fix,则直接输出错误\n      return console.log(stylish(results));\n    }\n    // 判断是否有匹配到错误\n    const hasErrors1 = results.some((result) => result.output || result.warningCount);\n    if (!hasErrors1) {\n      return Loading.succeed(`没有要修复的错误`);\n    }\n    // 输出回原文件\n    await ESLint.outputFixes(results);\n  \n  } catch (error) {\n    Loading.fail(`检测失败`);\n    console.error(chalk.red(error));\n  }\n}\n```\n上面我们执行 `lint([\"test.js\"], true)` 可以执行eslint检测了.可以封装一个eslint-cli,对任意文件夹执行检测和修复\n\n具体其他配置可以看上面官网的文档.\n\n## eslint忽略\n### 忽略文件/文件夹\n1. 根目录新建.eslintignore文件\n2.写入\n```js\ntest.js // 忽略单个文件\ntest // 忽略test文件夹下的所有文件\n```\n### 代码忽略\n```js\nalert(1) // eslint-disable-line  忽略当前行\n// eslint-disable-next-line  忽略下一行\nalert(1) \n/* eslint-disable */ // 忽略整个文件(注意, 放到代码任何位置都行,都会忽略整个文件, 一般放到顶部. // eslint-disable测试不生效;  )\nalert(1)\n\n/* eslint-disable */ 块级忽略\nalert(1)\n/* eslint-disable */ \n\n```\n","categories":["eslint"]},{"title":"2.eslint原理","url":"/ypf-blog/2024/08/01/eslint/2.eslint原理/","content":"# 调试源码\n我们要了解eslint原理,需要在vscode中打开一个 `javascript调试终端`, 然后执行 `npx eslint ...`, 编辑器会自动定位到**运行和调试**,但此时没有断点. 然后我们去node_modules/eslint中打上一个断点, 重新执行下`npx eslint ...`就会触发断点了.\n\n# 原理\n\n## 执行bin命令\n我们正常执行eslint命令,相当于**执行bin命令**(node_modules中eslint/bin/eslint目录执行Execute方法)\n\n<img src=\"images/1.jpg\" width=\"50%\" height=\"50%\" />\n\n## parse解析命令行参数以及初始化默认参数\n解析参数为对象以及对象中加一些初始化默认参数, 如—fix变为 `—fix:true`\n<img src=\"images/2.jpg\" width=\"50%\" height=\"50%\" />\n\n## 初始化类生成eslint实例\n执行`const engine=new ESlint()`\n<img src=\"images/3.jpg\" width=\"50%\" height=\"50%\" />\nESlint类中主要定义了`lintFiles、outputFixes、getErrorResults、lintText`等方法\n\n## 进行检测\n调用`engine.lintFiles()`进行规则检测\n<img src=\"images/4.jpg\" width=\"50%\" height=\"50%\" />\n\n### 解析文件路径为数组进行循环\n比如执行`npx eslint src`就会解析成`[{path:'1.js',config,...},{path:'2.js',config,...'}]`\n<img src=\"images/4-1.jpg\" width=\"50%\" height=\"50%\" />\nconfig就是规则数组,包含默认和用户自己的( 1.默认忽略规则2.被检测的文件夹中的.eslintrc.js规则文件)\n<img src=\"images/4-2.jpg\" width=\"50%\" height=\"50%\" />\n\n### 根据文件数组循环调用verifyText进行检测以及生成修复补丁、结果(fs直接获取内容)\n<img src=\"images/4-3.jpg\" width=\"50%\" height=\"50%\" />\n\n#### do while循环计数检测生成修复代码补丁、结果(注此时没有更新到文件)\n循环检测:\n- 如果有--fix,检测完生成修复补丁,根据补丁生成修复结果fixedResult,再拿着fixedResult的output当成文本检测一次(`这里就是let a=1,第一次是var a=1`),直至没有错误为止.(eslint默认最多循环10次(eslint默认初始化定义了 `const MAX_AUTOFIX_PASSES=10`))\n- 如果没有, 检测一次后生成修复补丁就跳出,不会根据补丁生成修复结果去检测\n**修复补丁**\n<img src=\"images/4-10.jpg\" width=\"50%\" height=\"50%\" />\n\n**修复结果**\n<img src=\"images/4-4-1.jpg\" width=\"50%\" height=\"50%\" />\n\n##### 利用解析器将文本转为ast树\n<img src=\"images/4-4.jpg\" width=\"50%\" height=\"50%\" />\n\n##### 遍历ast,将节点拍平为一维数组存起来\n<img src=\"images/4-5.jpg\" width=\"50%\" height=\"50%\" />\n\n##### 读取配置规则进行遍历校验\n\n<img src=\"images/4-6.jpg\" width=\"50%\" height=\"50%\" />\n\n- 获取每个规则的create函数(里面是用户自定义规则的各个ast节点函数)进行遍历,并定义了一个emitter钩子监听器用于存储每个ast节点函数\n<img src=\"images/4-7.jpg\" width=\"50%\" height=\"50%\" />\n\n- 遍历之前存储的一维ast数组节点,执行emitter匹配到的节点函数,并传入context上下文(context定义了report上报方法)\n<img src=\"images/4-9.jpg\" width=\"50%\" height=\"50%\" />\n<img src=\"images/4-8.jpg\" width=\"50%\" height=\"50%\" />\n\n- 当执行节点函数就会执行`context.report`逻辑, 如果存在fix方法,就会触发fix方法(所以无论执行命令存不存在--fix都会触发fix方法),生成一个修复补丁对象(包含修复后节点的文本,以及被修复的节点位置loc),此时还不会覆盖到原代码. (因为是遍历ast每个节点,所以假设有两个var,都要变成let, 遍历会触发2次VariableDeclaration方法,所以每个修复补丁都会细致到节点,都会有对应的位置loc)\n<img src=\"images/4-10.jpg\" width=\"50%\" height=\"50%\" />\n\n- 如果有--fix,根据补丁生成修复结果fixedResult,再拿着fixedResult的output当成文本会再执行一次检测是否修复好了,没好再重复循环,最多10次;\n- 如果没有--fix,直接跳出\n\n\n## 进行修复\n<img src=\"images/5.jpg\" width=\"50%\" height=\"50%\" />\n<img src=\"images/5-1.jpg\" width=\"50%\" height=\"50%\" />\n此时才会写入文件, 上面检测只会生成修复补丁, 不会覆盖到原文件\n\n\n## 统计打印结果\n打印总计多少错误、警告、每个错误文件路径等信息\n<img src=\"images/6.jpg\" width=\"50%\" height=\"50%\" />\n\n# 流程图\n<img src=\"images/7.jpg\" width=\"80%\" height=\"80%\" />\n<img src=\"images/8.jpg\" width=\"80%\" height=\"80%\" />\n","categories":["eslint"]},{"title":"ast实际应用","url":"/ypf-blog/2024/07/02/ast/ast实际应用/","content":"# esprima\n**使用esprima解析器用法,将下面函数进行转换**\n## 实战1-函数名修改 \n```js\nfunction a() {\n}\n// 转换为 函数名a变为b\nfunction b() {\n}\n```\n我们先看下[astexplorer](https://astexplorer.net/)的ast长什么样子\n<img src=\"images/1.jpg\" width=\"80%\" height=\"80%\" />\n\n```js\nconst esprima = require(\"esprima\"); // 最早ast的编译器\nconst estraverse = require(\"estraverse\"); // 遍历ast\nconst escodegen = require(\"escodegen\"); // ast生成代码\nlet code = `\nfunction a() {\n}\n`;\n// 1.将代码转换成ast语法树\nlet ast = esprima.parseScript(code);\nconsole.log(ast)\n\n// 2.遍历ast语法树(访问器)\n// estraverse.traverse没有返回值,直接修改原来的的ast,同步操作\n// ast遍历逻辑是: 遍历树,先进后出(从外面进去,从里面再出来), Program->FunctionDeclaration->Identifier(再走到leave的Identifier,即退出)->BlockStatement(再走到leave的BlockStatement,即退出)->....\nestraverse.traverse(ast, {\n  // 进入节点\n  enter(node) {\n    console.log(node.type, \"enter\");\n    if (node.type === \"FunctionDeclaration\") {\n      node.id.name = \"b\";\n    }\n  },\n  //   退出节点\n  leave(node) {\n    console.log(node.type, \"exit\");\n  },\n});\nconsole.log(ast.body);\n\n// 3.ast转换代码\nconst output = escodegen.generate(ast);\nconsole.log(output);\n```\n### 代码转ast\n打印结果如就是上面最开始用astexplorer查看的样子\n### traverse\n- estraverse是一个ast访问器,用来遍历ast语法树.\n- 没有返回值,直接修改原来的的ast,同步操作,我们打印的`ast.body`如下图,已经修改了\n- ast遍历的顺序是先进后出(从外面进去,从里面再出来). 上面的函数大概步骤是`Program->FunctionDeclaration->Identifier(再走到leave的Identifier,即退出)->BlockStatement(再走到leave的BlockStatement,即退出)->....`\n如下图\n<img src=\"images/2.jpg\" width=\"80%\" height=\"80%\" />\n\n### ast生成代码\n<img src=\"images/3.jpg\" width=\"80%\" height=\"80%\" />\n\n# babel\nbabel解析器核心:`@babel/core,实际其内部require了@babel/parser和@babel/traverse`\n使用babel解析器用法,将下面函数进行转换\n\n## 实战1-箭头函数转普通函数\n```\nconst sum = (a, b) => a+b\n转换为\nconst sum = function(a, b) {\n  return a+b\n}\n```\n我们先看下[astexplorer](https://astexplorer.net/)的ast长什么样子\n<img src=\"images/4.jpg\" width=\"80%\" height=\"80%\" />\n我们可以看到要转换为普通函数,要注意\n- 要新增了大括号节点(BlockStatement)+return节点(ReturnStatement),然后包裹老的二进制表达式(BinaryExpression)节点\n\n### babel-plugin-transform-es2015-arrow-functions\n我们先看下第三方插件转换结果\n```js\nconst babel = require(\"@babel/core\");\nconst t = require(\"@babel/types\");\nconst transformArrowFunction = require(\"babel-plugin-transform-es2015-arrow-functions\"); // 箭头函数转普通函数\n// 实现 将箭头函数转换为普通函数\nconst code = `\n  const sum = (a, b) => a+b\n`;\n// 代码转换\nconst result = babel.transform(code, {\n  plugins: [transformArrowFunction], // 插件\n  presets: [], // 预设(插件的集合)\n})\nconsole.log(result.code);\n```\n<img src=\"images/5.jpg\" width=\"80%\" height=\"80%\" />\n\n### 实现\n现在我们来实现,修改上面代码\n```js\nconst babel = require(\"@babel/core\");\nconst t = require(\"@babel/types\");\n// 实现\nconst transformArrowFunction={\n    visitor:{\n        ArrowFunctionExpression(path){ // path-就是访问的路径树, 包含一层层父级\n            const {node} = path;\n            // 1. 修改type\n            node.type=\"FunctionExpression\"; // const sum = function (a, b) a + b;\n            let body = node.body; // 老节点的 a+b\n            // 原格式可以有大括号const sum = (a, b) => {return a + b}, 或者没有const sum = (a, b) => a + b\n            // 2.所以我们需要判断有没有大括号(注意,不需要判通过有没有return来判断,因为有大括号肯定有return;没有大括号,肯定没return)\n            if(!t.isBlockStatement(body)){\n                // 没有大括号,需要创建大括号节点(BlockStatement)+return节点(ReturnStatement)\n                node.body = t.blockStatement([\n                    // t.expressionStatement(t.stringLiteral('hello')), \n                    t.returnStatement(body),\n                ])\n            }\n        }\n    }\n}\n// 实现 将箭头函数转换为普通函数\nconst code = `\n  const sum = (a, b) => a+b\n`;\n// 代码转换\nconst result = babel.transform(code, {\n  plugins: [transformArrowFunction], // 插件\n  presets: [], // 预设(插件的集合)\n})\n```\n上面逻辑很简单\n1. 修改type为普通函数`FunctionExpression`\n2. 判断有没有大括号,没有则创建大括号节点(BlockStatement)+return节点(ReturnStatement)\n\n上面是对原ast进行修改的,我们也可以生成一个新的ast直接`替换`旧的\n```js\nconst transformArrowFunction={\n    visitor:{\n        ArrowFunctionExpression(path){\n            let node=path.node\n            let params=node.params\n            let body;\n            if(!t.isBlockStatement(node.body)){\n                 body=t.blockStatement([t.returnStatement(node.body)])\n            }else{\n                body=node.body\n            }\n            //t.functionExpression(id, params, body, generator, async);\n            let functionExpression=t.functionExpression(null, params, body, false, false);\n            path.replaceWith(functionExpression)\n        }\n    }\n}\n```\n- 直接创建一个es5节点进行替换\n## 实战2-箭头函数转普通函数this指向\n\n我们修改下转换前代码\n```js\nfunction aa() {\n    const sum = () => console.log(this)\n}\n```\n此时我们还是用第三方库`babel-plugin-transform-es2015-arrow-functions`转换下,可以看到下面结果\n<img src=\"images/6.jpg\" width=\"80%\" height=\"80%\" />\n\n我们知道:`箭头函数没有this,他的this就是会一层层往上找最近作用域的this`\n所以我们要实现\n1. 在最近作用域创建`var _this = this;`\n2. 修改箭头函数的所有用到this的地方为`_this`\n\n### 实现\n```js\nconst babel = require(\"@babel/core\");\nconst t = require(\"@babel/types\");\n// 实现上面transformArrowFunction插件\nconst transformArrowFunction = {\n  visitor: {\n    ArrowFunctionExpression(path) {\n      const { node } = path;\n      // 处理this问题\n      processFunctionScope(path);\n      // 转换为普通函数\n      node.type = \"FunctionExpression\"; // const sum = function (a, b) a + b; 此时存在括号问题\n      let body = node.body; // 老节点的 a+b\n      // 原格式可以有大括号或者const sum = (a, b) => {return a + b}, 没有const sum = (a, b) => a + b\n      // 所以我们需要判断有没有大括号(注意,不需要判通过有没有return来判断,因为有大括号肯定有return;没有大括号,肯定没return)\n      if (!t.isBlockStatement(body)) {\n        // 没有大括号,需要创建大括号节点(BlockStatement)+return节点(ReturnStatement)\n        node.body = t.blockStatement([\n          // t.expressionStatement(t.stringLiteral('hello')),\n          t.returnStatement(body),\n        ]);\n      }\n    },\n  },\n};\n// 处理作用范围\nfunction getThisPaths(path) {\n  const arr = []; // 所有的this节点集合\n  path.traverse({\n    // this节点\n    ThisExpression(path) {\n      arr.push(path);\n    },\n  });\n  return arr;\n}\nfunction processFunctionScope(path) {\n  // 1. 查找父作用域\n  //   判断是函数且不是箭头函数,此时就是this的作用域 或者直接到根节点作用域(isProgram)\n  const thisEnv = path.findParent((path) => {\n    return (\n      (path.isFunction() && !path.isArrowFunctionExpression()) ||\n      path.isProgram()\n    );\n  });\n  console.log(thisEnv.node.id);\n  //   2.创建var _this=this\n  const bindingThis = \"_this\";\n  //   找到所有的this进行替换_this,this的type是ThisExpression,可以去astexplorer查看\n  const thisPaths = getThisPaths(path);\n  thisPaths.forEach((path) => {\n    // this-> _this\n    path.replaceWith(t.identifier(bindingThis));\n  });\n  //   3. 在上层作用域创建 var _this=this\n  thisEnv.scope.push({\n    id: t.identifier(bindingThis),\n    init: t.thisExpression()\n  });\n}\n\nconst code = `\n  function aa() {\n      const sum = () => console.log(this)\n  }\n`;\n// 代码转换\nconst result = babel.transform(code, {\n  plugins: [transformArrowFunction], // 插件\n  presets: [], // 预设(插件的集合)\n});\nconsole.log(result.code);\n```\n\n### 找到箭头函数的上级作用域\n\n- 找作用域`processFunctionScope`: **上级是函数且不是箭头函数**或者是**最外层根节点**\n- 找到所有箭头函数用到this地方放到数组中: `getThisPaths`方法\n- 遍历上面this数组,替换this为_this: `replaceWith`方法\n- 在作用域上创建`var _this=this`: `scope.push`方法\n\n## 实战3-预计算\n> `let delay= 2*3*4` 转换为 `let delay= 24`,  因为到浏览器端执行计算就会慢,可以在编译时就提前计算,到浏览器运行直接展示\n```js [toggle]\nconst preCalculatePlugin= {\n  visitor: {\n    // 节点是二进制表达式\n    BinaryExpression(path) {\n        let node=path.node\n        let left=node.left\n        let right=node.right\n        let operator=node.operator\n        console.log('left',left.type,left.value);\n        console.log('right',right.type,right.value);\n        if (t.isNumericLiteral(left) && t.isNumericLiteral(right)) {\n            if(!isNaN(left.value) && !isNaN(right.value)){\n                let value=eval(left.value + operator + right.value)\n                path.replaceWith(t.numericLiteral(value))\n                // 很重要, 因为如果不加, 执行到6 * 4 就结束了\n                if(path.parent&&path.parent.type === \"BinaryExpression\"){\n                    preCalculatePlugin.visitor.BinaryExpression.call(null,path.parentPath)\n                }\n            }\n        }\n    },\n  },\n};\nconst result = babel.transform(code, {\n  plugins: [\n    preCalculatePlugin,\n  ],\n});\nconsole.log(result.code);\n```\n执行顺序是:\n<img src=\"images/7.jpg\" width=\"80%\" height=\"80%\" />\n\n## 实战4-Class转换es5\n```js [toggle]\nconst babel = require(\"@babel/core\");\nconst t = require(\"@babel/types\");\nconst generator = require(\"@babel/generator\");\n// const transformClassesPlugin = require(\"babel-plugin-transform-es2015-classes\");\n// https://babel.dev/docs/babel-types\nconst code = `\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n    getName() {\n        return this.name;\n    }\n}\n`;\n// 转为\n// function Person (name) {\n//   this.name = name;\n// }\n// Person.prototype.getName= function (){\n//     return this.name;\n// }\nconst classPlugin = {\n  visitor: {\n    ClassDeclaration(path) {\n      let node = path.node;\n      let id = node.id;\n      let methods = node.body.body;\n      let expressions = [];\n      methods.forEach((method) => {\n        if (method.kind === \"constructor\") {\n          let functionDeclaration = t.functionDeclaration(\n            id,\n            method.params,\n            method.body\n          );\n          expressions.push(functionDeclaration);\n        } else if (method.kind === \"method\") {\n          let expressionStatement = t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              t.memberExpression(\n                t.memberExpression(id, t.identifier(\"prototype\")),\n                method.key\n              ),\n              t.functionExpression(null, method.params, method.body)\n            )\n          );\n          expressions.push(expressionStatement);\n        }\n      });\n      path.replaceWithMultiple(expressions); // 批量替换\n    },\n  },\n};\nconst result = babel.transform(code, {\n  plugins: [classPlugin],\n});\nconsole.log(result.code);\n```\n## 实战5-babel-plugin-import按需加载\n> `import {flatten,concat} from 'lodash'`转换为 \n> `import flatten from \"lodash/flatten\";import concat from \"lodash/concat\";`\n```js [toggle]\nconst code = `\nimport {flatten,concat} from 'lodash';\n`;\nconst classPlugin = {\n  visitor: {\n    ImportDeclaration(path) {\n      let node = path.node;\n      let id = node.id;\n      let source = node.source;\n      let specifiers = node.specifiers;\n      let expressions = [];\n      specifiers.forEach((specifier) => {\n        // 判断下,否则下面又构造一个importDeclaration会导致死循环\n        if (specifier.type === \"ImportSpecifier\") {\n          expressions.push(\n            t.importDeclaration(\n              [t.importDefaultSpecifier(specifier.local)],\n              t.stringLiteral(`${source.value}/${specifier.local.name}`)\n            )\n          );\n        }\n      });\n      if(expressions.length){\n          path.replaceWithMultiple(expressions); // 批量替换\n      }\n    },\n  },\n};\nconst result = babel.transform(code, {\n  plugins: [classPlugin],\n});\nconsole.log(result.code);\n```\n- 因为lodash直接加载,会把所有包都加载进来,我们可以按上面方式实现按需加载\n- 注意⚠️: 该方法的前提是组件`必须拆`出来一个个模块. lodash、ant、element、vant都是这样子的.\n- 上面就是 `babel-plugin-import`的原理, 一般组件库实现按需都是这样拆出来一个个模块的.\n\n<img src=\"images/8.jpg\" width=\"50%\" height=\"50%\" />\n\n","categories":["ast"]},{"title":"7.比对更新","url":"/ypf-blog/2024/06/26/vue3源码/7.比对更新/","content":"# 基本使用\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n  </body>\n  <script src=\"../packages/runtime-dom/dist/@vue/runtime-dom.global.js\"></script>\n  <!-- <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.js\"></script> -->\n  <script>\n    const { createApp, h, reactive } = window.VueRuntimeDom;\n    let App = {\n      setup(props) {\n        const state = reactive({\n          name: \"1\",\n          isShow: true,\n        });\n        setTimeout(() => {\n          state.isShow = false;\n        }, 1000);\n        return {\n          state,\n        };\n      },\n      render(proxy) {\n        if (proxy.state.isShow) {\n          const a = h(\n            \"div\",\n            {\n              style: {\n                color: \"red\",\n              },\n            },\n            [\n              h(\"span\", { key: \"A\" }, \"A\"),\n              h(\"span\", { key: \"B\" }, \"B\"),\n              h(\"span\", { key: \"C\" }, \"C\"),\n              h(\"span\", { key: \"D\" }, \"D\"),\n              h(\"span\", { key: \"E\" }, \"E\"),\n              h(\"span\", { key: \"Q\" }, \"Q\"),\n              h(\"span\", { key: \"F\" }, \"F\"),\n              h(\"span\", { key: \"G\" }, \"G\"),\n            ]\n          );\n          console.log(a, \"aaaa\");\n          return a;\n        } else {\n          const b = h(\n            \"div\",\n            {\n              style: {\n                color: \"blue\",\n              },\n            },\n            [\n              h(\"span\", { key: \"A\" }, \"A\"),\n              h(\"span\", { key: \"B\" }, \"B\"),\n              h(\"span\", { key: \"E\" }, \"E\"),\n              h(\"span\", { key: \"C\" }, \"C\"),\n              h(\"span\", { key: \"D\" }, \"D\"),\n              h(\"span\", { key: \"H\" }, \"H\"),\n              h(\"span\", { key: \"F\" }, \"F\"),\n              h(\"span\", { key: \"G\" }, \"G\"),\n            ]\n          );\n          console.log(b, \"bbbb\");\n          return b;\n        }\n      },\n    };\n    // a b c d e q f g\n    // a b e c d h f g\n    createApp(App, {\n      test: 1,\n    }).mount(\"#app\");\n  </script>\n</html>\n```\n# 更新流程\n\n我们上节课讲过, `render函数是通过创建一个effect执行的`,所以当我们修改state后,会再次触发该state收集的effect函数执行, 拿到新的vnode,然后通过`patch`函数进行对比新老vnode进行vnode的el属性更新.\n<img src=\"images/1.jpg\" width=\"80%\"/>\n\n```js\n    const setupRenderEffect = (instance, container) => {\n        // 创建effect, 在effect中调用render函数,这样render函数中获取数据就会收集这个effect\n        effect(function componentEffect() {\n            // 判断instance.isMounted: 是否挂载完成. 第一次肯定为false,否则为更新\n            if (!instance.isMounted) {\n                window.console.groupInfo('挂载')\n                // 渲染组件\n                const proxy = instance.proxy\n                console.log('执行render函数,并传入proxy且this也指向proxy')\n                console.log('const subTree =instance.render.call(instance.proxy, instance.proxy)')\n                const subTree = instance.subTree = instance.render.call(proxy, proxy)\n                // 将render执行的结果再次patch即render渲染', 'patch(null, subTree, container)'\n                patch(null, subTree, container)\n                console.log('挂载完成修改标识位', 'instance.isMounted = true')\n                instance.isMounted = true // 组件挂载完成\n            } else {\n                window.console.groupInfo('更新')\n                // 比对旧和新\n                const prevTree = instance.subTree // 旧的vnode\n                const proxy = instance.proxy\n                const nextTree = instance.render.call(proxy, proxy) // 执行获取新的vnode\n                instance.subTree = nextTree // 更新为新的vnode\n                patch(prevTree, nextTree, container)\n                window.console.groupInfoEnd()\n            }\n            window.console.groupInfoEnd()\n        })\n    }\n      const patch = (n1, n2, container, anchor = null) => {\n        // 针对不同类型的节点，做不同的处理 组件、元素、文本、注释\n        let { shapeFlag, type } = n2\n        console.log('判断type类型:', `type: ${type}`, `shapeFlag: ${shapeFlag}`)\n        // 比对\n        if (n1 && !isSameVNodeType(n1, n2)) { // 如果不是同一个元素,直接删除旧的,替换为新的\n            console.log('判断type不是同一个元素,直接删除旧的并n1=null,这样当patch时候,判断n1=null就是第一次挂载')\n            // 删除旧的\n            unmount(n1)\n            n1 = null\n        }\n        switch (type) {\n            case Text:\n                window.console.groupInfo(\"是文本: 进行文本挂载\")\n                processText(n1, n2, container)\n                window.console.groupInfoEnd()\n                break\n            default:\n                // 如果是元素\n                if (shapeFlag & ShapeFlags.ELEMENT) {\n                    // 元素挂载\n                    window.console.groupInfo(\"是元素: 进行元素挂载\", \"processElement(n1, n2, container, anchor)\")\n                    processElement(n1, n2, container, anchor)\n                    window.console.groupInfoEnd()\n                } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) { // 如果是组件\n                    window.console.groupInfo(\"是组件: 进行组件挂载\")\n                    console.log('执行: processComponent(n1, n2, container)函数. ', \"n1-旧虚拟节点,n2-新虚拟节点,container-容器\")\n                    // 组件挂载\n                    processComponent(n1, n2, container)\n                    window.console.groupInfoEnd()\n                }\n        }\n    }\n```\n我们梳理下流程\n\n## 如果不是同一个元素,直接卸载旧的,替换为新的\n\n```js\nconst patch = (n1, n2, container, anchor = null) => {\n  if (n1 && !isSameVNodeType(n1, n2)) { // 如果不是同一个元素,直接删除旧的\n      console.log('判断type不是同一个元素,直接删除旧的并n1=null,这样当patch时候,判断n1=null就是第一次挂载')\n      // 删除旧的\n      unmount(n1)\n      n1 = null // 因为为null,后面就会判定为第一次加载\n  }\n  ...\n  if (shapeFlag & ShapeFlags.ELEMENT) {\n      // 元素挂载\n      processElement(n1, n2, container, anchor)\n  }\n}\n\n// 判断新旧节点是否相同\nconst isSameVNodeType = (n1, n2) => {\n    return n1.type === n2.type && n1.key === n2.key\n}\n// 卸载\nconst unmount = (vnode) => {\n    hostRemove(vnode.el)\n}\nconst processElement = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n        window.console.groupInfo(\"n1为null,第一次挂载\")\n        // 初始化(第一次挂载)\n        mountElement(n2, container, anchor)\n        window.console.groupInfoEnd()\n    } else {\n        // 更新\n        window.console.groupInfo(\"n1不为null,比对更新\")\n        patchElement(n1, n2, container, anchor)\n        window.console.groupInfoEnd()\n    }\n}\n```\n- 上面判断type+key来保证不是同一个元素,不是的话直接卸载旧的\n- 替换为新的: 因为将n1置为null,下面走到判断是元素->`元素挂载processElement(n1, n2, container, anchor)`->根据n1有没有值来判断是第一次挂载还是更新\n## 比对属性增删改 patchProps\n```js\n  const patchElement = (n1, n2, container, anchor) => {\n      let el = (n2.el = n1.el)\n      // 比对属性-增删改\n      const oldProps = n1.props || {}\n      const newProps = n2.props || {}\n      patchProps(el, oldProps, newProps)\n      // 比对儿子\n      patchChildren(n1, n2, el)\n  }\n```\n## 比对儿子 patchChildren\n比对儿子存在4种情况\n\n1. 新的是文本\n  - 旧的是数组- 遍历卸载(删除)旧数组,设置新文本\n  - 旧的是文本- 对比不相同,直接设置新文本 \n2. 新的是数组\n  - 旧的是数组- 对比数组(最长递增子序列算法)\n  - 旧的是文本- 清空文本(设置文本为空),挂载新数组\n\n### 新的是文本,旧的是数组\n> 遍历卸载(删除)旧数组,设置新文本\n```js\nconst prevShapeFlag = n1.shapeFlag // 旧的标识\nconst newShapeFlag = n2.shapeFlag // 新的标识\nif (newShapeFlag & ShapeFlags.TEXT_CHILDREN) { // 新的是文本\n    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) { // 旧的是数组\n        console.log('旧的是数组,遍历数组卸载旧的')\n        unmountChildren(c1) // 卸载旧的\n    }\n    // 旧的是数组/文本都要设置文本\n    if (c2 !== c1) {\n        console.log('判断新旧文本不同,设置新文本')\n        hostSetElementText(el, c2) // 设置文本 如h('div',{}, 'hello1')=>  h('div',{}, 'hello2')\n    }\n}\nconst unmountChildren = (children) => {\n    for (let i = 0; i < children.length; i++) {\n        unmount(children[i])\n    }\n}\n```\n\n### 新的是文本,旧的是文本\n> 对比不相同,直接设置新文本\n就是上面代码的逻辑\n\n### 新的是数组,旧的是文本\n> 清空文本(设置文本为空),挂载新数组\n\n```js\nif (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {  // 旧的是数组\n    if (newShapeFlag & ShapeFlags.ARRAY_CHILDREN) {  // 新的是数组 如h('div',{}, [h('span',{},'hello1')])=>  h('div',{}, [h('span',{},'hello2')])\n        patchKeyedChildren(c1, c2, el)\n    }\n} else { // 旧的是文本,新的是数组 如h('div',{}, 'hello1')=>  h('div',{}, ['hello2'])\n    hostSetElementText(el, '') // 清空文本\n    mountChildren(c2, el) // 挂载新数组 \n}\n// 递归挂载\nconst mountChildren = (children, container) => {\n    console.log('遍历children数组,如果遍历的元素是文本,创建文本虚拟dom,递归调用patch函数')\n    for (let i = 0; i < children.length; i++) {\n        let child = normalizeVNode(children[i])\n        patch(null, child, container)\n    }\n}\n```\n### 新的是数组,旧的是数组\n> 对比数组(最长递增子序列算法)\n\n就是上面代码的逻辑 `patchKeyedChildren(c1, c2, el)`, 下面着重讲解\n\n## 新老都是数组\n核心点: 最长递增子序列+二分查找法\n- 正序头头对比,type和key一致就进行patch渲染,一旦不一样停止\n- 开始倒序尾尾对比,type和key一致就进行patch渲染,一旦不一样停止\n- 剩下乱序对比(最长递增子序列算法+二分查找法)\n```js\n// 比对数组\nconst patchKeyedChildren = (c1, c2, el) => {\n  let i = 0 // 表示循环到哪个地方\n  let e1 = c1.length - 1 // 旧的结束索引\n  let e2 = c2.length - 1 // 新的结束索引\n  // 1. 正序头头对比\n  // 2. 倒序尾尾对比\n  // 3. 乱序对比\n  ...\n}\n```\n### 正序头头对比\n```js\n// 1. 头部按序比对,type和key一致就进行patch渲染,一旦不一致跳出\nwhile (i <= e1 && i <= e2) {\n    const n1 = c1[i]\n    const n2 = c2[i]\n    if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, el)\n    } else {\n        break // 跳出后下面i++就不会执行了\n    }\n    i++\n}\n```\n### 倒序尾尾对比\n```js\n// 2. 尾部倒序比对,type和key一致就进行patch渲染,一旦不一致跳出\nwhile (i <= e1 && i <= e2) {\n    const n1 = c1[e1]\n    const n2 = c2[e2]\n    if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, el)\n    } else {\n        break\n    }\n    e1--\n    e2--\n}\n```\n**上面经过2轮对比,开头i,结尾e1,e2就会往中间靠拢,剩下的就是乱序即不一样的**\n### 剩下乱序对比\n存在3种情况:\n- 旧的长度少,新的多, 此时肯定要把多的新增(往前增或者往后增)\n- 旧的长度多,新的少, 此时肯定要把多的删除\n- 乱序(也会包含长度少,多的情况,只不过对比都不一样)\n\n#### 旧的长度少,新的多,把多的新增(往前增或者往后增)\n```js\n// 3. 旧的少新的多, 添加数据\n// (a b)\n// (a b) c\n// i = 2, e1 = 1, e2 = 2\n// (a b)\n// c (a b)\n// i = 0, e1 = -1, e2 = 0\nif (i > e1) { // 说明旧的肯定遍历完了,新的还有剩余\n    if (i <= e2) { // 不和上面的if合并,因为旧的和新的比如都是 a, 这样就会走到乱序对比, 写到这走到第一层if,里面的if也不会走进去执行\n        // 头部添加还是尾部添加?\n        const nextPos = e2 + 1\n        // 如果是前添加, e2+1一定<c2.length\n          console.log(nextPos, c2.length, '如果e2 + 1 < c2.length,则是前添加,否则是后添加,因为序号<自身长度,说明肯定倒序移动对比了,肯定是要插入某个元素前面', 'const anchor = nextPos < c2.length ? c2[nextPos].el : null')\n        const anchor = nextPos < c2.length ? c2[nextPos].el : null\n        while (i <= e2) {\n            patch(null, c2[i++], el, anchor)\n        }\n    }\n}\n```\n- `i > e1`,说明旧的肯定遍历完了,此时如果`i<=e2`说明新的还有剩余,所以把多的新增(往前增或者往后增), 往前需要锚点,往后需要锚点,直接添加到最后\n- 判断前后: `如果e2 + 1 < c2.length`,说明肯定倒序移动了才会e2变小,因为本身前面等式是相等的.此时锚点就是 e2+1,插入该元素前面. 为什么加1是因为, 遍历完多执行了一遍-1,所以加上才是最后一次遍历的位置.\n- 最后遍历`i <= e2`,进行patch\n\n#### 旧的长度多,新的少,把多的删除\n\n```js\n// 4.旧的多新的少, 删除数据\n// (a b) c\n// (a b)\n// i = 2, e1 = 2, e2 = 1\n// a (b c)\n// (b c)\n// i = 0, e1 = 0, e2 = -1\nelse if (i > e2) { // 说明新的肯定遍历完了,旧的还有剩余\n    while (i <= e1) {\n        unmount(c1[i++])\n    }\n}\n```\n- `i > e2`,说明新的肯定遍历完了, 此时如果`i<=e1`说明旧的还有剩余,所以把多的删除, 删除的时候不需要锚点,直接删除`i<=e1`里面的元素即可\n\n#### 未知顺序(乱序)\n\n乱序中存在一部分新旧相同的节点,此时要去处理: `相同进行移动,剩下的再进行删除/新增`\n比如:\n```js\na b c\na c b\n此时i=1,e1=2,e2=2\n```\n##### 用剩下的新的创建新映射表\n```js\nconst s1 = i\nconst s2 = i\nconst newKeyIndexMap = new Map()\n// 以新的数据创建一个映射表 build key:index map for newChildren\nfor (let i = s2; i <= e2; i++) {\n    newKeyIndexMap.set(c2[i].key, i)\n}\n```\n此时newKeyIndexMap结果为  `Map(2) {'C' => 1, 'B' => 2}`\n\n##### 遍历旧的,如果在新的映射表中也存在,则复用移动,如果不存在,则删除\n\n```js\nconst toBePatched = e2 - s2 + 1 // 乱序的个数\nconst oldNodeInNewNodePosIndexArray= new Array(toBePatched).fill(0)\nfor (let i = s1; i <= e1; i++) {\n    const oldChildVnode = c1[i]\n    const newIndex = newKeyIndexMap.get(oldChildVnode.key)\n    if (newIndex == undefined) { // 旧的在新的没有,删除\n        unmount(oldChildVnode)\n    } else { // 旧的在新的有,复用移动\n        oldNodeInNewNodePosIndexArray[newIndex - s2] = i + 1 // 新的数据在旧的数据的索引位置 +1\n        patch(oldChildVnode, c2[newIndex], el) // 此时存在2个问题: 复用的元素没有移动、新创建的元素没有创建出来\n    }\n}\na b c\n  3 2 在新元素中的位置+1,比如,b在新的元素中的位置是2,c在新的元素中的位置是1, 所以都+1后是 3 2\na c b\n```\n\n此时oldNodeInNewNodePosIndexArray结果为`[3, 2]`\n- 遍历旧的,然后去新映射表里面找,找不到,就把旧的卸载\n- 找到的话,定义一个数组`oldNodeInNewNodePosIndexArray`用于**存储老的元素在新的元素中的位置**,后面使用\n- oldNodeInNewNodePosIndexArray初始化的时候,是通过乱序的个数`e2 - s2 + 1`进行填充0, 为什么是 `e2 - s2 + 1`? 因为肯定以新的为基准,旧的不能为基准,旧的就算比新的多,多的也是要删除的.\n- 最后进行对这些新老相同的节点,进行patch比对渲染`patch(oldChildVnode, c2[newIndex], el)`\n\n此时仍存在2个问题:\n- 复用的元素只是patch进行递归对比了,但并没有移动\n- 上面只对比了,旧的在新的不存在-删除,旧的在新的存在-复用, 但是新的还有一部分是新增的,没有创建出来\n\n##### 最长递增子序列\n","categories":["vue3源码"]},{"title":"6.渲染(h、createApp)","url":"/ypf-blog/2024/06/17/vue3源码/6.渲染(h、createApp)/","content":"## 基本使用\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n  </head>\n  <body>\n    <div id=\"app\"></div>\n  </body>\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.js\"></script>\n  <script>\n    const { createApp, h, reactive } = window.Vue;\n    let App = {\n      setup(props) {\n        const state = reactive({\n          name: \"1\",\n        });\n        return {\n          state,\n        };\n        // 优先级高于外面的render函数\n        //  return () => {\n        //    return h('div', {\n        //      style: {\n        //        color: 'red'\n        //      }\n        //    }, 'hello world vue setup',state.name)\n        //  }\n      },\n      render(proxy) {\n        console.log(proxy,this,proxy===this,888);\n        console.log(proxy.state,proxy.state.name,8888);\n        const a = h(\n            \"div\",\n            {\n                style: {\n                    color: \"red\",\n                },\n            },\n            h(\"span\", {}, [ h(\"span\", {}, \"hello\"), \"test\" ] )\n        );\n        console.log(a, \"aaaa\");\n        return a;\n      },\n    };\n    createApp(App, {\n      test: 1,\n    }).mount(\"#app\");\n  </script>\n</html>\n```\n运行结果如下图:\n<img src=\"images/1.jpg\" width=\"80%\"/>\n\n- h函数: 用来创建虚拟节点\n- setup如果返回一个对象, 则会作为data属性使用;如果返回一个函数, 则会当成render函数使用,不会触发外层的render函数\n- render函数中的this以及参数proxy是一样的,都是组件实例对象(上下文)\n- createApp接收两个参数: 1.组件对象 2.组件的属性props, 返回一个对象,对象有一个方法mount,用来挂载组件\n\n下面我们通过渲染流程来讲解**createApp和h函数**\n\n## createApp\n`createApp(App, {test: 1,}).mount(\"#app\")`\ncreateApp主要做了以下几件事情:\n1. 定义渲染函数-render函数\n   - 里面就是定义了render方法即render里面执行了patch方法 `patch(null, vnode, container) // 1.旧的虚拟节点 2.新的虚拟节点 3.容器`,该方法主要是将虚拟节点渲染到真实dom上(通过一些js操作dom的方法)\n2. 定义了mount方法\n   - 获取dom节点: `container = nodeOps.querySelector(container)`\n   - 清空容器: `container.innerHTML = ''`\n   - 挂载\n     - 创建vnode: `let vnode=createVNode(rootComponent, rootProps)`\n     - 执行上面的render方法进行渲染: `render(vnode, container)`\n\n```js\nexport const createApp = (rootComponent, rootProps) => {\n    let app = createRender(rendererOptions)  // 不同平台的渲染器\n                    .createApp(rootComponent, rootProps)\n    let { mount } = app\n    app.mount = function (container) {\n        container = nodeOps.querySelector(container)\n        container.innerHTML = \"\" // 挂载前清空容器\n        mount(container) // 挂载 \n    }\n    return app\n}\nexport function createAppAPI(render) {\n    return function createApp(rootComponent, rootProps) {\n        let app = {\n            _component: rootComponent,\n            _props: rootProps,\n            _container: null,\n            mount(container) {\n                // 1.创建vnode\n                let vnode = createVNode(rootComponent, rootProps)\n                // 2.渲染\n                render(vnode, container)\n                // 保存容器\n                app._container = container\n            }\n        }\n        return app\n    }\n}\n```\n\n<img src=\"images/2.jpg\" width=\"80%\"/>\n\n## 创建组件vnode\n**执行 let vnode = createVNode(rootComponent, rootProps)**\n<img src=\"images/3.jpg\" width=\"80%\"/>\n\n- createVNode函数中判断type是对象,说明是组件,构造了一个vnode对象\n```js\nexport const createVNode = (type, props, children = []) => {\n    let shapeFlag = 0  // 标识是元素还是组件\n    if (isString(type)) { // 如果是字符串，那么就是元素\n        shapeFlag = ShapeFlags.ELEMENT\n    } else if (isObject(type)) { // 如果是对象，那么就是组件\n        shapeFlag = ShapeFlags.STATEFUL_COMPONENT\n    }\n    const vnode = {\n        __v_isVNode: true, // 标识是vnode\n        type,\n        props,\n        children,\n        key: props && props.key, // diff会用到\n        shapeFlag, // 标识是元素还是组件\n        el: null, // 挂载的dom节点\n        component: null, // 组件实例\n        render: null // 组件的render函数\n    }\n    // 儿子标识\n    normalizeChildren(vnode, children)\n    return vnode\n}\n// 儿子标识\nfunction normalizeChildren(vnode, children) {\n    let type = 0\n    if (children == null) { // 没有儿子\n        children = null\n    } else if (isString(children)) { // 文本节点\n        type = ShapeFlags.TEXT_CHILDREN\n    } else if (isArray(children)) { // 数组\n        type = ShapeFlags.ARRAY_CHILDREN\n    } else { // 插槽\n        type = ShapeFlags.SLOTS_CHILDREN\n    }\n    vnode.shapeFlag = vnode.shapeFlag | type\n}\n```\n## 执行createApp定义的render函数挂载组件\n**执行 render(vnode, container)**\n<img src=\"images/4.jpg\" width=\"80%\"/>\n\n### 判断节点类型是组件,进行组件挂载\n\n```js\n    // 渲染\n    let render = (vnode, container) => {\n        patch(null, vnode, container) // 1.旧的虚拟节点 2.新的虚拟节点 3.容器\n    }\n    const patch = (n1, n2, container) => {\n        // 针对不同类型的节点，做不同的处理 组件、元素、文本、注释\n        let { shapeFlag, type } = n2\n        switch (type) {\n            case Text:\n                processText(n1, n2, container)\n                break\n            default:\n                if (shapeFlag & ShapeFlags.ELEMENT) {  // 如果是元素\n                    // 元素挂载\n                    processElement(n1, n2, container)\n                } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) { // 如果是组件\n                    // 组件挂载\n                    processComponent(n1, n2, container)\n                }\n        }\n    }\n        // 组件挂载\n    const processComponent = (n1, n2, container) => {\n        if (n1 == null) {\n            // 初始化(第一次挂载)\n            console.log(\"判断n1是空: 就是初始化第一次挂载\",n1)\n            mountComponent(n2, container)\n        } else {\n            // 更新\n            console.log(\"判断n1不是空: 更新\",n1)\n\n        }\n    }\n    const mountComponent = (initialVNode, container) => {\n        // 1.先有一个组件的实例对象 \n        const instance = initialVNode.component = createComponentInstance(initialVNode)\n        //  2.解析数据到组件实例对象 \n        setupComponent(instance)\n        // 3.创建一个effect让render函数执行 \n        setupRenderEffect(instance, container)\n    }\n```\n\n\n#### 创建组件实例\n<img src=\"images/5.jpg\" width=\"80%\"/>\n\n#### 将vnode的属性值赋值到组件实例对象上\n<img src=\"images/6.jpg\" width=\"80%\"/>\n\n\n### 创建effect让render函数执行\n```js\n   const setupRenderEffect = (instance, container) => {\n        // 创建effect, 在effect中调用render函数,这样render函数中获取数据就会收集这个effect\n        effect(function componentEffect() {\n            if (!instance.isMounted) {\n                // 渲染组件\n                const proxy = instance.proxy\n                const subTree = instance.render.call(proxy, proxy)\n                patch(null, subTree, container) \n                instance.isMounted = true // 组件挂载完成\n            } else {\n                console.log('更新')\n            }\n        })\n    }\n```\n#### 执行render方法\n<img src=\"images/7.jpg\" width=\"80%\"/>\n\n\n#### 将render返回的vnode渲染到页面上\n<img src=\"images/8.jpg\" width=\"80%\"/>\n\n#### 修改标识位isMounted\n\n`instance.isMounted = true; // 组件挂载完成`\n\n## 总结\n\n流程比较长,需要对照着代码理解\n\n1. createApp()方法定义渲染函数-render函数\n2. 调用$mount()方法执行\n   - 获取dom节点: `container = nodeOps.querySelector(container)`\n   - 清空容器: `container.innerHTML = ''`\n   - 挂载\n     - 创建组件vnode: `let vnode=createVNode(rootComponent, rootProps)`\n     - 执行上面的render方法进行渲染: `render(vnode, container)`,render内部即`patch(null, vnode, container) // 1.旧的虚拟节点 2.新的虚拟节点 3.容器`\n3. 创建组件vnode\n   - 定义vnode结构,以及type标识shapeFlag是组件/元素字符串等\n   - 执行上面的render方法->patch函数->通过shapeFlag判断是组件执行组件挂载mountComponent\n4. 组件挂载mountComponent\n   - 创建组件实例. `createComponentInstance(上面的vnode)`\n   - 解析数据到组件实例对象: 将vnode的属性值赋值到组件实例对象上. \n     - 1.先将props、data、children赋值到实例上 \n     - 2.在instance上绑定proxy用于代理ctx上下文,当获取属性时候直接返回,如proxy.state.name即返回instance.ctx._.setupState[key] . `instance.proxy = new Proxy(instance.ctx, componentPublicInstance as any)`\n     - 3.判断setup返回值,如果是函数则赋值到instance.render,如果是对象就是data,否则instance绑定外层的render, 没有没有render且有template,编译template,也就是说render优先级>template\n   - 创建一个effect让instance.render函数执行 \n5. 创建一个effect让instance.render函数执行,使其响应式.此时的effect为渲染effect\n   - 判断instance.isMounted: 是否挂载完成. 第一次肯定为false,否则为更新\n   - 执行instance.render,并传入instance.proxy且this也指向instance.proxy\n      - render里面就是h函数,相当于调用createVNode创建vdom\n      - 对render返回的vdom进行patch操作,将vdom渲染到页面上(判断是元素、文本、组件等)\n   - 还原标志位 `instance.isMounted = true`; // 组件挂载完成\n  6. effect出栈\n  \n  ## h函数\nh函数就是createVNode函数, h函数内部就是调用了createVNode函数 [h函数](https://cn.vuejs.org/api/render-function.html#h)\n```js\n// 除了 type 外，其他参数都是可选的\nfunction h(type, props, children) {\n  ...\n  ...\n  return createVNode(type, props, children)\n}\n// 创建原生元素：\nh('div')\nh('div', { id: 'foo' })\n\n// attribute 和 property 都可以用于 prop\n// Vue 会自动选择正确的方式来分配它\nh('div', { class: 'bar', innerHTML: 'hello' })\n\n// class 与 style 可以像在模板中一样\n// 用数组或对象的形式书写\nh('div', { class: [foo, { bar }], style: { color: 'red' } })\n\n// 事件监听器应以 onXxx 的形式书写\nh('div', { onClick: () => {} })\n\n// children 可以是一个字符串\nh('div', { id: 'foo' }, 'hello')\n\n// 没有 prop 时可以省略不写\nh('div', 'hello')\nh('div', [h('span', 'hello')])\n\n// children 数组可以同时包含 vnode 和字符串\nh('div', ['hello', h('span', 'hello')])\n```\n\n```js\n创建组件：\n// 传递 prop\nh(Foo, {\n  // 等价于 some-prop=\"hello\"\n  someProp: 'hello',\n  // 等价于 @update=\"() => {}\"\n  onUpdate: () => {}\n})\n\n// 传递单个默认插槽\nh(Foo, () => 'default slot')\n\n// 传递具名插槽\n// 注意，需要使用 `null` 来避免\n// 插槽对象被当作是 prop\nh(MyComponent, null, {\n  default: () => 'default slot',\n  foo: () => h('div', 'foo'),\n  bar: () => [h('span', 'one'), h('span', 'two')]\n})\n```\n所以:\n- 第一个参数type: 组件或者原生标签\n- 第二个参数props: 属性、children、默认插槽\n- 第三个参数children: 子节点,可以为数组、字符串、具名插槽,数组中可以是h函数、字符串\n**createApp函数只能传前2个参数,type是组件,第二个参数是组件的属性**","categories":["vue3源码"]},{"title":"js操作(运算)符","url":"/ypf-blog/2024/06/03/javascript/js操作符/","content":"## 分类\n> 运算符(operator)也被称为操作符，是用于实现赋值、比较和执行计算数运算等 功能的符号\n- 算数运算符, 如+ - * / %\n- 比较运算符, 如== === != !== > < >= <=\n- 逻辑运算符, 如&& || !\n- 位运算符, 如& | ^ ~ << >>\n- 赋值运算符, 如= += -= *= /= %=\n\n## 位运算符\n[w3school](https://www.w3school.com.cn/js/js_bitwise.asp)\n>位操作符逻辑上可能要复杂一点因为我们习惯了使用十进制，而位操作符是**基于二进制**. 由于机器更容易理解二进制语言，所以使用二进制的目的是提高运算速度。  \n  - `内存占用减少`: 二进制占用空间比十进制小很多。因此相比于使用多个布尔变量或整数，它能够显著减少内存占用。\n  - `性能提升`: 位运算符比普通运算符快很多，因为位运算符是直接操作二进制，而普通运算符是先转换成二进制，然后再进行运算。\n1. 位与操作符：表示为 a&b，计算法则是先把a,b转换成二进制，对齐，然后对a,b的同一位置进行比较，比较规则是 **如果两位都是 1 则设置每位为 1**。\n    ```js\n    5 & 3; // 0101 & 0011 = 0001 ->1\n    ```\n2. 位或操作符：表示为a|b,计算法则是先把a,b转换成二进制，对齐，然后对a,b的同一位置进行比较，比较规则是 **如果两位之一为 1 则设置每位为 1**。\n    ```js\n    5 | 3 // 0101 | 0011 = 0111 ->7\n    ```\n3. 位非操作符：表示为 ~a 理解起来很简单就是转为二进制然后每一位这样操作如果是0换成1如果是1换成0，规则是 **反转所有位**。\n   ```js\n    ~5; // ~0101 = 1010 ->10\n   ```\n4. 异或操作符：表示为a^b, 计算法则是先把a,b转换成二进制，对齐，然后对a,b的同一位置进行比较，比较规则是 **如果两位只有一位为 1 则设置每位为 1**\n  ```js\n  5^3 // 0101 ^ 0011 = 0110 ->6\n  ```\n5. 零填充左位移(左移)操作符：表示为a<<b,计算法则是把a转换成二进制，然后把二进制**后面**加b个0 (通过从右推入零向左位移，并使最左边的位脱落)。 **一般左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方**。\n  ```js\n  1 << 3; // 0000 0000 0001 往左移动3位,结果为1000 -> 8 相当于 1*2^3=8\n  3 << 3  // 0000 0000 0011 往左移动3位,结果为11000 -> 24 相当于 3*2^3=24\n  ```\n6. 右移操作符：表示为a>>b，计算法则是把a转换成二进制，然后把二进制**前面**加b个0. **一般右移一位相当于除2，右移n位相当于除以2的n次方,取整**\n  ```js\n  8 >> 2; // 1000 往右移动2位,结果为0010->2 相当于8/2^2=2\n  100 >> 4; // 1100100 往右移动4位,结果为0000110,结果为2+4=6 相当于100/2^4=6\n  ```\n7. 零填充右位移操作符: 表示为a>>>b,即去除后面b位，然后往前面补0。规则是 **通过从左推入零来向右位移，并使最右边的位脱落。**\n  ```js\n  5 >>> 3; // 0101 >>> 3 = 0000 ->0\n  5 >>> 1; // 0101 >>> 1 = 0010 ->2\n  ```\n除了以上用法，位操作符还可以用来：\n\n- 两个数做交换：c=a^b, a=c^a, b=c^b.\n- 判断两个数是否相等：a^b=0则a=b。\n\n## 进制转换\n- 二进制->十进制：如1101，就是：1*2^0 + 0*2^1 + 1*2^2 + 1*2^3 = 13\n- 十进制->二进制：就是除2取余，然后倒序输出。比如 13/2 = 6, **余数是1**, 6/2 = 3, **余数是0**, 3/2 = 1, **余数是1**, 1/2 = 0, **余数是1**, 倒序输出就是 1101\n**注意: 任意非0的0次方都是1, 讨论0的0次方是无意义的。**\n\n```js\n// 十进制转二进制\n(13).toString(2) // 1101\n// 二进制转十进制, parseInt:解析参数,返回指定参数进制的十进制\nparseInt('1101',2) // 13\n// 字面量前缀 \nconsole.log(Ob1101) // 13\n```\n\n<img src=\"images/1.jpg\" width=\"80%\"/>\n\n> [JavaScript 中的位运算和权限设计](https://zhuanlan.zhihu.com/p/90618809)","categories":["javascript"]},{"title":"5.computed","url":"/ypf-blog/2024/05/31/vue3源码/5.computed/","content":"## 使用\n> computed是通过ComputedRefImpl类生成, 具有以下特点\n> 1.没有使用,不会执行\n> 2.具有缓存机制, 多次调用只执行一次\n> 3.具有依赖收集,当依赖的值发生变化时,才会重新执行\\\n> 4.要修改计算属性的值，相当于修改计算属性的依赖变量,set的参数就是传入的值\n### 函数\n```js\n    const { ref, computed } = window.Vue;\n    const age = ref(18);\n    const myAge = computed(() => {\n      console.log('缓存'); // 具有缓存(核心是_dirty属性),只执行一次\n      return age.value + 1;\n    });\n    console.log(myAge.value,myAge); // 19\n    setTimeout(() => {\n      console.log(myAge.value); // 19\n    }, 1000);\n```\n<img src=\"images/1.jpg\" width=\"80%\"/>\n\n上面例子可以看出:\n- 具有缓存机制, 多次调用只执行一次\n- 通过ComputedRefImpl类生成\n- 如果不调用, 是不会执行的\n\n### 对象\n```js\nconst myAge = computed({\n  get() {\n    console.log('缓存'); // 具有缓存(核心是_dirty属性),只执行一次\n    return age.value + 1;\n  },\n  set(val) {\n    console.log('set',val);\n    age.value = val;\n  }\n});\nconsole.log(myAge.value,myAge); \nsetTimeout(() => {\n  myAge.value = 100;\n  console.log(myAge.value); \n}, 1000);\n```\n<img src=\"images/2.jpg\" width=\"80%\"/>\n上面例子可以看出:\n\n- 要修改计算属性的值，相当于修改计算属性的依赖变量,set的参数就是传入的值\n\n## 实现\n### 定义computed函数\n```js\n// 新建packages/reactivity/src/computed.ts\nexport function computed(getterOrOptions) {\n    // 函数、对象\n    let getter; // 获取值\n    let setter; // 设置值\n    const onlyGetter = isFunction(getterOrOptions); // 是否只有getter\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter =\n            () => {\n                console.warn('Write operation failed: computed value is readonly');\n            }\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    // 创建一个计算属性\n    const cRef = new ComputedRefImpl(getter, setter);\n    return cRef;\n}\n\n```\n梳理下逻辑:\n- 定义getter、setter, 判断传过来的参数是否只有函数,是的话,setter函数**直接提示不能修改,只读**\n- 不是的的话,分别赋值为参数的get、set\n- 创建一个计算属性(生成实例)`cRef=new ComputedRefImpl(getter, setter)`\n\n### ComputedRefImpl类\n```js\nclass ComputedRefImpl {\n    public _dirty = true;\n    public _value;\n    public effect;\n    constructor(getter, private readonly setter) {\n        this.effect = effect(getter, {\n            lazy: true,\n            // 修改值时触发(trigger)\n            scheduler: () => {\n                if (!this._dirty) {\n                    this._dirty = true;\n                }\n            }\n        });\n    }\n    get value() {\n        if (this._dirty) {\n            this._value = this.effect();\n            this._dirty = false;\n        }\n        return this._value;\n    }\n    set value(newValue) {\n        this.setter(newValue);\n    }\n}\n```\n```js\n// 修改packages/reactivity/src/effect.ts\nexport function trigger(target, type, key, value?, oldValue?) {\n  ...\n  effectSet.forEach((effect: any) => {\n      // effect();\n      // 如果effect是scheduler,则执行scheduler,scheduler意思是调度,调度是什么意思?调度是指在合适的时机执行某个操作 \n      if (effect.options.scheduler) {\n          effect.options.scheduler(effect);\n      } else {\n          effect();\n      }\n  });\n}\n```\n梳理下逻辑:\n- _dirty表示是否重新计算值, true-执行 false-不执行, 默认为true\n- getter就是computed传过来的函数, 在类的constructor中初始化,传入effect中, lazy为true就是 **没有使用,不会执行**,scheduler用来修改数据时候重置标志位\n- 当获取computed的值时候, 触发get函数,第一次_dirty为true,就会执行,后面再次获取,因为_dirty为false,就不会执行\n- 当修改computed的值时候, 直接触发传过来的setter函数,里面是修改依赖项的值,触发trigger, 判断是computed的effect(即effect.options.scheduler存在),执行就修改了标志位_dirty=true,当我们再次获取computed的值时候,触发get函数,_dirty为true,就会执行\n\n## 总结\n我们再结合effect和例子完整梳理一下流程\n```js\nconst age = ref(18);\nconst myAge = computed(() => {\n  return age.value + 1;\n});\nconsole.log(myAge.value)\n```\n\n1. `const myAge=computed(...)`定义了一个computed-->判断是否是函数,通过getter、setter存储参数--> `new ComputedRefImpl(getter, setter)生成实例`-->`constructor`执行了\n  ```js\n   this.effect = effect(getter, {\n            lazy: true,\n            // 修改值时触发(trigger)\n            scheduler: () => {\n                if (!this._dirty) {\n                    this._dirty = true;\n                }\n            }\n        });\n  ```\n2. 调用了effect函数\n  ```js\n  export function effect(fn, options: any = {}) {\n    if (fn.effect) {\n        fn = fn.effect;\n    }\n    // 创建响应式effect\n    const effect = createReactiveEffect(fn, options);\n    if (!options.lazy) {\n        console.log('不是lazy,直接初始化执行effect()')\n        effect(); // 默认执行一次\n    }\n    return effect;\n  }\n  ```\n3. 触发了createReactiveEffect生成了effect\n   ```js\n    function createReactiveEffect(fn, options) {\n      const effect = function reactiveEffect() {\n          // window.console.groupInfo('定义effect函数')\n          try {\n              console.log('1-1.判断是否在effectStack中')\n              if (!effectStack.includes(effect)) {\n                  console.log('1-2.不存在,定义effect函数入栈effectStack')\n                  effectStack.push(effect); // 入栈\n                  console.log('1-3.activeEffect保存当前活动的effect')\n                  activeEffect = effect; // 保存当前活动的effect\n                  console.log('1-4.执行effect传入的fn')\n                  return fn(); // 执行用户传入的函数\n              }\n          } finally { // 为什么要try...finally?因为try执行完毕后,无论是否有错误,都要执行finally进行出栈\n              console.log('1-4.执行完毕,出栈effectStack')\n              effectStack.pop(); // 出栈\n              console.log('1-5.activeEffect重新赋值为effectStack[effectStack.length - 1]')\n              activeEffect = effectStack[effectStack.length - 1]; // 当前活动的effect\n          }\n      };\n      effect.id = uid++; // effect的唯一标识\n      effect._isEffect = true; // 标识effect是不是响应式effect\n      effect.raw = fn; // 保存用户传入的函数\n      // effect.deps = []; // 保存effect的依赖\n      effect.options = options; // 保存effect的配置\n      return effect;\n  }\n   ```\n4. 此时this.effect就是**createReactiveEffect函数**\n5. 调用`myAge.value`触发get函数--> 把标志位_dirty变为false且`this._value = this.effect()`-->执行了createReactiveEffect函数. 此时activeEffect就是computed传过来的getter, 然后进行第一次执行\n  ```js\n  get value() {\n          if (this._dirty) {\n              this._value = this.effect();\n              this._dirty = false;\n          }\n          return this._value;\n      }\n  ```\n5. 触发computed里面依赖的state即demo的age, 走到track收集,这样age就存下来一个computed的effect(即有effect.options.scheduler)\n```js\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        const res = Reflect.get(target, key, receiver)\n        if (!isReadonly) {\n            // 如果不是只读的，就收集依赖 effect\n            window.console.groupInfo(`调用state.${key}触发get收集effect`, target, key)\n            track(target, TrackOpTypes.GET, key)\n            window.console.groupInfoEnd()\n        }\n        if (shallow) {\n            // 如果是浅层的，就返回结果\n            return res\n        }\n        // 是对象，递归代理\n        // 懒代理递归，即当取值的时候才会递归代理,性能优化\n        if (isObject(res)) {\n            return isReadonly ? readonly(res) : reactive(res)\n        }\n        return res\n    }\n}\n\nexport function track(target, type, key) {\n    // 如果当前没有活动的effect，则不需要收集依赖\n    if (activeEffect === undefined) {\n        return;\n    }\n    // console.log(activeEffect.id, 'activeEffect.id');\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n        targetMap.set(target, (depsMap = new Map()));\n    }\n    console.log(targetMap, 'targetMap');\n    let dep = depsMap.get(key); //{key:set[]}\n    if (!dep) {\n        depsMap.set(key, (dep = new Set()));\n    }\n    if (!dep.has(activeEffect)) {\n        dep.add(activeEffect); // 收集依赖\n        // activeEffect.deps.push(dep);\n    }\n}\n```\n\n5. 修改值的时候,触发了set,就执行了传过来的set函数, 里面执行了 **依赖的属性** 修改语句就触发了trigger\n```js\n set value(newValue) {\n    this.setter(newValue);\n}\n```\n6. trigger执行属性对应的effect数组, 判断effect如果是computed(即effect.options.scheduler调度),执行把标志位_dirty变为true,当再次获取的时候,触发get,因为为true又可以执行了.\n```js\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        // 触发更新\n        // 注意:1.是数组还是对象 2.是新增还是修改\n        const oldValue = target[key] // 获取老值\n        console.log(isArray(target) ,isIntegerKey(key),key,typeof key,'key')\n        const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key) // 判断是否有这个属性\n        const result = Reflect.set(target, key, value, receiver)\n        window.console.groupInfo('set')\n        if (!hadKey) {\n            // 新增\n            console.log('判断是新增属性')\n            trigger(target, TriggerOpTypes.ADD, key, value)\n        } else if (hasChanged(value, oldValue)) { // 判断新值和老值是否有变化,如果有变化就触发更新,如果没有变化就不触发更新\n            // 修改\n            console.log('判断是修改属性且值有变化',key,value)\n            trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n        }\n        window.console.groupInfoEnd()\n        return result\n    }\n}\nexport function trigger(target, type, key, value?, oldValue?) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) { // 比如直接修改值state.xx=1, xx不存在,此时target是{name,list,xx},肯定不存在\n        return;\n    }\n    let effectSet1 = depsMap.get(key); // set[effect,effect]\n    let effectSet = new Set(); // 重复的effect只执行一次,去重\n    let add = (effectsToAdd) => {\n        if (effectsToAdd) {\n            effectsToAdd.forEach(effect => {\n                effectSet.add(effect);\n            });\n        }\n    }\n    // console.log(effectSet, 'effectSet');\n    // 数组修改长度需要特殊处理 例如:arr[1] = 3,arr.length = 1,此时arr[1]应该为undefined\n    if (isArray(target) && key === 'length') {\n        depsMap.forEach((dep, key) => {\n            console.log(dep, key, 'dep,key')\n            // 如果更改的length小于收集的索引,那么这个索引要重新执行effect\n            if (key === 'length' || value<=key) {\n                add(dep);\n            }\n        });\n    } else {\n        // 对象\n        if (key !== undefined) {\n            add(depsMap.get(key));\n        }\n        switch (type) {\n            case TriggerOpTypes.ADD:\n                // 数组新增>长度的索引,也要重新执行effect,使的已经使用list.length的地方更新\n                if (isArray(target) && isIntegerKey(key)) {\n                    console.log(depsMap.get('length'), \"depsMap.get('length')\")\n                    add(depsMap.get('length'));\n                } // 添加属性\n                break;\n\n\n        }\n    }\n    effectSet.forEach((effect: any) => {\n        // effect();\n        // 如果effect是scheduler,则执行scheduler,scheduler意思是调度,调度是什么意思?调度是指在合适的时机执行某个操作 \n        if (effect.options.scheduler) {\n            effect.options.scheduler();\n        } else {\n            effect();\n        }\n    });\n}\n```\n\n## 简单描述\n- computed就是创建一个effect,存到this上,执行this.effect相当于执行了核心effect函数就相当于执行了createReactiveEffect函数,里面执行当前活动activeEffect=computed的getter,且用_value存值\n- 当执行里面**获取属性语句**,就触发track收集该activeEffect.且有个_dirty属性第一次为true,后面为false阻止再次执行,取_value缓存\n- 修改值就触发set,里面执行**修改属性语句**,触发trigger执行了对应属性收集的effect数组,循环执行数组,判断effect如果有scheduler调度属性,就是computed,执行,把_dirty变为true, 这样下次获取值触发get就直接又可以执行了this.effect","categories":["vue3源码"]},{"title":"4.ref和toRef","url":"/ypf-blog/2024/05/29/vue3源码/4.ref和toRef/","content":"# ref\n## 基本使用\n> ref就是将普通的数据转换为响应式数据,返回一个对象,对象中有一个value属性,这个value就是值\n> ref允许我们创建一个任意类型的响应式的ref对象，在使用时需要带上.value ,reactive只能接收对象或数组等复杂类型\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.js\"></script>\n  <script>\n    const { ref, reactive, toRaw, effect } = window.Vue;\n    let name = ref(\"John\"); \n    console.log(name);\n    console.log(name.value);\n  </script>\n</html>\n```\n<img src=\"images/1.jpg\" width=\"80%\"/>\n我们打印可以看到, ref生成的是一个实例对象,通过RefImpl来生成\n\n## 实现\n### 类的基本定义\n```js\n// 新建packages/reactivity/src/ref.ts\nimport { hasChanged, isArray } from '@vue/shared'\n\nexport function ref(target) {\n    return createRef(target)\n}\nexport function shallowRef(target) {\n    return createRef(target, true)\n}\nfunction createRef(rawValue, shallow = false) {\n    return new RefImpl(rawValue, shallow)\n}\nclass RefImpl {\n    public __v_isRef = true // 用于标识是一个ref对象\n    public _value // 存储值\n    public _rawValue // 存储原始值\n    constructor(value, public readonly __v_isShallow) {\n        this._rawValue = __v_isShallow ? value : toRaw(value)\n        this._value = __v_isShallow ? value : toReactive(value)\n    }\n    get value() {\n        track(this, TrackOpTypes.GET, 'value')\n        return this._value\n    }\n    set value(newValue) {\n        if (hasChanged(newValue, this._value)) {\n            this._value = this.__v_isShallow?newValue:toReactive(newValue)\n            this._rawValue = this.__v_isShallow?newValue:toRaw(newValue)\n            trigger(this, TriggerOpTypes.SET, 'value', newValue)\n        }\n    }\n}\n```\n我们梳理下上面代码步骤:\n1. ref是通过createRef来创建的, createRef执行了 `new RefImpl`\n2. RefImpl类接收2个参数(值,是否是浅代理),对外暴露出\n   _rawValue: 原始值\n   _value: 新值\n   __v_isRef: 标识符,用于标识是一个ref对象\n   __v_isShallow: 是否是浅代理,默认false即深层\n3. 逻辑很简单,就是get时候,返回`this._value`, set时候,判断如果已经修改值,就是更新`this._value = newValue;this._rawValue = newValue`,是否浅代理下面讲\n   \n但是上面我们可以测试下,在effect里面使用`xx.value`, 然后修改值,发现不会响应.\n\n### 响应式\n还是看上面代码,很明显,我们在get的时候,进行`track`,在set时候,进行`trigger`, **传递的对象就是this,指向实例,因为我们用就是实例.value**, 这样就完成了响应式\n### ref只能传基本类型?\n一般我们ref是用来绑定基础类型的,reactivity是用来绑定数组、对象等复杂数据类型的. 但实际上,ref是支持对象、数组等任意类型的.\n我们看上面代码:\n```js\n constructor(value, public readonly __v_isShallow) {\n      this._rawValue = __v_isShallow ? value : toRaw(value)\n      this._value = __v_isShallow ? value : toReactive(value)\n }\n```\n- 对于原始值(即没被代理的对象),如果是浅层的,直接绑定value, 如果是深层的, 执行toRaw进行转换原始值\n```js\n// toRaw是根据一个 Vue 创建的代理返回其原始对象(可以返回由 reactive()、readonly()、shallowReactive() 或者 shallowReadonly() 创建的代理对应的原始对象)\nconst foo = {}\nconst reactiveFoo = reactive(foo)\nconsole.log(toRaw(reactiveFoo) === foo) // true\nconsole.log(reactiveFoo.__v_raw === foo) // true\n```\n\n- 对象新值,如果是浅层的,直接绑定value,如果是深层的,执行toReactive进行代理\n我们前面讲过toReactive方法\n```js\nexport function toReactive(value) {\n    return isObject(value) ? reactive(value) : value\n}\n```\n我们看\n**demo1**\n```js\n    let obj=ref({name:'John',age:18})\n    console.log(obj,obj.value);\n```\n<img src=\"images/2.jpg\" width=\"80%\"/>\n我们看到,obj.value此时是个proxy\n\n**demo2**\n```js\n    let obj=ref({name:'John',age:18})\n    effect(()=>{\n      console.log(obj.value) // 不收集\n      console.log(obj.value.name) // 收集\n    })\n    setTimeout(() => {\n        obj.value.name='Tom'\n    }, 1000);\n```\n修改name值后, effect不会响应,因为effect中并没有使用name进行收集\n\n**demo3**\n```js\n    let obj=ref({name:'John',age:18})\n    effect(()=>{\n      console.log(obj.value) // 收集\n    })\n    setTimeout(() => {\n        obj.value={name:'Tom',age:18}\n    }, 1000);\n```\n直接修改value,effect会响应,此时新值就是一个proxy,上面我们set已经进行toReactive处理\n\n## 总结\n- ref就是通过`new RefImpl`生成的,暴露value, 会判断是否浅代理, 进行toReactive\n- 在get进行收集,set进行响应, 绑定的是this实例\n- 可以接受任意类型\n\n# toRef\n## 基本使用\n> toRef是将目标对象的指定属性转换为ref对象,如果目标对象是响应式的,ref对象会保持响应式,反之不是响应式, 一般我们使用都是响应式对象\n\n```js\n  const { toRef,reactive,effect } = window.Vue;\n  let state = {\n    name: \"John\",\n    age: 18,\n  };\n  let name = toRef(state, \"name\"); \n  console.log(name, name.value); // 不是响应式,如果用effect,修改数据不会重新执行\n```\n<img src=\"images/3.jpg\" width=\"80%\"/>\n\n```js\n  const { toRef,reactive,effect } = window.Vue;\n  let state = reactive({\n    name: \"John\",\n    age: 18,\n  });\n  let name = toRef(state, \"name\"); \n  console.log(name, name.value); // 是响应式,如果用effect,修改数据会重新执行\n```\n<img src=\"images/4.jpg\" width=\"80%\"/>\n\n```js\n  const { toRef,reactive,effect } = window.Vue;\n  let state = \"John;\n  let name = toRef(state); \n  console.log(name, name.value); //是响应式,因为是ref类创建的,如果用effect,修改数据不会重新执行\n```\n<img src=\"images/5.jpg\" width=\"80%\"/>\n\n上面3个例子我们可以看出\n1. 如果目标已经是ref,就直接返回\n2. 如果目标是对象, 则通过ObjectRefImpl类创建, 如果是响应式的,ref对象会保持响应式(即effect重新执行),反之不是响应式(即不会重新执行effect), 一般我们使用都是响应式对象\n3. 如果目标是基本类型,直接返回`ref(目标)`\n\n## 实现\n```js\nexport function isRef(r) {\n    return !!(r && r.__v_isRef === true)\n}\nexport function toRef(target, key) {\n    if (isRef(target)) {\n        return target\n    } else if (isObject(target) && arguments.length > 1) {\n        return isRef(target[key]) ? target[key] : new ObjectRefImpl(target, key)\n    } else {\n        return ref(target)\n    }\n}\nclass ObjectRefImpl {\n    public __v_isRef = true\n    constructor(private readonly _object, private readonly _key) {\n    }\n    get value() {\n        return this._object[this._key]\n    }\n    set value(newValue) {\n        this._object[this._key] = newValue\n    }\n}\n```\n上面逻辑很简单:\n1. 先判断如果是ref就直接返回\n2. 如果是对象,如果值是ref就直接返回,否则通过`new ObjectRefImpl`创建\n3. 其他情况,直接返回`ref(target)`\n4. `ObjectRefImpl类`逻辑很简单,get从对象取值,set更新新值\n\n# toRefs\n## 使用\n> toRef是将目标对象的所有属性转换为ref对象,如果目标对象是响应式的,ref对象会保持响应式,反之不是响应式, 一般我们使用都是响应式对象\n```js\n  const { toRefs,reactive,effect } = window.Vue;\n  let state = {\n    name: \"John\",\n    age: 18,\n  };\n  let obj = toRefs(state);  \n  console.log(obj,obj.name); \n  // 或者解构\n  const {name,age}=toRefs(state);  \n  console.log(name,name.value); \n```\n<img src=\"images/6.jpg\" width=\"80%\"/>\n\n上面我们可以看到\n- 目标对象的每个属性都会转换为ref对象\n- 传入的不是响应式对象,会⚠️警告让传入响应式对象\n\n## 解构无法响应?\n\n```js\n const { toRefs,reactive,effect } = window.Vue;\n  let state = reactive({\n    name: \"John\",\n    age: 18,\n  });\n  console.log(state.name) // 响应式对象proxy\n  const {name,age}=state\n  console.log(name,age) // John 18\n```\n我们使用reactive时候不想每次都用`state.xx`这样,所以如果想上面解构,直接就是个值,肯定是不对的.我们修改下\n```js\n const { toRefs,reactive,effect } = window.Vue;\n  let state = reactive({\n    name: \"John\",\n    age: 18,\n  });\n  const {name,age}=toRefs(state)\n  console.log(name,age) // ref响应式\n```\n上面我们通过toRefs转换,就没有问题了\n\n## 实现\n```js\nexport function toRefs(object) {\n    const ret = isArray(object) ? new Array(object.length) : {}\n    for (const key in object) {\n        ret[key] = isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key)\n    }\n    return ret\n}\n```\n上面逻辑很简单:\n1. 创建一个空对象, 长度就是目标对象的长度,如果是数组就是数组的length\n2. 遍历对象,判断如果是ref就直接放到空对象中,如果不是,通过`new ObjectRefImpl`创建后放到空对象中\n3. 最后返回对象\n","categories":["vue3源码"]},{"title":"3.effect","url":"/ypf-blog/2024/05/22/vue3源码/3.effect/","content":"## 基本使用\n我们先学习下effect的基本使用，我们先看下源码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body><div id=\"app\"></body>\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.js\"></script>\n  <script>\n    const { effect } = window.VueReactivity;\n    const state = reactive({\n      name: \"John\",\n      list : [1,2,3]\n    });\n    effect(\n      () => {\n        app.innerHTML = state.name;\n      }, \n      {\n        // lazy: true, // 默认为false,自动执行, lazy为true时,只有在effect被调用时才会执行effect\n      }\n    )\n  </script>\n</html>\n```\n运行上面代码, 会发现页面上显示John\n- effect用于收集依赖, 当依赖发生变化时, 会执行effect中的回调函数,解释下, 我们执行effect,执行到`state.name`就会触发get就会收集effect依赖, 当state发生变化时, 会执行effect中的回调函数\n- lazy默认为false, 自动执行, lazy为true时, 只有在effect被调用时才会执行effect\n\n## 实现原理\n\n### 定义effect函数\n```js\n// 新建packages/reactivity/src/effect.ts\nimport { isIntegerKey, isArray } from '@vue/shared';\nimport { TriggerOpTypes } from './constants';\nexport function effect(fn, options: any = {}) {\n    if (fn.effect) {\n        fn = fn.effect;\n    }\n    // 创建响应式effect\n    window.console.log('1.定义effect函数')\n    const effect = createReactiveEffect(fn, options);\n    // window.console.groupInfoEnd()\n    if (!options.lazy) {\n        console.log('不是lazy,直接初始化执行effect()')\n        effect(); // 默认执行一次\n    }\n    return effect;\n}\nlet uid = 0;\nlet activeEffect; // 当前活动的effect\nlet effectStack = []; // effect栈,用于解决递归调用的问题,\nfunction createReactiveEffect(fn, options) {\n    const effect = function reactiveEffect() {\n        try {\n            console.log('1-1.判断是否在effectStack中')\n            if (!effectStack.includes(effect)) {\n                console.log('1-2.不存在,定义effect函数入栈effectStack')\n                effectStack.push(effect); // 入栈\n                console.log('1-3.activeEffect保存当前活动的effect')\n                activeEffect = effect; // 保存当前活动的effect\n                console.log('1-4.执行effect传入的fn')\n                return fn(); // 执行用户传入的函数\n            }\n        } finally { // 为什么要try...finally?因为try执行完毕后,无论是否有错误,都要执行finally进行出栈\n            console.log('1-4.执行完毕,出栈effectStack')\n            effectStack.pop(); // 出栈\n            console.log('1-5.activeEffect重新赋值为effectStack[effectStack.length - 1]')\n            activeEffect = effectStack[effectStack.length - 1]; // 当前活动的effect\n        }\n    };\n    effect.id = uid++; // effect的唯一标识\n    effect._isEffect = true; // 标识effect是不是响应式effect\n    effect.raw = fn; // 保存用户传入的函数\n    effect.options = options; // 保存effect的配置\n    return effect;\n}\n```\n上面代码流程解析\n1. 定义effect函数外层, 里面调用生成effect的createReactiveEffect函数(将fn,options参数传过去),判断是否懒加载,不是就执行一次\n2. createReactiveEffect函数主要是定义effect函数, 同时给函数绑定唯一的id,_isEffect标识effect是不是响应式effect,raw保存用户传入的函数,options保存effect的配置, 然后return出去\n3. effect函数执行时,会执行里面的逻辑, 首先判断是否在effectStack中, 如果不在, 就将effect入栈, 并将activeEffect保存当前活动的effect, 然后执行effect传入的fn, 执行完毕finally后, 出栈effectStack, 并将activeEffect重新赋值为effectStack[effectStack.length - 1]\n\n**为什么要使用effectStack保存effect?**\n我们看下下面代码\n```js\neffect(() => {\n  state.name // effect1\n  effect(() => {\n    state.name // effect2\n  })\n  state.name // effect1\n})\n```\n我们执行上面代码,\n- 执行state.name, 会给name绑定一个依赖effect1\n- 执行effect(() => {})里面的state.name, 会给name绑定一个依赖effect2\n- 执行state.name, 此时仍是绑定effect1\n所以需要存起来effectStack, 用于解决递归调用的问题, effectStack[effectStack.length - 1]就是当前活动的effect.\n\n## 收集依赖\n\n```js\n// 修改packages/reactivity/src/baseHandlers.ts\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        const res = Reflect.get(target, key, receiver)\n        if (!isReadonly) {\n            // 如果不是只读的，就收集依赖 effect\n            window.console.groupInfo(`调用state.${key}触发get收集effect`, target, key)\n            track(target, TrackOpTypes.GET, key)\n            window.console.groupInfoEnd()\n        }\n        if (shallow) {\n            // 如果是浅层的，就返回结果\n            return res\n        }\n        ...\n```\n```js\n// packages/reactivity/src/effect.ts\nlet targetMap = new WeakMap(); // 依赖存储  WeakMap{target:Map{key:set[effect,effect]}}\nexport function track(target, type, key) {\n    // 如果当前没有活动的effect，则不需要收集依赖\n    if (activeEffect === undefined) {\n        return;\n    }\n    // console.log(activeEffect.id, 'activeEffect.id');\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n        targetMap.set(target, (depsMap = new Map()));\n    }\n    console.log(targetMap, 'targetMap');\n    let dep = depsMap.get(key); //{key:set[]}\n    if (!dep) {\n        depsMap.set(key, (dep = new Set()));\n    }\n    if (!dep.has(activeEffect)) {\n        dep.add(activeEffect); // 收集依赖\n        // activeEffect.deps.push(dep);\n    }\n}\n```\n- 当我们获取data上的某个key时候,就会往targetMap存储依赖, 格式为 `WeakMap{target:Map{key:set[effect,effect]}}`\n- activeEffect就是当前活动的effect\n- effect会通过set去重\n\n### 对象\n如`state.name`\n<img src=\"images/1.jpg\" width=\"80%\"/>\n\n### 数组\n如`state.list[0]`\n<img src=\"images/2.jpg\" width=\"80%\"/>\n\n## 触发依赖\n```js\n// 修改packages/reactivity/src/baseHandlers.ts\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        // 触发更新\n        // 注意:1.是数组还是对象 2.是新增还是修改\n        const oldValue = target[key] // 获取老值\n        const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key) // 判断是否有这个属性\n        const result = Reflect.set(target, key, value, receiver)\n        window.console.groupInfo('set')\n        if (!hadKey) {\n            // 新增\n            console.log('判断是新增属性')\n            trigger(target, TriggerOpTypes.ADD, key, value)\n        } else if (hasChanged(value, oldValue)) { // 判断新值和老值是否有变化,如果有变化就触发更新,如果没有变化就不触发更新\n            // 修改\n            console.log('判断是修改属性且值有变化',key,value)\n            trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n        }\n        window.console.groupInfoEnd()\n        return result\n    }\n}\n```\n```js\n// packages/reactivity/src/effect.ts\n// 触发更新\nexport function trigger(target, type, key, value?, oldValue?) {\n    console.log(target, 'target12221')\n    const depsMap = targetMap.get(target);\n    if (!depsMap) { // 比如直接修改值state.xx=1, xx不存在\n        return;\n    }\n    // let effectSet1 = depsMap.get(key); // set[effect,effect]\n    let effectSet = new Set(); // 重复的effect只执行一次,去重\n    let add = (effectsToAdd) => {\n        if (effectsToAdd) {\n            effectsToAdd.forEach(effect => {\n                effectSet.add(effect);\n            });\n        }\n    }\n    // console.log(effectSet, 'effectSet');\n    // 数组修改长度需要特殊处理 例如:arr[1] = 3,arr.length = 1,此时用到arr[1]的地方应该更新为undefined\n    if (isArray(target) && key === 'length') {\n        depsMap.forEach((dep, key) => {\n            console.log(dep, key, 'dep,key')\n            // 如果更改的length小于收集的索引,那么这个索引要重新执行effect\n            if (key === 'length' || value<=key) {\n                add(dep);\n            }\n        });\n    } else {\n        // 对象\n        if (key !== undefined) {\n            add(depsMap.get(key));\n        }\n        switch (type) {\n            case TriggerOpTypes.ADD:\n                // 数组新增>长度的索引,也要重新执行effect,使的已经使用list.length的地方更新\n                if (isArray(target) && isIntegerKey(key)) {\n                    console.log(depsMap.get('length'), \"depsMap.get('length')\")\n                    add(depsMap.get('length'));\n                } // 添加属性\n                break;\n        }\n    }\n    console.log(effectSet, 'effectSet')\n    // console.log(effectSet1, 'effectSet1')\n    effectSet.forEach((effect: any) => {\n        effect();\n    });\n}\n```\n### 核心主流程\n**主要核心是: 根据key,找到缓存中收集的effect,然后循环执行**\n```js\nconst depsMap = targetMap.get(target);\nif (!depsMap) { // 比如直接修改值state.xx=1, xx不存在,此时target是{name,list,xx},缓存中肯定不存在\n    return;\n}\nlet effectSet = depsMap.get(key); // set[effect,effect] \neffectSet.forEach((effect: any) => {\n    effect();\n});\n```\n上面代码因为存在修改时,存在相同的effect,所以通过set去重, 因为对象数组有下面特殊情况,所以需要获取effect,通过add函数添加到effectSet中\n```js\n let effectSet = new Set(); // 重复的effect只执行一次,去重\n    let add = (effectsToAdd) => {\n        if (effectsToAdd) {\n            effectsToAdd.forEach(effect => {\n                effectSet.add(effect);\n            });\n        }\n    }\n```\n### 对象\n对象很简单,直接 \n```js\nif (key !== undefined) {\n    add(depsMap.get(key));\n}\n```\n### 数组\n数组存在两种特殊情况需要特殊处理\n#### 修改length,已使用state.list[index],需要响应\n```js\nconst state = reactive({\n  name: 1,\n  list: [1, 2, 3],\n});\neffect(()=>{\n  console.log(state.list[1]) // 第一次是2, 第二次是undefined\n})\nsetTimeout(()=>{\n  state.list.length = 1 // 修改length, 此时应该重新执行effect, 并且输出undefined\n},1000)\n```\n`所以通过下面逻辑判断,更新的length<=索引,即长度<=索引>,那么这个索引要重新执行effect`\n```js\nif (isArray(target) && key === 'length') {\n    depsMap.forEach((dep, key) => {\n        console.log(dep, key, 'dep,key')\n        // 如果更改的length小于收集的索引,那么这个索引要重新执行effect\n        if (key === 'length' || key >= value) {\n            add(dep);\n        }\n    });\n}\n```\n#### 数组增加索引,已使用state.list.length,需要响应\n```js\neffect(()=>{\n  app.innerHTML = state.list.length // 第一次是3, 第二次是6\n})\nsetTimeout(()=>{\n  state.list[5]=5 // 修改数组, 此时应该重新执行effect,并且输出6, 数组是[1,2,3,empty,empty,5],此时获取list[3]是undefined\n},1000)\n```\n`通过下面的逻辑判断,数组新增index(数组的index>=length),用到length的地方重新执行effect`\n```js\nswitch (type) {\n  case TriggerOpTypes.ADD:\n      // 数组新增index>=长度,也要重新执行effect,使的已经使用list.length的地方更新\n      if (isArray(target) && isIntegerKey(key)) {\n          console.log(depsMap.get('length'), \"depsMap.get('length')\")\n          add(depsMap.get('length'));\n      } // 添加属性\n      break;\n}\n```\n","categories":["vue3源码"]},{"title":"傻傻分不清楚- ==和===和Object.is","url":"/ypf-blog/2024/05/06/javascript/傻傻分不清楚- ==和===和Object.is/","content":"## \n  ","categories":["javascript"]},{"title":"Map,WeakMap,Set,WeakSet","url":"/ypf-blog/2024/05/06/javascript/Map,WeakMap,Set,WeakSet/","content":"## Map\n> 由于js对象的键只能是字符串,如果硬要对象作键, 键会变成`'[object Object]'`, 这给使用带来了很大的限制,所以es6新增Map, **任意类型都可以当键**\n```js\nconst a = {\n  test: 1,\n};\nconst b = {\n  test: 2,\n};\nvar obj = {\n  [a]: 1,\n  [b]: 2,\n};\nconsole.log(obj.a); // undefined\nconsole.log(obj); // { '[object Object]': 2 } // 覆盖为2\n```\n### 使用\n```js\nconst map= new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n或者\nconst map= new Map()\nmap.set(\"a\", 1).set(\"b\", 2).set(\"c\", 3)\nconsole.log(map)\n```\n<img src=\"images/1.jpg\" width=\"50%\"/>\n\n### 不同类型值\n\n键如果严格相等,则会视为一个键.特殊的除外\n```js\nconst obj1 = {},\n      obj2 = {},\n      obj3 = obj2;\nconst arr1 = [],\n      arr2 = [];\nconsole.log(0 === -0, \"0 === -0\"); // true\nconsole.log(NaN === NaN, \"NaN === NaN\"); // false\nconsole.log(obj1 === obj2, \"obj1 === obj2\"); // false\nconsole.log(obj3 === obj2, \"obj3 === obj2\"); // true\nconsole.log(arr1 === arr2, \"arr1 === arr2\"); // false\nconsole.log(null === null, \"null === null\"); // true\nconsole.log(undefined === undefined, \"undefined === undefined\"); // true\nconsole.log(null === undefined, \"null===undefined\"); // false\n\nconst map = new Map([\n  [+0, 1],\n  [-0, 2],\n  [\"0\", 3],\n  [NaN, 1],\n  [NaN, 2],\n  [obj1, 1],\n  [obj2, 2],\n  [obj3, 3],\n  [arr1, 1],\n  [arr2, 2],\n  [null, 1],\n  [null, 2],\n  [undefined, 1],\n  [undefined, 2],\n]);\n```\n<img src=\"images/2.jpg\" width=\"50%\"/>\n\n我们可以看出,如果 === 为true,那么就是对应同一个键,会被覆盖,\n-  特殊的就 `NaN: ===为false,但是当成一个键`\n-  对象、数组不是同一个,只有指向同一个指针的时候,才是同一个.\n\n### 方法\n我们打印下原型上的方法`console.log(Map.prototype)`, 可以看到里面无非就是 `增删改查、size、遍历`方法\n<img src=\"images/3.jpg\" width=\"70%\"/>\n我们测试下各个方法的返回值\n```js\n  console.log(map.get(NaN)); // 2\n  console.log(map.get(0),map.get(- 0)); // 2 2\n  console.log(map.has(NaN)); // true\n  console.log(map.has(0),map.has(-0)); // true true\n  console.log(map.size); // 9\n  console.log(map.delete(NaN)); // true\n  console.log(map.clear()); // undefined,无返回值\n  console.log(map.size); // 0\n```\n\n### 遍历\n```js\nconst map = new Map([\n  [\"a\", 1],\n  [\"b\", 2],\n  [\"c\", 3],\n]);\nconsole.log(\"----for of----\");\nfor (let item of map) {\n  // 等同于map1.entries()\n  console.log(item);\n}\n\nconsole.log(\"----map.keys()----\");\nfor (let item of map.keys()) {\n  console.log(item);\n}\n\nconsole.log(\"----map.values()----\");\nfor (let item of map.values()) {\n  console.log(item);\n}\n\nconsole.log(\"----map.entries()----\");\nfor (let item of map.entries()) {\n  console.log(item);\n}\n```\n- 上面我们可以看出`for of 和 map.entries`是一样的效果\n\n### 转换\n```js\n// 数组->map\nfunction arrayToMap(array) {\n  return new Map(array); // Map(3) { 'a' => 1, 'b' => 2, 'c' => 3 }\n}\n// map->数组\nfunction mapToArray(map) {\n  return [...map]; // [['a', 1], ['b', 2], ['c', 3]]\n}\n```\n\n## WeakMap\n- 主要特点是,键只能是对象如对象、数组、函数(null除外)和symbol,不能是基本类型,打印结果和map格式一样\n- 键是弱引用,不计入垃圾回收机制, 但值仍是强引用,计入垃圾回收\n- 只有增删改查,没有遍历、size, 因为是弱引用,不知道浏览器什么时候回收,所以也就不可能存在遍历,size\n  \n### 使用\n```js\nconst weakMap = new WeakMap([\n  [{ a: 1 }, 1],\n  [[], 2],\n  [() => {}, 2],\n]);\nconsole.log(weakMap);\nweakMap.set(1, 2); // TypeError: Invalid value used as weak map key\n```\n### 方法\n我们打印下原型上的方法`console.log(WeakMap.prototype)`,可以看到没有遍历,只有和map一样常用的`get、set、delete、has`\n<img src=\"images/5.jpg\" width=\"70%\"/>\n\n### 弱引用\n\n我们对比看下:\n```js\nconst map= new Map();\nlet obj = {a: 1};\nmap.set(obj,1);\nconsole.log(map.has(obj)); // true\nobj=null\nconsole.log(map.has(obj)); // false\nconsole.log(map); // Map(1) { { a: 1 } => 1 }\n```\n上面属于强引用, 虽然把`obj=null`, 但是map仍存在引用关系.\n\n```js\nconst weakMap= new WeakMap();\nlet obj = {a: 1};\nweakMap.set(obj,1);\nconsole.log(weakMap.has(obj)); // true\nobj=null\nconsole.log(weakMap.has(obj)); // false\nconsole.log(weakMap); // WeakMap(1) { { a: 1 } => 1 },打断点去控制台垃圾回收旧没有了\n```\n上面我们看着结果貌似一样,实际上, 我们打断点,在控制台`Memory`手动清除垃圾,此时就没有了\n<img src=\"images/5.jpg\" width=\"80%\"/>\n\n- 弱引用指的是,我们并不能控制什么时候回收,由浏览器自行决定,专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。\n\n注意,`键是弱引用,值是强引用`,我们修改下代码\n```js\nconst map = new WeakMap();\nlet obj = { a: 1 };\nlet value = { b: 1 };\nmap.set(obj, value);\nvalue = null;\nconsole.log(map); //  WeakMap { {a:1} => { b: 1 } }\n```\n此时就算我们去手动清除垃圾,打印还是会有\n### 转换\n```js\n// 数组->map\nfunction arrayToMap(array) {\n  return new Map(array); \n}\n// map->数组 不存在,因为是弱引用,都不存在遍历,所以自然不能通过...进行转换\n\n```\n## Set\n\n> 类似于数组，只不过成员的值都是唯一的，自带去重功能\n\n### 使用\n```js\nconst set = new Set([\n  0,\n  -0,\n  '0',\n  NaN,\n  NaN,\n  {},\n  {},\n  [],\n  [],\n  1,\n  '1',\n  1\n]);\nset.add(1);\nconsole.log(set);\n```\n打印结果如下:\n<img src=\"images/7.jpg\" width=\"70%\"/>\n- 和map一样, NaN会认为相同,去重\n\n### 方法\n我们打印下原型上的方法`console.log(Set.prototype)`, 可以看到里面无非就是 `增删改查、size、遍历`方法\n<img src=\"images/8.jpg\" width=\"70%\"/>\n\n### 遍历\n```js\nconst set = new Set([\n  1,\n  2\n]);\nconsole.log(set);\n// 在set中, key和value是一样的,是不存在key的,所以set.keys()和set.values()是一样的\nconsole.log(\"----for of----\");\nfor (let item of set) {\n  // 相当于set.values()\n  console.log(item);\n}\nconsole.log(\"----set.keys()----\");\nfor (let item of set.keys()) {\n  console.log(item);\n}\nconsole.log(\"----set.values()----\");\nfor (let item of set.values()) {\n  console.log(item);\n}\nconsole.log(\"----set.entries()----\");\nfor (let item of set.entries()) {\n  console.log(item);\n}\n```\n<img src=\"images/9.jpg\" width=\"30%\"/>\n\n- 上面我们可以看出`for of 和 set.values`是一样的效果\n\n### 转换\n```js\n// 数组->map\nfunction arrayToSet(array) {\n  return new Set(array); // Set(2) { 1, 2 }\n}\n// set->数组\nfunction setToArray(map) {\n  return [...set]; // [1, 2]\n}\n```\n\n## WeakSet\n- 和set一样,也会自动去重、只能添加对象如对象、数组、函数(null除外)和symbol,不能是基本类型,打印结果和set格式一样\n- 是弱引用,不计入垃圾回收机制\n- 只有增删改查,没有遍历、size, 因为是弱引用,不知道浏览器什么时候回收,所以也就不可能存在遍历,size\n\n### 使用\n```js\nconst weakSet = new WeakSet([{},()=>{},[]]);\nweakSet.add({});\nweakSet.add({});\nconsole.log(weakSet);\nweakSet.set(null); // TypeError:  Invalid value used in weak set\n```\n### 方法\n我们打印下原型上的方法`console.log(WeakSet.prototype)`,可以看到没有遍历,只有和map一样常用的`add、delete、has`\n<img src=\"images/10.jpg\" width=\"70%\"/>\n\n### 弱引用\n```js\nconst weakSet = new WeakSet();\nlet obj={a:1}\nweakSet.add(obj);\nconsole.log(weakSet.has(obj)); // true\nobj=null\nconsole.log(weakSet.has(obj)); // false\nconsole.log(weakSet);\n```\n和上面的weakMap一样, 也是清除垃圾才能看到.\n\n\n## 总结\n- map是添加([key,value]) 对标对象, set是添加([value,value])对标数组,原型上方法是增删改查、size、遍历\n- weakMap和weakSet和上面格式一样, 但是是弱引用, 注意weakMap键名是弱引用,值是强引用, 原型上方法没有遍历、size\n- set和weakSet会自带去重\n- 这四个类型对于NaN,都认为是一个键\n- map的新增是set,set的新增是add\n- 这四个类型不是js新增的基本数据类型,它们都是 ES6 引入的新的**数据结构**，被称为“集合类型”（Collection types）或“内置对象”，属于复杂数据类型或引用类型。\n ","categories":["javascript","傻傻分不清楚"]},{"title":"2.reactive和readonly","url":"/ypf-blog/2024/04/29/vue3源码/2.reactive和readonly/","content":"## 基本使用\n我们先学习下`reactive,shallowReactive,readonly,shallowReadonly`的基本使用\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.js\"></script>\n  <!-- <script src=\"../packages/reactivity/dist/@vue/reactivity.global.js\"></script> -->\n  <script>\n    const { reactive,readonly,shallowReactive, shallowReadonly } = window.VueReactivity;\n    // 返回一个对象:默认深度响应式代理\n    console.group('reactive');\n    const state = reactive({\n      name: \"John\",\n      list : [1,2,3]\n    });\n    console.log(state.list);\n    console.log(state);\n    console.groupEnd();\n\n    // 返回一个对象:浅层响应式代理\n    console.group('shallowReactive');\n    const state1 = shallowReactive({\n      name: \"John\",\n      list : [1,2,3]\n    });\n    console.log(state1.list);\n    console.log(state1);\n    console.groupEnd();\n\n    // 返回一个对象:只读代理\n    console.group('readonly');\n    const state2 = readonly({\n      name: \"John\",\n      list : [1,2,3]\n    });\n    state2.name = 'Doe';\n    console.log(state2.name);\n    state2.list.push(4);\n    console.log(state2.list);\n    console.groupEnd();\n\n    // 返回一个对象:浅层只读代理\n    console.group('shallowReadonly');\n    const state3 = shallowReadonly({\n      name: \"John\",\n      list : [1,2,3]\n    });\n    state3.name = 'Doe';\n    console.log(state3.name);\n    state3.list.push(4);\n    console.log(state3.list);\n    console.groupEnd();\n  </script>\n</html>\n\n```\n直接看结果\n<img src=\"images/1.jpg\" width=\"80%\"/>\n很容易理解:\n- reactive是用来创建代理对象的,默认是深层的\n- shallowReactive是浅层的,即第一层\n- readonly是创建深层只读代理对象的,任意层都不可以修改\n- shallowReadonly是创建浅层只读代理对象的, 第一层不可修改值,但深层可以修改\n\n接下来我们就开始通过来实现了\n\n## reactive\n```js\n// 新建 packages/reactivity/src/index.ts\n// 1. 导出入口文件\nexport {\n    reactive,\n    shallowReactive,\n    readonly,\n    shallowReadonly,\n} from './reactive'\n```\n```js\n// 新建 packages/reactivity/src/reactive.ts\nimport { isObject } from '@vue/shared'\nimport { reactiveHandlers, readonlyHandlers, shallowReactiveHandlers, shallowReadonlyHandlers } from './baseHandlers'\n// 2. 导出4个代理方法, 都调用了createReactiveObject函数生成,参数都有各自的handler处理器\nexport function reactive(target) {\n    return createReactiveObject(target, false, reactiveHandlers) // target是对象, false是不是只读的, reactiveHandlers是代理对象\n}\nexport function shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers) // target是对象, false是不是只读的, shallowReactiveHandlers是代理对象\n}\nexport function readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers) // target是对象, true是只读的, readonlyHandlers是代理对象\n}\nexport function shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers) // target是对象, true是只读的, shallowReadonlyHandlers是代理对象\n}\n// 3.创建createReactiveObject函数(实现代理的核心)\n// 用于存储代理,代理过就不会二次代理\n// WeakMap 是弱引用的Map，不会造成内存泄漏, key必须是对象, value可以是任意类型, 自动的垃圾回收机制\nconst reactiveMap = new WeakMap() \nconst readonlyMap = new WeakMap()\n// target是对象, isReadonly是只读的, baseHandlers是代理对象\nfunction createReactiveObject(target, isReadonly, baseHandlers) {\n    // 如果目标不是对象，直接返回\n    if (!isObject(target)) {\n        return target\n    }\n    // 如果已经代理过了，直接返回(优化)\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap\n    const existingProxy = proxyMap.get(target)\n    if (existingProxy) {\n        return existingProxy\n    }\n    // 创建代理对象\n    const proxy = new Proxy(target, baseHandlers)\n    proxyMap.set(target, proxy)\n    return proxy\n}\n```\n```js\n// 4.新建 packages/reactivity/src/baseHandlers.ts\nimport { isObject } from '@vue/shared'\nimport { reactive, readonly } from './reactive'\n// 5.创建get生成器\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        const res = Reflect.get(target, key, receiver)\n        if (shallow) {\n            // 如果是浅层的，就返回结果\n            return res\n        }\n        // 是对象，递归代理\n        // 懒代理递归，即当取值的时候才会递归代理,性能优化\n        if (isObject(res)) {\n            return isReadonly ? readonly(res) : reactive(res)\n        }\n        return res\n    }\n}\n// 6.创建set生成器\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        const res = Reflect.set(target, key, value, receiver) // 获取最新的值\n        return res\n    }\n}\nconst get = createGetter() // 不是只读的,是深层的\nconst shallowGet = createGetter(false, true) // 不是只读的,是浅层的\nconst readonlyGet = createGetter(true) // 是只读的,是深层的\nconst shallowReadonlyGet = createGetter(true, true) // 是只读的,是浅层的\nconst set = createSetter() // 不是只读的,是深层的\nconst shallowSet = createSetter(true) // 不是只读的,是浅层的\n\n// 7.导出4个handler\nexport const reactiveHandlers = {\n    get,\n    set,\n}\nexport const readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n        console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`)\n        return true\n    }\n}\nexport const shallowReactiveHandlers = {\n    get: shallowGet,\n    set: shallowSet,\n}\nexport const shallowReadonlyHandlers = {\n    get: shallowReadonlyGet,\n    set(target, key) {\n        console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`)\n        return true\n    }\n}\n```\n```js\n// packages/shared/src/index.ts\n// 判断是否是对象 \nexport function isObject(val) {\n    return val !== null && typeof val === 'object'\n}\n```\n\n## 总结\n上面实际流程很简单,比vue2递归遍历简单多了,我们接下来分步讲解下.\n1. 入口index.ts导出4个方法`reactive,shallowReactive,readonly,shallowReadonly`\n2. 这4个方法是统一调用了`createReactiveObject(target, readonly, handlers)`, handlers也同样对应了4个handlers\n```js\nexport function reactive(target) {\n    return createReactiveObject(target, false, reactiveHandlers) // target是对象, false是不是只读的, reactiveHandlers是代理对象\n}\nexport function shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers) // target是对象, false是不是只读的, shallowReactiveHandlers是代理对象\n}\nexport function readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers) // target是对象, true是只读的, readonlyHandlers是代理对象\n}\nexport function shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers) // target是对象, true是只读的, shallowReadonlyHandlers是代理对象\n}\n```\n3. createReactiveObject方法里面主要是进行 先判断不是对象(对象、数组)就return, 再从缓存`readonlyMap/reactiveMap(weakMap)`取,有的话就不代理,没有再进行**第一层代理**proxy\n```js\nfunction createReactiveObject(target, isReadonly, baseHandlers) {\n    // 如果目标不是对象，直接返回\n    if (!isObject(target)) {\n        return target\n    }\n    // 如果已经代理过了，直接返回(优化)\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap\n    const existingProxy = proxyMap.get(target)\n    if (existingProxy) {\n        return existingProxy\n    }\n    // 创建代理对象\n    const proxy = new Proxy(target, baseHandlers)\n    proxyMap.set(target, proxy)\n    return proxy\n}\n```\n4. 4个handlers,里面就是get、set, readonly的set很简单,直接抛出警告⚠️即可\n```js\nexport const reactiveHandlers = {\n    get,\n    set,\n}\nexport const readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n        console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`)\n        return true\n    }\n}\nexport const shallowReactiveHandlers = {\n    get: shallowGet,\n    set: shallowSet,\n}\nexport const shallowReadonlyHandlers = {\n    get: shallowReadonlyGet,\n    set(target, key) {\n        console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`)\n        return true\n    }\n}\n```\n5. 4个handlers各自对应get、set都是通过createGetter、createSetter来创建,我们先来看下createGetter, \n   - 里面主要使用了Reflect.get进行取值\n   - 如果是shallow浅层,直接return返回取的值\n   - 在判断如果是对象, 根据是否只读, `递归调用readonly(res)或者reactive(res)`,注意,**这里和vue2对比的好处是,vue2是初始化全部递归代理, 这个是默认只代理第一层,只有取值的时候才会递归代理**\n```js\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        const res = Reflect.get(target, key, receiver)\n        if (shallow) {\n            // 如果是浅层的，就返回结果\n            return res\n        }\n        // 是对象，递归代理\n        // 懒代理递归，即当取值的时候才会递归代理,性能优化\n        if (isObject(res)) {\n            return isReadonly ? readonly(res) : reactive(res)\n        }\n        return res\n    }\n}\n```\n6. 我们再来看下createSetter, 很简单,直接就是修改值\n```js\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        const res = Reflect.set(target, key, value, receiver) // 获取最新的值\n        // 触发更新\n        return res\n    }\n}\n```\n## 注意点\n### 为什么需要Reflect.get?\n我们会好奇,get函数里面直接 用对象取值就行了, 为什么还需要`Reflect.get`?举个例子就明白了\n```js\n   const origin = {\n      a: 1,\n      b: 2,\n      get c() {\n        return this.a + this.b;\n      },\n    };\n    const proxy = new Proxy(origin, {\n      get(target, key, receiver) {\n        console.log(\"get\", key);\n        // return origin[key];\n        return Reflect.get(target, key, receiver);\n      },\n    });\n    console.log(proxy.c);\n```\n如果使用`orign[key]`,我们看下打印截图\n<img src=\"images/2.jpg\" width=\"80%\"/>\n如果使用`Reflect`,我们看下打印截图\n<img src=\"images/3.jpg\" width=\"80%\"/>\n\n我们发现,如果使用Reflect,可以将this指向为receiver,这样一个key里面依赖其他key,我们就会在get中捕获到.","categories":["vue3源码"]},{"title":"1.Proxy和Reflect","url":"/ypf-blog/2024/04/09/vue3源码/1.Proxy和Reflect/","content":"## Proxy\n\n### 定义\n\n> `Proxy` 对象用于创建一个对象的代理,通过代理从而实现基本操作的拦截和自定义如属性查找、赋值、枚举、函数调用等）。是ES6(ES2015)新增.**在代理对象上所作的任何操作都会如实的反应到源对象身上，在这里你可以认为代理对象几乎等同于源对象,使用没什么区别,如origin.a和proxy.a都可以拿到值**\n\n换个方式理解: vue中的 `虚拟dom就是对真实dom的一层抽象`,因为直接操作真实DOM所带来的负面影响较大，所以考虑在真实DOM上增加一层抽象来得以解决这个问题，而这层抽象就是虚拟DOM.毫不客气的说，虚拟DOM承担了我们对真实DOM所做的一切操作，而Diff算法则会依赖这层抽象来决定是否更新真实DOM.\n\n如果把源对象看做“真实DOM”，代理对象看做“虚拟DOM”，捕获器则看做“Diff”算法，这样一来 Proxy 便与它有了异曲同工之妙。我们对代理对象(虚拟DOM)所做的一切操作，均由捕获器(Diff)决定此次操作是否反映至源对象(真实DOM)中，并由捕获器对此次操作给出一系列反馈\n\n### 兼容性\n如果你决定了在项目中大幅使用Proxy时，那么你应当注意一个问题——兼容性。 Proxy 是在ES6中新增的标准，目前主流浏览器中均已支持，但总有漏网之鱼(其它浏览器)是不支持该特性的，即便是 babel 也无能为力.\n我们知道 箭头函数 也是ES6的产物，而babel在转换箭头函数时会将箭头函数转为普通函数，但对于Proxy却不会做出任何转换.如下图\n转换前:\n<img src=\"images/1.webp\" width=\"80%\"/>\n转换后\n<img src=\"images/2.webp\" width=\"80%\"/>\n从上图中我们可以看出Proxy依旧是Proxy，如果我们在低于ES6的环境中去运行上述代码是会报错的，因为它不认识Proxy\n<img src=\"images/3.jpg\" width=\"80%\"/>\n\n\n### 使用\n\n#### 参数都必填\n```js\nconst origin = {} // 源对象\nconst handler = {} // 捕获器 (get、set、target、has、...)\nconst proxy = new Proxy(origin, handler) // 正确\nnew Proxy() // 错误\nnew Proxy(origin) // 错误\nnew Proxy(origin,{}) // 正确\n```\n- proxy缺少任何一个参数则抛出 `Uncaught TypeError: Cannot create proxy with a non-object as target or handler` 错误\n- 与vue2的区别是:Object.defineProperty是深度遍历属性且新增的属性只能通过$set来代理, 否则无法监听. 而proxy直接就**监听整个对象**,所以不存在遍历,新增无法监听\n\n#### 代理层级\n```js\nconst origin = {\n  a: 1,\n  b: {\n    c: 2,\n  },\n  list: [1, 2, 3],\n};\nconst proxy = new Proxy(origin, {});\nconsole.log(proxy.b); // {c: 2}是不会被代理的\nconsole.log(proxy.list); // [1, 2, 3]是不会被代理的\n// 代理list\nconst proxy1 = new Proxy(origin.list, {});\nconsole.log(proxy1);\n```\n- 所以proxy只会代理第一层,如果需要遍历深层,需要递归遍历,如果上面在handler里面写get,同样深层也不会触发\n  \n#### 原型\n```js\n    const origin = {\n      name: \"John\",\n    };\n    Object.prototype.age = 18;\n    const proxy = new Proxy(origin, {});\n    console.log(proxy);\n    console.log(Proxy.prototype); // undefined\n    console.log(proxy.__proto__);\n    console.log(Object.prototype);\n    console.log(proxy.__proto__ === Object.prototype); // true\n    console.log(Object.prototype.__proto__, Object.prototype.__proto__ === null); // null true\n    console.log(origin.name,origin.c,origin.age,proxy.name,proxy.c,proxy.age); // John undefined 18 John undefined 18\n    console.log(origin===proxy); // false\n    console.log(origin==proxy); // false\n    console.log(origin instanceof Object) // true\n    console.log(proxy instanceof Object) // true\n```\n运行结果如下\n<img src=\"images/4.jpg\" width=\"80%\"/>\n\n- `Proxy.prototype` 为 undefined, 那么疑问来了,实例的__proto__等于构造函数的原型, 是不是proxy.__proto__也为undefined. 实际测试比较特殊`proxy.__proto__ === Object.prototype`\n- 我们说过所有对代理对象的操作handler最终都会如实地映射至源对象身上，那 proxy.__proto__ 这个操作就相当于 origin.__proto__ ，而 origin.__proto__ 会指向 Object.prototype ，所以也就不难解释为什么 proxy.__proto__ 会指向 Object.prototype 了\n- **在代理对象上所作的任何操作都会如实的反应到源对象身上，在这里你可以认为代理对象几乎等同于源对象**\n\n### 控制台中的Proxy实例对象\n\n我们看下控制台proxy的结构\n<img src=\"images/5.jpg\" width=\"80%\"/>\n[[Handler]] 为处理对象， [[Target]] 为源对象， [[IsRevoked]] 代表当前代理对象是否已经被撤销。如果当前代理对象被撤销了，那么 [[IsRevoked]] 的值是 true ，而 [[Target]] 与 [[Handler]] 一律为 null, `Revoke英文翻译是废除、撤销的意思`\n<img src=\"images/6.jpg\" width=\"80%\"/>\n\n### IsRevoked内部属性\n\n#### [[]]符号\n\n[[]]这个符号在JS里代表内部属性。在JS里，[[Target]]这种两个括号包裹的属性，属于内部特性，这种些特性开发者无法直接访问。之所以你在F12里打印proxy对象能够看到这些内部特性，是为了让开发者明确知道这个对象是被代理过的，否则就无法区分普通对象和代理对象了。\nF12里打印的对象，都会有意的显示一些内部特性，比如[[prototype]]。但这些内部特性和对象上直接可以获取的属性是并不是同一个东西.实际上js提供了__proto__来访问.\n所以对于proxy，并不是通过`proxy.IsRevoked`这样去获取是否撤销代理.\n\n<img src=\"images/7.jpg\" width=\"80%\"/>\n\n\n#### 使用\n- 有时候你可能需要撤销代理对象与源对象之前的关联，此时就`不用Proxy`了,直接用 `Proxy.revocable` 代替，该方法会返回一个对象，返回的这个对象中`包含代理对象 proxy 与撤销函数 revoke` ，默认IsRevoked是false, 表示没有取消代理,即代理状态. \n- 需要注意的是， revoke 无论调用多少次，其结果总是相同，但如果在调用之后还试图访问代理对象中的属性，则会抛出 TypeError 。撤销代理之后不会对源对象造成任何负面影响\n- [[IsRevoked]]是内部属性,不能获取, js没有提供获取是否代理的方法.我们可以`自己定义Proxy.revocable函数`\n- 如果当前代理对象被撤销了，那么 [[IsRevoked]] 的值是 true ，而 [[Target]] 与 [[Handler]] 一律为 null, Revoke英文翻译是废除、撤销的意思\n<img src=\"images/8.jpg\" width=\"80%\"/>\n\n```js\nconst proxy1= Proxy.revocable(origin, {})\nconsole.log(proxy1);\nconsole.log(proxy1.proxy.name); // John\nproxy1.revoke(); // 取消代理\nconsole.log(origin.name); // John\nconsole.log(proxy1.proxy.name); // Cannot perform 'get' on a proxy that has been revoked\n```\n\n<img src=\"images/9.jpg\" width=\"80%\"/>\n\n### this指向\n\n- origin中的函数,如果`proxy.key`this指向proxy, `origin.key`this指向origin\n- 捕获器handler中函数,this指向handler函数\n\n```js\n    const origin = {\n      name: \"John\",\n      getName: function () {\n        console.log(this,'getName'); // proxy\n        return this.name;\n      },\n    };\n    const proxy = new Proxy(origin, {\n      get (target, key, receiver) {\n        console.log(key,'key');\n        console.log(this,'handler'); // handler对象\n        return target[key];\n      },\n    });\n    console.log(proxy.getName()) // John\n```\n\n<img src=\"images/10.jpg\" width=\"80%\"/>\n\n### get\n\n- handler中的get函数,会返回3个参数`target-origin对象`,`key-获取的key`,`receiver-proxy对象`\n- 默认我们不返回,获取值的时候也是undefined, 一般我们会进行判断抛出错误\n- 我们在get中应该使用`origin[key]`进行返回,不能使用`proxy[key]`进行返回,因为会重复触发get导致死循环\n- 只有访问代理proxy上的属性,才会触发get, 通过orign访问属性,不会触发\n\n```js\n  const origin = {\n    name: \"John\",\n  };\n  const proxy = new Proxy(origin, {\n    get (target, key, receiver) {\n      console.log(\n        target, // origin对象\n        key, // 获取值的key\n        receiver // proxy\n      );\n      if(key in target) {\n        return target[key];\n        // return proxy[key] 注意⚠️:不能这样写,相当于重复触发get导致死循环\n      }\n      // 如果不写else进行return, 此时proxy.c也是undefined, 我们也可以像下面代码一样进行抛出错误\n      else{\n        throw new Error('Property \"' + key + '\" does not exist.');\n      }\n\n    },\n  });\n  console.log(proxy.name); // John 会触发get\n  console.log(origin.name); // John 不会触发get\n\n```\n\n### set\n- handler中的set函数,会返回4个参数`target-origin对象`,`key-被设置值的key`,`value-要设置的value`,`receiver-proxy对象`\n- 一般设置完值后需要`return true`表示设置成功,也可不写, 下面代码没有判断条件啥的,总是成功的,所以`return false`也没影响,但从代码阅读逻辑上最好`return true`表示设置成功\n- 我们在set中应该使用`target[key] = value;`,不能使用`proxy[key] = value;`进行返回,因为会重复触发set导致死循环\n- set一个origin对象不存在的key,相当于新增一个key,就算原型存在这个key,也不会覆盖\n- 通过origin或者proxy添加新属性, origin/proxy都会添加, 当使用proxy获取新属性,会触发get\n```js\n    const origin = {\n      name: \"John\",\n    };\n    Object.prototype.age = 18;\n    const proxy = new Proxy(origin, {\n      set (target, key, value, receiver) {\n        console.log(\n          target, // origin对象\n          key, // 被设置值的key\n          value, // 要设置的value\n          receiver // proxy\n        );\n        target[key] = value;\n        // proxy[key] = value; 注意⚠️:不能这样写,相当于重复触发set导致死循环\n         return true; // 返回true表示设置成功 ,可以不写\n      },\n    });\n    proxy.name = \"Tom\"; \n    proxy.age = 20;  // 注意,此处set不是修改原型链上的属性,而是添加了一个age属性\n    origin.test=1; // 通过原对象添加属性,代理对象也会添加,获取代理对象的属性,也会触发get\n    console.log(proxy.name); // Tom\n    console.log(origin.name);// Tom\n    console.log(proxy.age); // 20\n    console.log(origin.age); // 20\n    console.log(proxy.test); // 1 会触发get\n    console.log(origin) // {name:\"Tome\",age:20} \n    console.log(proxy) \n```\n<img src=\"images/11.jpg\" width=\"80%\"/>\n\n### 广义上的对象\n> `Proxy`不仅仅可以代理对象(object)，还可以代理其它对象(广义上的对象，因为JS中 万物皆对象 )\n#### 代理数组\n```js\n  const origin = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    const proxy = new Proxy(origin, {\n      get(target, key, receiver) {\n        console.log(\n          target, // origin对象\n          key, // 获取值的key, 这里就是 index下标,注意是字符串,如'0'\n          receiver // proxy\n        );\n      },\n      set(target, key, value, receiver) {\n        console.log(\n          target, // origin对象\n          key, // 被设置值的key, 这里就是 index下标,注意是字符串,如'0'\n          value, // 要设置的value\n          receiver // proxy\n        );\n        return target[key] = value; // 返回表示设置成功 ,可以不写\n      }, \n    });\n    proxy[0]\n    proxy[0] = 100;\n    proxy.length=5 // 设置数组长度,也会触发set, 里面打印的target仍是[1,2,3,4,5,6,7,8,9,10],key为'length',value就是5\n    console.log(proxy) // {0: 1, 1: 2, 2: 3, 3: 4, 4: 5} 会截取前5个元素\n    proxy[5] // undefined, 此时会触发get,里面打印的target是[1,2,3,4,5]\n    proxy[0]=2 // 修改数组元素,也会触发set,里面打印的target现在是[1,2,3,4,5]\n```\n**说明修改数据长度, proxy会自动按长度截取数组**\n## js对象的get和set\n```js\nconst person = {\n  firstName: \"hello\",\n  lastName: \"world\",\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n  set fullName(value) {\n    const parts = value.split(\" \");\n    this.firstName = parts[0];\n    this.lastName = parts[1];\n  },\n};\nconsole.log(person);\nconsole.log(person.fullName);\nperson.fullName = \"John Smith\";\nconsole.log(person);\nconsole.log(person.fullName);\n```\n<img src=\"images/12.jpg\" width=\"80%\"/>\n- 上面对象中的get、set实际es5很早就支持了,并不是es6新增的,它就是getter和setter,上面我们是通过对象字面量定义getter、setter,在es5我们还可以通过Object.defineProperty,es6是通过Class类\n- 在函数前面加上get, 此时就不是函数了,直接就是一个值(相当于函数调用), 一般用于隐藏内部逻辑,计算值.我们看上面截图,fullName就是一个计算好的值.\n- set只支持一个参数,不支持多个参数,会报错. 我们给key赋值的value就是set的参数\n\n## Reflect\n> 用于函数式调用Object内部方法\n### 定义\n- 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。\n- 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。\n```js\n// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n```\n- 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。\n```js\n// 老写法\n'assign' in Object // true\n\n// 新写法\nReflect.has(Object, 'assign') // true\n```\n- Reflect对象的方法与Proxy对象的方法一一对应，`只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法,并且参数都一模一样`.如Proxy的get,和Reflect.get,方法一样,参数也一样.这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。\n- 有了Reflect对象以后，很多操作会更易读。\n- Reflectt不是一个函数对象，因此它是不可构造的.与大多数全局对象不同，Reflect没有构造函数，所以不能将其与new一起使用，Reflect所有属性和方法都是静态的。我们打印看看`console.log(Reflect)`\n<img src=\"images/13.jpg\" width=\"80%\"/>\n\n\n```js\n// 老写法\nFunction.prototype.apply.call(Math.floor, undefined, [1.75]) // 1\n\n// 新写法\nReflect.apply(Math.floor, undefined, [1.75]) // 1\n```\n### 方法\nReflect对象一共有 13 个静态方法\n```js\nReflect.apply(target, thisArg, args)\nReflect.construct(target, args)\nReflect.get(target, name, receiver)\nReflect.set(target, name, value, receiver)\nReflect.defineProperty(target, name, desc)\nReflect.deleteProperty(target, name)\nReflect.has(target, name)\nReflect.ownKeys(target)\nReflect.isExtensible(target)\nReflect.preventExtensions(target)\nReflect.getOwnPropertyDescriptor(target, name)\nReflect.getPrototypeOf(target)\nReflect.setPrototypeOf(target, prototype)\n```\n#### get\n我们知道`只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法,并且参数都一模一样`,所以get方法有3个参数 `target、key、receiver`,我们测试下\n```js\nconst person = {\n  firstName: \"hello\",\n  lastName: \"world\",\n  get fullName() {\n    console.log(this,'this');\n    return `${this.firstName} ${this.lastName}`;\n  },\n  set fullName(value) {\n    const parts = value.split(\" \");\n    this.firstName = parts[0];\n    this.lastName = parts[1];\n  },\n  testFn(){\n    console.log(this,'this');\n  }\n};\nReflect.get(person, \"testFn\",{\n  firstName:1,\n  lastName:2\n})() // 此时this指向window, 需要加()执行,因为不加相当于读testFn属性,返回的是个函数体字符串\nperson.testFn() // 此时this指向person\nconsole.log(Reflect.get(person, \"fullName\")); // hello world\nconsole.log(\n  Reflect.get(person, \"fullName\", {\n    firstName: 1,\n    lastName: 2,\n  }) // 此时this指向该对象\n); // 1 2\n```\n\n- 如果属性key是个getter,则getter函数中的this指向receiver,如果省略receiver,默认指向target\n\n#### set\n同理,set方法4个参数 `target、key、value、receiver`, 并且如果key是个setter, 则this指向receiver,如果省略receiver,默认指向target","categories":["vue3源码"]},{"title":"2.vue-router的hook","url":"/ypf-blog/2024/03/28/vue-router/2.vue-router的hook/","content":"## 基本使用\n\n```js\n  const router = new VueRouter({\n    routes: [],\n  });\n  router.beforeEach((to, from, next) => {\n    setTimeout(() => {\n      console.log(1);\n      next();\n    }, 1000);\n  });\n  router.beforeEach((to, from, next) => {\n    setTimeout(() => {\n      console.log(2);\n      next();\n    }, 3000);\n  });\n```\n\n我们看上面代码, 知道router是可以写多个beforeEach,  但是只有最后一个next执行时,才会渲染页面. 所以\n- `router的hook实际上是一个队列,next是执行下一项`\n\n## 原理\n\n### 定义beforeEach\n\n```js\n修改src/vue-router/index.js\nexport default class VueRouter {\n  constructor(options = {}) {\n    ...\n    this.beforeHooks = []; // 全局前置守卫\n    ...\n  }\n  ...\n   // 定义全局前置守卫\n  beforeEach(fn) {\n    this.beforeHooks.push(fn);\n  }\n}\n```\n\n所以上面我们调用beforeEach,都会push到数组里.\n\n### 执行队列\n\n```js\n修改src/vue-router/history/base.js\n// 列队执行 queue:列队 iterator:执行列队的函数 cb:回调函数\nfunction runQueue(queue, iterator, cb) {\n  function step(index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        iterator(queue[index], () => {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  }\n  step(0);\n}\nclass History {\n    // 路由跳转\n  transitionTo(location, cb) {\n    console.groupInfo(\n      \"通过this.router.matcher.match将当前路径转换为matched数组形式的路由信息(上面扁平路由进行二次转换)\"\n    );\n    const route = this.router.matcher.match(location); // 获取当前路径对应的路由信息\n    console.log(route, 1232131);\n    // console.log('如 {/bar/child:{path,component,parent}}转化为{path:/bar/child,matched:[{path:/bar,component,parent},{path:child,component,parent}]}');\n    console.log(\"转化前\", \"{/bar/child:{path,component,parent}}\");\n    console.log(\n      \"转化后\",\n      \"{path:/bar/child,matched:[{path:/bar,component,parent},{path:child,component,parent}]}\"\n    );\n    console.groupInfoEnd();\n\n    // 获取全局前置守卫列队\n    const queue = [].concat(this.router.beforeHooks);\n    // 执行列队\n    const iterator = (hook, next) => {\n      hook(route, this.current, next);\n    };\n    runQueue(queue, iterator , () => {\n      console.info(\"this.current更新为当前路径对应的路由信息\");\n      this.current = route;\n      console.info(\"更新视图\");\n      this.cb && this.cb(route); // 监听路由变化,更新视图\n      cb && cb(route);\n    });\n  }\n}\n```\n我们知道router初始化会执行 init函数,里面调用了 `transitionTo跳转当前url更新路由信息,最后渲染页面`,所以我们只需要渲染前递归队列就可以了.\n- runQueue是一个列队执行函数, 通过next执行下一项, 全部结束后执行回调.\n- iterator是当前执行函数, 参数是to(最新的路由信息)、from(this.current-上一次路由信息)、next(执行下一项)\n- 当队列结束后,执行cb,即\n```js\n  this.current = route; // 更新最新的路由信息\n  this.cb && this.cb(route); // 监听路由变化,更新视图,即初始化通过history.listen传入的`app._route = route`\n  cb && cb(route); // 执行调用trasntionTo方法时候,传入的回调(如push方法后修改url-window.location.hash = location、或者初始化的监听 history.setupListeners)\n```\n\n**所以next是执行列队的下一项, 而不是渲染页面,只有执行完才会渲染页面**\n\n## 总结\n\n- beforeEach就是一个列队,每调用一次就会添加到数组中,然后再transitionTo方法中依次next执行,直到结束执行渲染页面(`this.cb && this.cb(route)`)\n- 参数是to(最新的路由信息-`const route = this.router.matcher.match(location)`)、from(`this.current`-上一次路由信息)、next(执行下一项)\n- 渲染页面的原理就是,router-view依赖$route(当前页面路由信息)->_route->current, 第一次init的时候,往this.cb中存储了`app._route = route`,所以执行this.cb就会触发$route变化,页面依赖了$route,最后导致渲染页面. dep和watcher可以回一下.\n\n","categories":["vue2源码","vue-router"]},{"title":"1.vue-router原理","url":"/ypf-blog/2024/03/26/vue-router/1.vue-router原理/","content":"## 基本用法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.min.js\"></script>\n    <!-- <script src=\"https://cdn.bootcdn.net/ajax/libs/vue-router/3.6.5/vue-router.min.js\"></script> -->\n    <script src=\"./dist/vue-router.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <router-link to=\"/foo\">Go to Foo</router-link>\n      <router-link to=\"/bar\"> Go to Bar </router-link>\n      <router-link to=\"/bar/child\">Go to BarChild</router-link>\n      <router-view test=\"1\" class=\"aa\" title=\"1\" id=\"bb\"></router-view>\n    </div>\n  </body>\n</html>\n<script>\n  Vue.use(VueRouter);\n  new Vue({\n    el: \"#app\",\n    router: new VueRouter({\n      routes: [\n        { path: \"/foo\", component: { template: \"<div>foo</div>\" } },\n        {\n          path: \"/bar\",\n          component: { template: \"<div>bar<router-view></router-view></div>\" },\n          children: [\n            {\n              path: \"child\", // 子路由\n              component: { template: \"<div>barchild</div>\" },\n            },\n            {\n              path: \"/child\", // 不是子路由\n              component: { template: \"<div>barchild</div>\" },\n            },\n          ],\n        },\n      ],\n    }),\n    created() {\n      console.log(this.$router, \"router\");\n      console.log(this.$route, \"route\");\n    },\n  });\n</script>\n```\n**注意⚠️: 上面child和/child不一样, vue认为首个字符为/的path不是子路由,所以child最终为/bar/child,而child最终为/child**\n\n## 原理\n\n### 创建VueRouter类\n\n和Vuex一样,我们也要使用`Vue.use(VueRouter)`和传入`router: new VueRouter({})`,所以\n```js\nsrc/vue-router/index.js\nlet Vue;\nexport default class VueRouter {\n  constructor(options = {}) {}\n}\nVueRouter.install = function (_Vue) {\n  Vue = _Vue;\n}\n```\n我们看下大概流程图\n<img src=\"images/step.jpg\" width=\"80%\"/>\n\n#### install\n接下来我们来完善install的代码\n```js\nVueRouter.install = function (_Vue) {\n  Vue = _Vue;\n  // 1. 注册全局组件\n  Vue.component(\"RouterLink\", Link);\n  Vue.component(\"RouterView\", View);\n  // 2. 注册全局混入\n  Vue.mixin({\n    beforeCreate() {\n      if (this.$options.router) {\n        this._routerRoot = this; // 将根实例挂载到_routerRoot上暴露给子组件\n        this._router = this.$options.router;\n        // 初始化\n        console.groupInfo(\"初始化路由(渲染页面)...\")\n        this._router.init(this);\n        console.groupInfoEnd()\n        // 通过defineReactive将_route变成响应式的\n        Vue.util.defineReactive(this, \"_route\", this._router.history.current);\n      } else {\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\n        // this._router = this.$parent && this.$parent._router;\n      }\n    },\n  });\n  // 3. 注册实例方法\n  Object.defineProperty(Vue.prototype, \"$router\", {\n    get() {\n      // return this._router;\n      return this._routerRoot._router;\n    },\n  });\n  Object.defineProperty(Vue.prototype, \"$route\", {\n    get() {\n      // return this._route;\n      return this._routerRoot._route;\n    },\n  });\n};\n\n```\n上面我们\n- 创建了全局组件 `RouterLink`和`RouterView`\n- 全局混入beforeCreate方法中, 通过`this._routerRoot`存储根实例vm,找不到找parent. 同时`this._router = this.$options.router`为每个组件写入_router, 最后创建响应式变量`Vue.util.defineReactive(this, \"_route\", this._router.history.current);`\n- 调用`this._router.init(this)`进行初始化\n- 在`Vue.prototype`挂载`$router-->this._routerRoot._router`, `$route-->this._routerRoot._route`便于访问\n上面流程很好理解, 我们知道`this.$router-->this.$options.router`, `this.$route-->this._router.history.current`.接下来我们来讲解这两个都是什么意思.\n\n#### VueRouter类\n\n```js\nimport Link from \"./components/link\";\nimport View from \"./components/view\";\nimport { createMatcher } from \"./create-matcher\";\nimport { HashHistory } from \"./history/hash\";\nimport { HTML5History } from \"./history/html5\";\nexport default class VueRouter {\n  constructor(options = {}) {\n    // 一.  创建路由匹配器\n    console.groupInfo(\"创建路由匹配器\")\n    this.matcher = createMatcher(options.routes || []); // this.matcher={addRoutes, match} \n    console.log(this.matcher, \"this.matcher\");\n    console.groupInfoEnd()\n    // 二.浏览器的路由管理\n    // 1.获取模式,默认是hash模式\n    console.groupInfo(\"初始化路由模式(创建this.history实例)\")\n    let mode = options.mode || \"hash\";\n    switch (mode) {\n      case \"hash\": // hash模式\n        this.history = new HashHistory(this, options.base);\n        break;\n      case \"history\": // HTML5模式\n        this.history = new HTML5History(this, options.base);\n        break;\n      case \"abstract\": // 服务端渲染\n        this.history = new AbstractHistory(this, options.base);\n        break;\n      default:\n        console.error(`不支持${mode}模式`);\n    }\n    console.groupInfoEnd()\n  }\n  // 三.初始化(根据当前路径,渲染对应的组件)、监听路由变化、跳转路由\n  init(app) {\n    // 1.获取当前路径,渲染对应的组件\n    const history = this.history;\n    // 2.跳转\n    console.info(\"1.window.location.hash获取当前url的hash值:\")\n    console.log(history.getCurrentLocation());\n    console.groupInfo(\"2.history.transitionTo跳转到该hash,回调监听路由变化\")\n    history.transitionTo(\n      history.getCurrentLocation(), // 获取当前路径\n      history.setupListeners // 监听路由变化\n    );\n    console.groupInfoEnd()\n    // 3.更新_route\n    console.info(\"3.往history中添加更新_route的回调函数,用于后续切换页面更新视图,第一次不需要\")\n    history.listen((route) => {\n      app._route = route;\n    });\n  }\n  // 路由跳转\n  push(location) {\n    this.history.push(location);\n  }\n  // 路由跳转\n  replace(location) {\n    this.history.transitionTo(location, () => {\n      window.location.replace(\n        window.location.href.replace(/#(.*)$/, \"\") + \"#\" + location\n      );\n    });\n  }\n}\n```\n\n##### 创建路由匹配器\n主要包括如下内容:\n- 通过`createRouteMap`进行递归将用户传入的嵌套数组路由-->扁平路由pathMap,即\n  ```js\n    [\n        { path: \"/foo\", component: { template: \"<div>foo</div>\" } },\n        {\n          path: \"/bar\",\n          component: { template: \"<div>bar<router-view></router-view></div>\" },\n          children: [\n            {\n              path: \"child\",\n              component: { template: \"<div>barchild</div>\" },\n            },\n          ],\n        },\n      ]\n      // 转化为\n      {\n          \"/foo\": {\n              \"path\": \"/foo\",\n              \"component\": {\n                  \"template\": \"<div>foo</div>\",\n              }\n          },\n          \"/bar\": {\n              \"path\": \"/bar\",\n              \"component\": {\n                  \"template\": \"<div>bar<router-view></router-view></div>\"\n              }\n          },\n          \"/bar/child\": {\n              \"path\": \"child\",\n              \"component\": {\n                  \"template\": \"<div>barchild</div>\"\n              },\n              \"parent\": {\n                  \"path\": \"/bar\",\n                  \"component\": {\n                      \"template\": \"<div>bar<router-view></router-view></div>\"\n                  }\n              }\n          }\n      }\n  ```\n- 创建match方法,入参接受当前url,返回当前路径的数组组(里面遍历了上面的pathMap进行二次格式化)\n  ```js\n    \"/bar/child\": {\n        \"path\": \"child\",\n        \"component\": {\n            \"template\": \"<div>barchild</div>\"\n        },\n        \"parent\": {\n            \"path\": \"/bar\",\n            \"component\": {\n                \"template\": \"<div>bar<router-view></router-view></div>\"\n            }\n        }\n    }\n    // 转化为 matched数组用于后面router-view渲染\n    {\n        \"path\": \"/bar/child\",\n        \"matched\": [\n            {\n                \"path\": \"/bar\",\n                \"component\": {\n                    \"template\": \"<div>bar<router-view></router-view></div>\",\n                }\n            },\n            {\n                \"path\": \"child\",\n                \"component\": {\n                    \"template\": \"<div>barchild</div>\",\n                },\n                \"parent\": {\n                    \"path\": \"/bar\",\n                    \"component\": {\n                        \"template\": \"<div>bar<router-view></router-view></div>\",\n                    }\n                }\n            }\n        ]\n    }\n  ```\n- 导出addRoutes方法,用于动态添加路由(原理就是和生成pathMap一样, 调用createRouteMap,用户传入路由和已有的pathMap进行遍历合并)\n\n我们来看下create-matcher文件\n```js\nsrc/vue-router/create-matcher.js\nimport { createRouteMap, createRoute } from \"./create-route-map\";\nexport function createMatcher(routes, router) {\n  // 创建路由映射表,数组转对象,如将[{ path: '/foo', component: Foo }]转换为{ pathMap: { '/foo': {component,parent} ,'/bar':{component,parent},'/bar/child':{component,parent}},即嵌套路由转换为扁平路由\n  console.groupInfo(\"嵌套路由-->扁平路由\")\n  const { pathMap } = createRouteMap(routes);\n  console.log(pathMap,'pathMap');\n  console.groupInfoEnd()\n  // 用户自己定义的路由,动态添加-合并路由配置,将上一步的pathMap和新的routes传过去进行合并\n  function addRoutes(routes) {\n    createRouteMap(routes, pathMap);\n  }\n  // addRoutes([{\n  //   path: '/a',\n  //   component: {\n  //     render(h) {\n  //       return h('div', 'a');\n  //     }\n  //   }\n  // }])\n  // console.log(pathMap,2);\n  // addRoutes([\n  //   {\n  //     path: \"/bar\",\n  //     component: { template: \"<div>bar111<router-view></router-view></div>\" },\n  //     children: [\n  //       {\n  //         path: \"child1\",\n  //         component: { template: \"<div>barchild1</div>\" },\n  //       },\n  //     ],\n  //   },\n  // ]);\n  // console.log(pathMap,3);\n  // 将pathMap中的子路由增加match属性进行拆分为数组\n  // 如/about/a/b=>{ path: '/about/a/b', matched: [{ path: '/about', component: About }, { path: 'a', component: A }, { path: 'b', component: B }] }\n  function match(location) {\n    let record = pathMap[location];\n    if (record) {\n      return createRoute(record, {\n        path: location,\n      });\n    }\n    return createRoute(null, {\n      path: location,\n    });\n  }\n  return {\n    match,\n    addRoutes,\n  };\n}\n```\n```js\nsrc/vue-router/create-route-map.js\n// 目的：将路由配置转换为路由映射表, 用于匹配路由, 生成路由链接等\nexport function createRouteMap(routes, oldPathMap = Object.create(null)) {\n  let pathMap = oldPathMap; // 创建一个空对象,用于存放路由映射表\n  routes.forEach((route) => {\n    addRouteRecord(route, pathMap);\n  });\n  return {\n    pathMap,\n  };\n}\n// 将路由配置转换为路由映射表, 用于匹配路由, 生成路由链接等.route:如{ path: '/foo', component: Foo }\nfunction addRouteRecord(route, pathMap, parent) {\n  const { name, component } = route;\n  const record = {\n    name,\n    path: route.path,\n    component,\n    parent,\n  };\n  let path;\n  if(route.path[0] === '/'){\n    path = route.path;\n  }else{\n    if(parent){\n      path = `${parent.path}/${route.path}`; // 如果有parent,说明是children子路由,则path需要拼接\n    } else {\n      path = `/${route.path}`;\n    }\n  }\n  if (!pathMap[path]) {\n    pathMap[path] = record;\n  }\n  // 递归处理子路由,递归\n  if (route.children) {\n    route.children.forEach((child) => {\n      // 注意,传record是为了知道儿子的父亲是谁\n      addRouteRecord(child, pathMap, record);\n    });\n  }\n}\n// 创建路由,返回一个对象,\n// 如/about/a=>{ path: '/about/a', matched: [{ path: '/about', component: About }, { path: 'a', component: A }] }\nexport function createRoute(record, location) {\n  let { path } = location;\n  let matched = [];\n  if (record) {\n    while (record) {\n      matched.unshift(record); // 因为先渲染/a,再渲染/about,所以需要unshift将/about放在前面\n      record = record.parent;\n    }\n  }\n  return {\n    path,\n    matched,\n  };\n}\n\n```\n\n\n#### 初始化路由模式\n- 创建history类, 包括base.js公共类,和不同模式的类继承base.如hash.js、html5.js、abstract.js\n- 以hash举例子,初始化类就执行`ensureSlash`方法,将当前url变成hash模式.如果没有hash值,则window.location.hash值为/,此时浏览器会自动跳转到/#/,这个是浏览器自动跳转的.\n- base公共类定义了transitionTo(更新当前this.current路由信息、赋值给_route进行页面更新)、listen(用于存入更新视图的回调函数)\n- hash类定义了getCurrentLocation(获取当前hash路径)、push(调用transitionTo,回调函数为修改url的hash)、setupListeners(监听路由变化,window.addEventListener(\"hashchange\",cb),调用transitionTo)\n- 如果是html5类,则是调用window.addEventListener(\"popstate\",cb) 用来监听用户在浏览器中点击了回退或前进按钮的事件,该事件支持移动设备上的回退键\n```js\nsrc/vue-router/history/base.js\nimport { createRoute } from \"../create-route-map\"; \n// 公共方法\nclass History {\n  constructor(router, base) {\n    this.router = router;\n    // 保存当前路径对应当前路由信息\n    console.groupInfo(\"this.current保存当前路径对应当前路由信息\");\n    this.current = createRoute(null, {\n      path: \"/\",\n    });\n    console.log(this.current, \"this.current\");\n    console.groupInfoEnd();\n    this.cb = null; // 用于监听路由变化的回调函数\n  }\n\n  // 路由跳转\n  transitionTo(location, cb) {\n    console.groupInfo('通过this.router.matcher.match将当前路径转换为matched数组形式的路由信息(上面扁平路由进行二次转换)')\n    const route = this.router.matcher.match(location);// 获取当前路径对应的路由信息\n    console.log(route,1232131);\n    // console.log('如 {/bar/child:{path,component,parent}}转化为{path:/bar/child,matched:[{path:/bar,component,parent},{path:child,component,parent}]}');\n    console.log('转化前','{/bar/child:{path,component,parent}}')\n    console.log('转化后','{path:/bar/child,matched:[{path:/bar,component,parent},{path:child,component,parent}]}');\n    console.groupInfoEnd()\n    console.info(\"this.current更新为当前路径对应的路由信息\");\n    this.current=route\n    // createRoute(route, {\n    //   path: location,\n    // });\n    console.log(this.cb,1111);\n    console.info('更新视图');\n    this.cb && this.cb(route); // 监听路由变化,更新视图\n    cb && cb(route);\n  }\n  // 监听路由变化\n  listen(cb) {\n    this.cb = cb;\n  } \n}\nexport { History };\n```\n\n```js\nsrc/vue-router/history/hash.js\nimport { History } from \"./base\";\n// 获取浏览器地址栏的hash值(#/a),并去掉#号\n// slice(a,b)截取字符串,从第a个字符开始截取到第b个字符,不包括第b个字符,如果b不写,则截取到最后一个字符\n// 原字符串不变,返回截取后的字符串\n// slice(1)截取字符串,从第二个字符开始截取到最后一个字符,不包括最后一个字符\nfunction getHash() {\n  return window.location.hash.slice(1);\n}\nclass HashHistory extends History {\n  constructor(router, base) {\n    super(router, base); // 调用父类的构造函数,super()是调用父类的构造函数\n    this.router = router; // 路由实例\n    console.groupInfo(\"确保地址栏的url是以#开头\");\n    // slash是斜杠的意思,确保当前是hash模式,没有hash值,则设置hash值为/,此时浏览器会自动将url变成/#/,注意hash改变并不会触发页面刷新,只是改变了url,hash相当于页面内的锚点、片段标识符\n    ensureSlash();\n    console.groupInfoEnd();\n  }\n  // 获取当前路径\n  getCurrentLocation() {\n    return getHash();\n  }\n  // 监听路由变化\n  setupListeners() {\n    console.info(\"回调监听: window.addEventListener-hashchange\");    \n    window.addEventListener(\"hashchange\", () => {\n      if (!ensureSlash()) {\n        return;\n      }\n      console.info('跳转')\n      this.transitionTo(getHash()); // 路由跳转\n    });\n  }\n  // 路由跳转\n  push(location) {\n    this.transitionTo(location, () => {\n      window.location.hash = location;\n    });\n  }\n}\n// 确保当前是hash模式,即浏览器地址栏的url是以#开头的\nfunction ensureSlash() {\n  if (window.location.hash) {\n    return;\n  }\n  window.location.hash = \"/\"; // 如果没有hash值,则设置hash值为/,此时浏览器会自动跳转到/#/\n}\nexport { HashHistory };\n```\n\n#### 初始化\n- 在install中的beforeCreate调用`this._router.init(this)`进行初始化\n- 调用`history.transitionTo(history.getCurrentLocation(), history.setupListeners);`进行更新当前路由\n- `history.listen((route) => {app._route = route});`往history中添加更新_route的回调函数,用于后续切换页面更新视图,第一次不需要\n\n#### 渲染\n- router-link代码很简单,就是个组件接收tag标签、to,自定义了click,调用了`this.$router.push(to)`\n- router-view是个函数式组件,里面主要通过while循环向上parent,获取组件的深度depth,然后通过parent.$route即this._router.history.current,获取current.matched[depth]找到组件,渲染对应次数, 如/bar/child,先渲染/bar,再渲染/child, 共2次\n\n```js\nsrc/vue-router/view.js\nexport default {\n  name: \"router-view\",\n  functional: true,\n  // render共有两个参数,第一个是createElement,第二个是context,context表示当前组件的上下文\n  render(h, { parent, data, children, props}) {\n    console.groupInfo('router-view渲染');\n    // 1. 获取当前路由\n    const route = parent.$route; // 需要从父组件中获取当前路由,因为当前组件是一个函数式组件,没有this,不会有$route属性\n    // 2. 对于嵌套路由,需要递归查找是否routerView为true,并且计算深度,深度就表示当前路由的层级,由里到外,一直到根路由,有几次parent就表示有几层路由\n    console.info('while循环查找routerView为true的深度')\n    data.routerView = true;\n    let depth = 0;\n    while (parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      parent = parent.$parent;\n    }\n    let record = route.matched[depth]\n    console.log(depth , 'depth');\n    console.log(record, '当前路由信息');\n    if (!record) {\n      return h();\n    }\n    // h-渲染函数,用于创建虚拟dom,参数有三个,第一个是标签名,第二个是属性,第三个是子元素,如h('div', { class: 'container' }, 'hello')\n    return h(record.component,data);\n  },\n};\n```\n\n```js\nsrc/vue-router/link.js\nexport default {\n  name: \"RouterLink\",\n  props: {\n    to: {\n      type: String,\n      required: true,\n    },\n    tag: {\n      type: String,\n      default: \"a\",\n    },\n  },\n  render(h) {\n    const tag = this.tag;\n    const handler = (e) => {\n      e.preventDefault();\n      this.$router.push(this.to);\n    };\n    return h(\n      tag,\n      { on: { click: handler }, attrs: { href: this.to } },\n      this.$slots.default\n    );\n  },\n};\n```\n\n## 总结\n- VueRouter是个类,install方法,通过Object.defineProperty(Vue.prototype,绑定了$router(VueRouter的实例)、$route(当前路由的组件信息).并且通过mixin在beforeCreate绑定`this._router = this.$options.router`实例,然后`this._router.init(this)`进行初始化.且通过`Vue.util.defineReactive(this, \"_route\", this._router.history.current)`进行响应式.\n-  init方法就是调用transitionTo方法跳转指定path,更新current当前路由信息\n- history类, 包括base.js公共类,和不同模式.如hash.js、html5.js、abstract.js, 都继承base\n- 以hash举例子,初始化类就执行`ensureSlash`方法,将当前url变成hash模式.如果没有hash值,则window.location.hash值为/,此时浏览器会自动跳转到/#/,这个是浏览器自动跳转的.\n- base公共类定义了transitionTo(更新当前this.current路由信息、赋值给_route进行页面更新)、listen(用于存入更新视图的回调函数)\n- hash类定义了getCurrentLocation(获取当前hash路径)、push(调用transitionTo,回调函数为修改url的hash)、setupListeners(监听路由变化,window.addEventListener(\"hashchange\",cb),调用transitionTo)\n- 如果是html5类,则是调用window.addEventListener(\"popstate\",cb) 用来监听用户在浏览器中点击了回退或前进按钮的事件,该事件支持移动设备上的回退键\n- router-link代码很简单,就是个组件接收tag标签、to,自定义了click,调用了`this.$router.push(to)`\n- router-view是个函数式组件,里面主要通过while循环向上parent,获取组件的深度depth,然后通过parent.$route即this._router.history.current,获取current.matched[depth]找到组件,渲染对应次数, 如/bar/child,先渲染/bar,再渲染/child, 共2次\n- 路由配置经过了2次格式化, 一次对象扁平化、第二次当前路由信息(match数组), 最后用于router-view渲染","categories":["vue2源码","vue-router"]},{"title":"3.vuex-helpers","url":"/ypf-blog/2024/02/06/vuex/3.vuex-helpers/","content":"## 基本用法\nhelpers是什么?顾名思义,指的是辅助函数.包括`mapState、mapGetters、mapMutations、mapActions`\n```js\ncomputed:{\n  ...Vuex.mapState([\"age\"]),\n  ...Vuex.mapState({\n    age: (state, getters) => {\n      return state.age + 199990;\n    },\n  }),\n  ...Vuex.mapState(\"ModuleA\", {\n    age: (state, getters) => {\n      return state.age + 199990;\n    }\n  }),\n  ...Vuex.mapGetters([\"myAge\"]),\n  ...Vuex.mapGetters(\"ModuleA\", [\"myAge\"]),\n  // 注意,下面这种传入对象不支持\n  ...Vuex.mapGetters(\"ModuleA\",{\n    myAge: (state, getters) => {\n      return state.age + 1000;\n    },\n  }),\n}\nmethods:{\n    ...Vuex.mapMutations(['changeAge']),\n    ...Vuex.mapMutations(\"ModuleA\",['changeAge']),\n    ...Vuex.mapActions(['changeAge']),\n    ...Vuex.mapActions(\"ModuleA\",['changeAge']),\n    ...Vuex.mapMutations({\n    changeAge: (commit,...rest)=>{\n        console.log(commit,rest);\n      },\n    }),\n    ...Vuex.mapActions({\n      changeAge: (dispatch,...rest)=>{\n        console.log(dispatch,rest);\n      },\n    }),\n}\n语法: \nmapState(namespace, Array|Obj) \nmapGetters(namespace, Array) \nmapMutations(namespace, Array|Obj)\nmapActions(namespace, Array|Obj)\n```\n**注意:namespace可省略、mapGetters只能传入数组,对象不支持**\n\n## 原理\n以mapState为例,我们目的就是在模版中直接使用age,而不用`$store.state.age`,所以相当于\n```js\ncomputed:{\n  age(){\n    return this.$store.state.age\n  }\n}\n```\n那我们mapState的方法原理很简单: **实现一个数组返回多个computed函数(返回store上的state或module上的state)**,这样我们通过...解构出来即可.\nmapActions/mapMutations一样, **实现一个数组返回多个fn即可**\n```js\n// src/vuex/index.js\nimport { Store } from \"./store\";\nimport { install } from \"./mixin\";\n// 1.新增\nimport { mapState, mapGetters, mapMutations, mapActions } from \"./helpers\";\nconst Vuex = {\n  Store,\n  install,\n  mapState,\n  mapGetters,\n  mapMutations,\n  mapActions,\n};\nexport default Vuex;\n```\n```js\nexport const mapState = normalizeNamespace((namespace, states) => {\n  const res = {};\n  normalizeMap(states).forEach(({ key, val }) => {\n    res[key] = function mappedState() {\n      let state = this.$store.state;\n      let getters = this.$store.getters;\n      if (namespace) {\n        const module = getModuleByNamespace(this.$store, \"mapState\", namespace);\n        if (!module) {\n          return;\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === \"function\"\n        ? val.call(this, state, getters)\n        : state[val];\n    };\n    res[key].vuex = true; // mark vuex getter for devtools 标记vuex getter用于devtools\n  });\n  return res;\n});\n\nexport const mapGetters = normalizeNamespace((namespace, getters) => {\n    const res = {};\n    normalizeMap(getters).forEach(({ key, val }) => {\n        val=namespace+val\n        res[key] = function mappedGetter() {\n            if (namespace && !getModuleByNamespace(this.$store, \"mapGetters\", namespace)) {\n                return;\n            }\n            if(!(val in this.$store.getters)){\n                console.error(`[vuex] unknown getter: ${val}`);\n                return;\n            }\n            return this.$store.getters[val];\n        };\n        res[key].vuex = true; // mark vuex getter for devtools\n    });\n    return res;\n});\nexport const mapMutations = normalizeNamespace((namespace, mutations) => {\n    const res = {};\n    normalizeMap(mutations).forEach(({ key, val }) => {\n        res[key] = function mappedMutation(...args) {\n            let commit = this.$store.commit;\n            if (namespace) {\n                const module = getModuleByNamespace(this.$store, \"mapMutations\", namespace);\n                if (!module) {\n                    return;\n                }\n                commit = module.context.commit;\n            }\n            return typeof val === \"function\"\n                ? val.apply(this, [commit].concat(args)) // val是函数,则调用val,并且进行数组合并 [ commit, ...args ]\n                : commit.apply(this.$store, [val].concat(args));\n        };\n    });\n    return res;\n});\n\nexport const mapActions = normalizeNamespace((namespace, actions) => {\n    const res = {};\n    normalizeMap(actions).forEach(({ key, val }) => {\n        res[key] = function mappedAction(...args) {\n            let dispatch = this.$store.dispatch;\n            if (namespace) {\n                const module = getModuleByNamespace(this.$store, \"mapActions\", namespace);\n                if (!module) {\n                    return;\n                }\n                dispatch = module.context.dispatch;\n            }\n            return typeof val === \"function\"\n                ? val.apply(this, [dispatch].concat(args))\n                : dispatch.apply(this.$store, [val].concat(args));\n        };\n    });\n    return res;\n});\n\n/**\n * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object\n * 中文: 重新绑定命名空间参数,并且返回一个简单的对象\n * @param {String} namespace\n * @return {Object}\n */\nexport function createNamespacedHelpers(namespace) {\n  return {\n    mapState: mapState.bind(null, namespace),\n    mapGetters: mapGetters.bind(null, namespace),\n    mapMutations: mapMutations.bind(null, namespace),\n    mapActions: mapActions.bind(null, namespace),\n  };\n}\n/* Normalize the map, 规范化映射为 key-val 形式\n * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]\n * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]\n * @param {Array|Object} map\n * @return {Array}\n */\nfunction normalizeMap(map) {\n  return Array.isArray(map)\n    ? map.map((key) => ({ key, val: key }))\n    : Object.keys(map).map((key) => ({ key, val: map[key] }));\n}\nfunction normalizeNamespace(fn) {\n  return (namespace, map) => {\n    if (typeof namespace !== \"string\") {\n      map = namespace;\n      namespace = \"\";\n    }\n    // 如果namespace不为空,并且不是以/结尾,则加上/,chartAt()返回指定索引位置的字符,从0开始.chartAt()不传返回第一个字符,如果超出范围,则返回空字符串\n    // chartAt()和str[0]是一样的,都是返回第一个字符,但是str.charAt(-1)返回'',str[-1]返回undefined\n    else if (namespace.charAt(namespace.length - 1) !== \"/\") {\n      namespace += \"/\";\n    }\n    return fn(namespace, map);\n  };\n}\nfunction getModuleByNamespace(store, helper, namespace) {\n  if (!namespace) {\n    return store._modules.root;\n  }\n  const module = store._modulesNamespaceMap[namespace];\n  if (!module) {\n    console.error(\n      `[vuex] module namespace not found in ${helper}(): ${namespace}`\n    );\n  }\n  return module;\n}\n```\n上面代码比较长,我们来分布解析下.\n\n### mapState\n我们知道,入参支持`namespace和数组/对象的`,namespace可以省略,所以我们需要先对mapState的参数处理.\n```js\nfunction normalizeNamespace(fn) {\n  return (namespace, map) => {\n    if (typeof namespace !== \"string\") {\n      map = namespace;\n      namespace = \"\";\n    }\n    // 如果namespace不为空,并且不是以/结尾,则加上/,chartAt()返回指定索引位置的字符,从0开始.chartAt()不传返回第一个字符,如果超出范围,则返回空字符串\n    // chartAt()和str[0]是一样的,都是返回第一个字符,但是str.charAt(-1)返回'',str[-1]返回undefined\n    else if (namespace.charAt(namespace.length - 1) !== \"/\") {\n      namespace += \"/\";\n    }\n    return fn(namespace, map);\n  };\n}\n```\n- fn就是咱们的mapState函数, 先判断namespace如果不是字符串,说明是直接传入的数组/对象, 所以`map=namespace;namespace = \"\"`\n- 判断namespace不是以/结尾,拼接上/\n\n```js\nexport const mapState = normalizeNamespace((namespace, states) => {\n  const res = {};\n  normalizeMap(states).forEach(({ key, val }) => {\n    res[key] = function mappedState() {\n      let state = this.$store.state;\n      let getters = this.$store.getters;\n      if (namespace) {\n        const module = getModuleByNamespace(this.$store, \"mapState\", namespace);\n        if (!module) {\n          return;\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === \"function\"\n        ? val.call(this, state, getters)\n        : state[val];\n    };\n    res[key].vuex = true; // mark vuex getter for devtools 标记vuex getter用于devtools\n  });\n  return res;\n});\n/* Normalize the map, 规范化映射为 key-val 形式\n * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]\n * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]\n * @param {Array|Object} map\n * @return {Array}\n */\nfunction normalizeMap(map) {\n  return Array.isArray(map)\n    ? map.map((key) => ({ key, val: key }))\n    : Object.keys(map).map((key) => ({ key, val: map[key] }));\n}\nfunction getModuleByNamespace(store, helper, namespace) {\n  if (!namespace) {\n    return store._modules.root;\n  }\n  const module = store._modulesNamespaceMap[namespace];\n  if (!module) {\n    console.error(\n      `[vuex] module namespace not found in ${helper}(): ${namespace}`\n    );\n  }\n  return module;\n}\n```\n- 我们知道,可以传数组/对象,所以我们通过`normalizeMap`将参数转化为数组对象`[{key,val}]`,只不过原来是数组转化后的key、val一样\n- 默认取出根节点的`state、getters`,如果有namespace,则根据namespace获取相应的module,module不存在则报错不存在, 存在则`state = module.context.state;getters = module.context.getters`,最后`typeof val === \"function\"? val.call(this, state, getters): state[val]`,判断是函数执行并以state、getters作为参数, 不是函数直接取值.\n\n### mapGetters\n```js\nexport const mapGetters = normalizeNamespace((namespace, getters) => {\n    const res = {};\n    normalizeMap(getters).forEach(({ key, val }) => {\n        val=namespace+val\n        res[key] = function mappedGetter() {\n            if (namespace && !getModuleByNamespace(this.$store, \"mapGetters\", namespace)) {\n                return;\n            }\n            if(!(val in this.$store.getters)){\n                console.error(`[vuex] unknown getter: ${val}`);\n                return;\n            }\n            return this.$store.getters[val];\n        };\n        res[key].vuex = true; // mark vuex getter for devtools\n    });\n    return res;\n});\n```\n- 有一点要注意,我们使用的时候`...mapGetters(moudleA,['myAge'])`,实际取的是`ModuleA/myAge`.我们看下存的数据结构就知道了.\n- 所以我们将`val=namespace+val`,前面已经namespace拼接过`/`,根据namespace判断不存在就报错, 存在直接返回`this.$store.getters[val]`. 注意为什么不能传对象就是这里,因为判断`val in this.$store.getters`,当为对象,val是函数,所以namespace+函数成了一个字符串肯定不存在,所以直接报错不存在.\n<img src=\"images/1.jpg\" width=\"80%\"/>\n  \n### mapMutations\n```js\nexport const mapMutations = normalizeNamespace((namespace, mutations) => {\n    const res = {};\n    normalizeMap(mutations).forEach(({ key, val }) => {\n        res[key] = function mappedMutation(...args) {\n            let commit = this.$store.commit;\n            if (namespace) {\n                const module = getModuleByNamespace(this.$store, \"mapMutations\", namespace);\n                if (!module) {\n                    return;\n                }\n                commit = module.context.commit;\n            }\n            return typeof val === \"function\"\n                ? val.apply(this, [commit].concat(args)) // val是函数,则调用val,并且进行数组合并 [ commit, ...args ]\n                : commit.apply(this.$store, [val].concat(args));\n        };\n    });\n    return res;\n});\n```\n- 默认commit是根的commit, 如果有namespace,根据namespace取出context.commit\n- 和上面一样, 只不过判断是函数,将commit当一个参数传过来,如果不是此时val就是type,直接调用commit(Store里面的commit = (type, payload)),将type当第一个参数传过去\n\n### mapActions\n```js\nexport const mapActions = normalizeNamespace((namespace, actions) => {\n    const res = {};\n    normalizeMap(actions).forEach(({ key, val }) => {\n        res[key] = function mappedAction(...args) {\n            let dispatch = this.$store.dispatch;\n            if (namespace) {\n                const module = getModuleByNamespace(this.$store, \"mapActions\", namespace);\n                if (!module) {\n                    return;\n                }\n                dispatch = module.context.dispatch;\n            }\n            return typeof val === \"function\"\n                ? val.apply(this, [dispatch].concat(args))\n                : dispatch.apply(this.$store, [val].concat(args));\n        };\n    });\n    return res;\n});\n```\n- 和上面mapMutations一样,就不讲了.\n\n## 总结\n- 要想直接模版中使用,而不是`$store.state.xx/$store.commit(type,payload)`,相当于定义一个数组返回多个computed函数/methods函数.\n- 因为入参有`(namespace,map)`,namespace有时候不传,所以在外面包裹一个`normalizeNamespace`函数判断namepsace不是字符串,直接map=namespace\n- 由于map可以传Array/Object,所以格式化参数统一为`[{key:val}]`\n- 对于mapState: 根据namespace从`store._modulesNamespaceMap[namespace]`取出module.context,然后判断入参是函数执行并以state、getters作为参数, 不是函数直接取值.\n- 对于mapGetters:因为store.getters.xx是以namespace+xx存储的,所以直接返回`store.getters.xx`\n- 对于mapMutations: 根据namespace取出context.commit,入参判断是函数,将commit当一个参数传出去,不是直接调用commit\n- 对于mapActions:和mapMutations一样\n- 注意,都会有根据namespace取module,不存在就报错, 取context只有mapGetters不用,直接从`store.getters.xx`取.因为前者是`MoudleA/age、ModuleA/ModuleA-A/age`这种形式,而conext是自己module的,如下图\n<img src=\"images/2.jpg\" width=\"80%\"/>\n\nstore.getters\n\n<img src=\"images/1.jpg\" width=\"80%\"/>\n  ","categories":["vue2源码","vuex"]},{"title":"2.vuex-plugins","url":"/ypf-blog/2024/02/06/vuex/2.plugins/","content":"## 基本用法\n\n```js\n  plugins: [\n    (store) => {\n      console.log(store); // store是当前的store实例\n      // 监听mutation,每次mutation之后都会触发\n      const plugin = store.subscribe((mutation, state) => {\n        // mutation是当前的mutation,结构为{type:'mutation的类型',payload:'mutation的参数'},state是当前最新的state\n        console.log(mutation, state); \n      });\n      setTimeout(() => {\n        plugin(); // 1s后取消监听,不会再触发\n      }, 1000);\n\n      // // 监听action,每次action之后都会触发\n      // store.subscribeAction((action,state)=>{\n      //   console.log(action,state);\n      // })\n    },\n  ],\n```\n- vuex插件原理很简单,插件就是一个函数,函数的参数只有一个Store\n- 我们可以通过`Store.subscribe`来监听每次mutation触发后的钩子函数,该函数返回一个函数,执行就会取消监听\n- 我们可以通过`store.subscribeAction`来监听action触发后的钩子函数该函数返回一个函数,执行就会取消监听\n  \n## 原理\n```js\nsrc/vuex/store.js\nexport class Store {\n  constructor(options) {\n    const { plugins = [] } = options;\n    ...\n    this._actionSubscribers=[] // 1. 存放所有action的订阅者\n    this._subscribes = []; // 1.存放所有mutation的订阅者\n    ...\n    // 2.插件注册\n    plugins.forEach((plugin) => plugin(this));\n  }\n  get state() {\n    return this._vm._data.$$state;\n  }\n  commit = (type, payload) => {\n    const entry = this._mutations[type];\n    if (!entry) {\n      console.error(\"没有这个mutation\");\n      return;\n    }\n    entry.forEach((fn) => fn(payload));\n    this._subscribes.forEach((fn) => fn({ type, payload }, this.state)); // 4.插件执行mutation钩子函数\n  };\n  // 3.注册mutation钩子函数\n  subscribe(fn,options) {\n    return genericSubscribe(fn, this._subscribes, options);\n  }\n  replaceState(state) {\n    this._vm._data.$$state = state;\n  }\n}\n// 插件注册\nfunction genericSubscribe(fn, subs, options) {\n  if (subs.indexOf(fn) < 0) {\n    options && options.prepend ? subs.unshift(fn) : subs.push(fn); // 如果是prepend,则插入到数组的最前面,否则插入到数组的最后面,用于控制订阅的顺序\n  }\n  // 返回一个取消订阅的函数,用于取消订阅,执行完后,从subs中删除\n  return () => {\n    const i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1); // 取消订阅, splice(开始索引,删除个数),返回删除的元素, 原数组发生改变\n    }\n  };\n}\n```\n上面代码很简单:\n- 使用`this._subscribes = []`和`this._actionSubscribers=[]`来分别存放mutation的订阅者和action的订阅者\n- 初始化 `new Vuex.store()`就会执行`plugins.forEach((plugin) => plugin(this));`返回Store作为参数\n- 当我们使用`Store.subscribe`就会触发genericSubscribe往this._subscribes加入钩子,根据prepend来控制执行顺序,返回一个取消订阅的函数\n- `Store.subscribeAction`类似\n- 当commit时候,就遍历`this._subscribes.forEach((fn) => fn({ type, payload }, this.state))`即可触发回调函数,返回类似下面结构, action类似\n  ```js\n  {\n    mutation:{type:'changeAge',payload:1}\n    state:{\n      age:2\n    }\n  }\n  ```\n\n## vuex-persistedstate简易实现原理\n```js\n  const persistedState=function(Store){\n    const  state=JSON.parse(localStorage.getItem('state'));\n    if(state){\n      Store.replaceState(state);\n    }\n    Store.subscribe((mutation,state)=>{\n      localStorage.setItem('state',JSON.stringify(state));\n    })\n  }\n```\n上面代码很简单,主要用到了`replaceState`用来直接替换state.\n```js\n replaceState(state) {\n    this._vm._data.$$state = state;\n  }\n```\n","categories":["vue2源码","vuex"]},{"title":"1.vuex原理","url":"/ypf-blog/2024/02/02/vuex/1.vuex原理/","content":"## 基本用法\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.min.js\"></script>\n    <!-- <script src=\"./dist/vue.js\"></script> -->\n    <script src=\"./dist/vuex.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      {{ $store.state.age }} {{ $store.getters.myAge }}\n      <button @click=\"$store.commit('changeAge', 1)\">commit同步</button>\n      <button @click=\"$store.dispatch('changeAge', 1)\">dispatch异步</button>\n      <div>moduleA</div>\n      state:{{ $store.state.ModuleA.age }} \n      getters:{{$store.getters['ModuleA/myAge'] }}\n      <button @click=\"$store.commit('ModuleA/changeAge', 1)\">commit同步</button>\n      <button @click=\"$store.dispatch('ModuleA/changeAge', 1)\">\n        dispatch异步\n      </button>\n    </div>\n  </body>\n  <script>\n    Vue.use(Vuex);\n    new Vue({\n      el: \"#app\",\n      store: new Vuex.Store({\n        // 存放数据,响应式,数据改变视图也会改变\n        state: {\n          age: 10,\n        },\n        // 计算属性,和computed原理一样,有缓存,依赖的数据变化才会重新计算\n        getters: {\n          myAge(state) {\n            return state.age + 20;\n          },\n        },\n        // 修改state的唯一方式,同步的\n        mutations: {\n          changeAge(state, payload) {\n            state.age += payload;\n          },\n        },\n        // 异步操作,提交mutation,然后再去修改state\n        actions: {\n          changeAge({ commit }, payload) {\n            setTimeout(() => {\n              commit(\"changeAge\", payload);\n            }, 100);\n          },\n        },\n        modules: {\n          ModuleA: {\n            namespaced: true,\n            state: {\n              age: 100,\n            },\n            getters: {\n              myAge(state) {\n                return state.age + 20;\n              },\n            },\n            mutations: {\n              changeAge(state, payload) {\n                state.age += payload;\n              },\n            },\n            actions: {\n              changeAge({ commit }, payload) {\n                setTimeout(() => {\n                  commit(\"changeAge\", payload);\n                }, 100);\n              },\n            },\n            modules: {\n              \"ModuleA-A\": {\n                namespaced: true,\n                state: {\n                  age: 100,\n                },\n                getters: {\n                  myAge(state) {\n                    return state.age + 20;\n                  },\n                },\n                mutations: {\n                  changeAge(state, payload) {\n                    state.age += payload;\n                  },\n                },\n                actions: {\n                  changeAge({ commit }, payload) {\n                    setTimeout(() => {\n                      commit(\"changeAge\", payload);\n                    }, 100);\n                  },\n                },\n              },\n            },\n          },\n          ModuleB: {\n            namespaced: true, \n            state: {\n              age: 100,\n            },\n            getters: {\n              myAge(state) {\n                return state.age + 20;\n              },\n            },\n            mutations: {\n              changeAge(state, payload) {\n                state.age += payload;\n              },\n            },\n            actions: {\n              changeAge({ commit }, payload) {\n                setTimeout(() => {\n                  commit(\"changeAge\", payload);\n                }, 100);\n              },\n            },\n          },\n        },\n      }),\n    });\n  </script>\n</html>\n```\n<img src=\"images/1.jpg\" width=\"80%\"/>\n\n上面我们展示了vuex的基本用法,接下来我们讲解下实现原理.\n\n## 原理\n\n### 新建index.js\n\n```js\n// src/vuex/index.js\nimport { Store } from \"./store\";\nimport { install } from \"./mixin\";\nconst Vuex = {\n  Store,\n  install,\n};\nexport default Vuex;\n```\n导出Vuex,其包含 `Store构造函数`和`install方法`\n- 我们通过`Vue.use()`使用install方法\n- 给new Vue({})传入`new Vuex.Store({})`初始化store\n\n### install\n```js\n// src/vuex/mixin.js\nexport let Vue;\nexport const install = function (_Vue) {\n  // 保存Vue的构造函数,在install中使用\n  Vue = _Vue;\n  // 将store注入到每个组件实例上\n  Vue.mixin({\n    beforeCreate() {\n      // 判断是否是根组件\n      if (this.$options && this.$options.store) {\n        // 根组件\n        this.$store = this.$options.store;\n      } else {\n        // 子组件\n        this.$store = this.$parent && this.$parent.$store;\n      }\n    }\n  });\n};\n```\n我们在vue中模版中,经常直接使用`$store.state.xx`,所以我们需要给`vue绑定$store`.\n- 使用Vuex.mixin混入beforeCreate方法,我们知道该方法的this指向vm.\n- 需要判断是否options上传入了store\n  - 传入的话直接`this.$store=this.$options.store;`, 一般vue都会只有一个new Vue,所以此时<App/>初始化绑定了$store,而子组件都不会再单独传一个$store,如果传了就会用子组件的\n  - 没有传入的话,直接绑定父级的$store`this.$store = this.$parent && this.$parent.$store;`\n\n**这样在vue无论模版还是script中,都可以获取$store**\n\n### Store类\n\n```js\nexport class Store {\n  constructor(options) {\n    const { plugins = [] } = options;\n    //  1. 初始化\n    this._actions = Object.create(null); // 存放所有的action,格式为{namespace+type:[fn,fn]}\n    this._mutations = Object.create(null); // 存放所有的mutation,格式为{namespace+type:[fn,fn]}\n    this._wrappedGetters = Object.create(null); // 存放所有的getter,格式为{namespace+type:[fn,fn]}\n    this._committing = false; // 是否正在提交mutation\n    this._subscribes = []; // 存放所有的订阅者\n    console.group(\"将store格式化为树结构\");\n    this._modules = new ModuleCollection(options); // 1.递归注册模块,格式化为树结构\n    console.log(this._modules, \"格式化后的结果\");\n    console.groupEnd();\n    // 2.递归注册模块,将mutation,action,getter push到对应的数组中_mutations,_actions,_wrappedGetters\n    // 并且将state变成响应式,并且将getters和state关联起来\n    // 并且将每个模块的state拼接上path,然后设置到父模块的state中\n    // 并且计算出当前模块的命名空间,在订阅的时候每个模块都有一个命名空间,用于区分不同的模块,如: a/changeAge\n    // 并且生成当前模块的上下文\n    // 并且递归注册子模块\n    // 参数:store,路径path,当前模块,根state\n    installModule(this, [], this._modules.root, options.state);\n    // 3.处理计算属性,将_wrappedGetters中的属性定义到getters中;\n    // 同时处理state,将state变成响应式,并且将getters和state关联起来\n    resetStoreVM(this, options);\n    // 4.安装插件\n    plugins.forEach((plugin) => plugin(this));\n  }\n  get state() {\n    return this._vm._data.$$state;\n  }\n  commit = (type, payload) => {\n    const entry = this._mutations[type];\n    if (!entry) {\n      console.error(\"没有这个mutation\");\n      return;\n    }\n    entry.forEach((fn) => fn(payload));\n  };\n  dispatch = (type, payload) => {\n    const entry = this._actions[type];\n    if (!entry) {\n      console.error(\"没有这个action\");\n      return;\n    }\n    const result =\n      entry.length > 1\n        ? Promise.all(entry.map((fn) => fn(payload)))\n        : entry[0](payload);\n    return result;\n  };\n}\n```\n1. 定义`this._actions`、`this._mutations`、`this._wrappedGetters`用来将子module的方法都放到一起.\n2. 通过`this._modules = new ModuleCollection(options)`将store递归转化为树结构\n```js\nconst root = {\n  _raw: rootModule, // 当前模块的原始数据\n  _children: {}, // 子module\n  state: {}, // 当前模块的数据\n};\n```\n\n#### ModuleCollection类\n```js\nimport { forEachValue } from \"../utils\";\nimport Module from \"./module\";\n\nexport class ModuleCollection {\n  constructor(options) {\n    this.root = null; // 格式化后的结果\n    this.register([], options); // 注册模块\n  }\n  getNameSpace(path) {\n    let root = this.root;\n    // 累加,如果有命名空间,则加上/,没有则不加,最后返回\n    return path.reduce((namespace, key) => {\n      root = root._children[key];\n      return namespace + (root._raw.namespaced ? key + \"/\" : \"\");\n    }, \"\");\n  }\n  register(path, rootModule) {\n    const newModule = new Module(rootModule);\n    // let newModule = {\n    //   _raw: rootModule, // 当前模块\n    //   _children: {}, // 子模块\n    //   state: rootModule.state, // 当前模块的state\n    // };\n    if (path.length === 0) {\n      this.root = newModule;\n    } else {\n      // slice(a,b) 截取数组,从索引a开始,到索引b结束,不包含索引b, [0,-1]表示从索引0开始,到索引-1结束,不包含索引-1,即不包含最后一个元素\n      // 找到当前模块的父模块\n      let parent = path.slice(0, -1).reduce((prev, cur) => {\n        return prev._children[cur];\n      }, this.root);\n      // 将当前模块添加到父模块的_children中\n      parent._children[path[path.length - 1]] = newModule;\n    }\n    if (rootModule.modules) {\n      forEachValue(rootModule.modules, (module, moduleName) => {\n        console.group(`格式化${moduleName}`)\n        this.register(path.concat(moduleName), module); // 递归注册模块\n        console.groupEnd()\n      });\n    }\n  }\n}\n```\n- 将store转换树结构: 通过`this.register([], options); `实现,第一个参数是`path数组,初始化是[]`,第二个是store的入参.`this.root=null`用于存储转换后的树结果\n- 定义树基本结构: `const newModule = new Module(rootModule)`类\n- 递归: \n    - 第一次path是[],所以`this.root = newModule`将第一层转换为树结构\n    - 然后判断有modules, 递归注册,此时第一个参数为`path.concat(moduleName)`,第二个参数为`module`\n    - 通过reduce循环获取当前层级(初始值是this.root),然后通过`parent._children[path[path.length - 1]] = newModule`就完成了所有层级转换为树结构\n\n#### Module类\n\n```js\nimport { forEachValue } from \"../utils\";\nexport default class Module {\n  constructor(options) {\n    this._raw = options; // 当前模块的原始数据\n    this._children = {}; // 子模块\n    this.state = options.state; // 当前模块的state\n  }\n  get namespaced() {\n    return !!this._raw.namespaced;\n  }\n  getChild(key) {\n    return this._children[key];\n  }\n  addChild(key, module) {\n    this._children[key] = module;\n  }\n  forEachMutation(fn) {\n    if (this._raw.mutations) {\n      Object.keys(this._raw.mutations).forEach((key) => {\n        fn(this._raw.mutations[key], key);\n      });\n    }\n  }\n  forEachAction(fn) {\n    if (this._raw.actions) {\n      Object.keys(this._raw.actions).forEach((key) => {\n        fn(this._raw.actions[key], key);\n      });\n    }\n  }\n  forEachGetter(fn) {\n    if (this._raw.getters) {\n      Object.keys(this._raw.getters).forEach((key) => {\n        fn(this._raw.getters[key], key);\n      });\n    }\n  }\n  forEachChild(fn) {\n    Object.keys(this._children).forEach((key) => {\n      fn(this._children[key], key);\n    });\n  }\n}\n```\n- 定义了树的基本结构\n\n#### reduce方法\nreduce()方法可以搞定的东西特别多，就是循环遍历能做的，reduce都可以做.\n```js\narray.reduce((prev, cur, index, arr)=> {\n}, initialValue)\n```\n- prev 上一次调用回调返回的值，或者是提供的初始值（initialValue））\n- cur (当前数组循环到的元素)\n- index (当前数组循环到的元素的索引)\n- 调用reduce的数组\n- initialValue (初始值)\n  - 没有初始值: 从第一项开始循环,即index=1,prev=第0项,cur=第1项\n  - 有初始值: 从第0项开始循环,即index=0,prev=初始值,cur=第0项\n- 每次return的值就是下次循环的prev\n```js\n const arr=[1,2,3,4]\n const result=arr.reduce((prev,cur,index,arr)=>{\n    console.log(prev,cur,index,arr);\n    return prev+cur\n  })\n console.log(result); // 10\n  // 1 2 1 (4) [1, 2, 3, 4]\n  // 3 3 2 (4) [1, 2, 3, 4]\n  // 6 4 3 (4) [1, 2, 3, 4]\n```\n```js\n const arr=[1,2,3,4]\n const result=arr.reduce((prev,cur,index,arr)=>{\n    console.log(prev,cur,index,arr);\n    return prev+cur\n },6)\n console.log(result); //16\n  // 6 1 0 (4) [1, 2, 3, 4]\n  // 7 2 1 (4) [1, 2, 3, 4]\n  // 9 3 2 (4) [1, 2, 3, 4]\n  // 12 4 3 (4) [1, 2, 3, 4]\n```\n转换后的结果\n<img src=\"images/2.jpg\" width=\"80%\"/>\n\n#### 执行installModule方法是主要功能\n```js\nconst installModule = (store, path, module, rootState) => {\n  // 判断是否是根模块\n  if (path.length > 0) {\n    // 不是根模块,找到当前模块的父模块\n    let parent = path.slice(0, -1).reduce((root, current) => {\n      return root[current];\n    }, rootState);\n    Vue.set(parent, path[path.length - 1], module.state);\n  }\n  // 计算出当前模块的命名空间,在订阅的时候每个模块都有一个命名空间,用于区分不同的模块,如: a/changeAge\n  // 思路:从根模块开始,一层一层的找到当前模块的父模块,然后拼接上当前模块的名称\n  let namespace = store._modules.getNameSpace(path);\n  const local = (module.context = makeLocalContext(\n    // 生成当前模块的上下文\n    store,\n    namespace,\n    path\n  ));\n  // 注册mutation\n  module.forEachMutation((mutation, key) => {\n    store._mutations[namespace + key] = store._mutations[namespace + key] || [];\n    store._mutations[namespace + key].push((payload) => {\n      mutation.call(store, local.state, payload);\n    });\n  });\n  // 注册action\n  module.forEachAction((action, key) => {\n    store._actions[namespace + key] = store._actions[namespace + key] || [];\n    store._actions[namespace + key].push((payload) => {\n      let res = action.call(store, local, payload);\n      const isPromise = res && typeof res.then === \"function\";\n      if (!isPromise) {\n        res = Promise.resolve(res);\n      }\n      return res;\n    });\n  });\n  // 注册getter\n  module.forEachGetter((getter, key) => {\n    if (store._wrappedGetters[namespace + key]) {\n      return;\n    }\n    // wrappedGetter的作用是包裹原始的getter,并且传入当前模块的state,当前模块的getters,根state,根getters\n    store._wrappedGetters[namespace + key] = function wrappedGetter(store) {\n      return getter(local.state, local.getters, store.state, store.getters); // 传入当前模块的state,当前模块的getters,根state,根getters\n    };\n  });\n  // 递归注册子模块\n  module.forEachChild((child, key) => {\n    installModule(store, path.concat(key), child, rootState);\n  });\n};\n```\n```js\nfunction makeLocalContext(store, namespace, path) {\n  let noNamespace = namespace === \"\";\n  let local = {\n    dispatch: noNamespace\n      ? store.dispatch\n      : (type, payload) => {\n          type = namespace + type;\n          return store.dispatch(type, payload);\n        },\n    commit: noNamespace\n      ? store.commit\n      : (type, payload) => {\n          type = namespace + type;\n          return store.commit(type, payload);\n        },\n  };\n  Object.defineProperties(local, {\n    state: {\n      get: () => {\n        let state = store.state;\n        return path.reduce((root, current) => {\n          return root[current];\n        }, state);\n      },\n    },\n  });\n  return local;\n}\n```\n```js\nfunction resetStoreVM(store, options) {\n  const computed = {};\n  store.getters = {};\n  forEachValue(store._wrappedGetters, (fn, key) => {\n    computed[key] = () => fn(store.state);\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key],\n    });\n  });\n  store._vm = new Vue({\n    data: {\n      $$state: options.state,\n    },\n    computed,\n  });\n}\n```\n##### 将module的state拼接上path\n将每个模块的state拼接上path,然后设置到父模块的state中,结果如下图\n  ```js\n    // 判断是否是根模块\n  if (path.length > 0) {\n    // 不是根模块,找到当前模块的父模块\n    let parent = path.slice(0, -1).reduce((root, current) => {\n      return root[current];\n    }, rootState);\n    Vue.set(parent, path[path.length - 1], module.state);\n  }\n  ```\n  <img src=\"images/3.jpg\" width=\"80%\"/>\n\n##### 计算出每个module的命名空间\n  ```js\n  let namespace = store._modules.getNameSpace(path);\n  ```\n  ```js\n  // src/vuex/moudle/index.js\n  getNameSpace(path) {\n    let root = this.root;\n    // 累加,如果有命名空间,则加上/,没有则不加,最后返回\n    return path.reduce((namespace, key) => {\n      root = root._children[key];\n      return namespace + (root._raw.namespaced ? key + \"/\" : \"\");\n    }, \"\");\n  }\n  ```\n  <img src=\"images/4.jpg\" width=\"80%\"/>\n\n##### 为每个module绑定一个context上下文\n为module绑定一个context属性即生成每个模块的上下文store\n  ```js\n  // 生成当前模块的上下文\n  const local = (module.context = makeLocalContext(store, namespace, path));\n  console.log(local, \"local\");\n  // 生成当前模块的上下文\n  // - 重写dispatch,commit,拼接上命名空间\n  // - 对于state,通过Object.defineProperty将state变成响应式\n  // - 将dispatch、commit、state返回为一个对象local\n  function makeLocalContext(store, namespace, path) {\n    let noNamespace = namespace === \"\";\n    let local = {\n      dispatch: noNamespace\n        ? store.dispatch\n        : (type, payload) => {\n            type = namespace + type;\n            return store.dispatch(type, payload);\n          },\n      commit: noNamespace\n        ? store.commit\n        : (type, payload) => {\n            type = namespace + type;\n            return store.commit(type, payload);\n          },\n    };\n    //  Object.defineProperties和Object.defineProperty的区别是前者可以定义多个属性,后者只能定义一个属性\n    Object.defineProperties(local, {\n      state: {\n        get: () => {\n          let state = store.state;\n          return path.reduce((root, current) => {\n            return root[current];\n          }, state);\n        },\n      },\n    });\n    return local;\n  }\n  ```\n\n<img src=\"images/5.jpg\" width=\"80%\"/>\n\n##### 将mutation,action,getter push到对应的数组_mutations,_actions,_wrappedGetters中以及递归执行installModule注册子模块\n  ```js\n  // 注册mutation\n  module.forEachMutation((mutation, key) => {\n    store._mutations[namespace + key] = store._mutations[namespace + key] || [];\n    store._mutations[namespace + key].push((payload) => {\n      mutation.call(store, local.state, payload);\n    });\n  });\n  // 注册action\n  module.forEachAction((action, key) => {\n    store._actions[namespace + key] = store._actions[namespace + key] || [];\n    store._actions[namespace + key].push((payload) => {\n      let res = action.call(store, local, payload);\n      const isPromise = res && typeof res.then === \"function\";\n      if (!isPromise) {\n        res = Promise.resolve(res);\n      }\n      return res;\n    });\n  });\n  // 注册getter\n  module.forEachGetter((getter, key) => {\n    if (store._wrappedGetters[namespace + key]) {\n      return;\n    }\n    // wrappedGetter的作用是包裹原始的getter,并且传入当前模块的state,当前模块的getters,根state,根getters\n    store._wrappedGetters[namespace + key] = function wrappedGetter(store) {\n      return getter(local.state, local.getters, store.state, store.getters); // 传入当前模块的state,当前模块的getters,根state,根getters\n    };\n  });\n  // 递归注册子模块\n  module.forEachChild((child, key) => {\n    installModule(store, path.concat(key), child, rootState);\n  });\n  ```\n#### 通过new Vue实现视图数据响应更新,将state变成响应式\n```js\n    // 处理计算属性,将_wrappedGetters中的属性定义到getters中;\n    // 同时处理state,将state变成响应式,并且将getters和state关联起来\n  resetStoreVM(this, options);\n  function resetStoreVM(store, options) {\n    const computed = {};\n    store.getters = {};\n    forEachValue(store._wrappedGetters, (fn, key) => {\n      computed[key] = () => fn(store.state);\n      Object.defineProperty(store.getters, key, {\n        get: () => store._vm[key],\n      });\n    });\n    console.log(options.state, \"options.state\");\n    // new一个Vue对象来实现数据的“响应式化”，运用Vue.js内部提供的数据双向绑定功能来实现store的数据与视图的同步更新.\n    // vuex是单向数据流\n    store._vm = new Vue({\n      data: {\n        $$state: options.state,\n      },\n      computed,\n    });\n  }\n```\n- 当我们访问`$store.state.xx`时即访问`Store的get state() {return this._vm._data.$$state;}`\n- 上面遍历store._wrappedGetters塞入computed中,同时通过Object.defineProperty在store.getters上绑定`store._vm[key]`\n- 最后通过new Vue传入state、computed来实现响应(数据改动,视图更新)\n\n## 总结\n1. Vuex导出install方法和Store类, 其中install提供mixin的beforeCreate往this.$store中赋值option.store,这样Vue.use就会使用install方法\n2. 我们在页面中调用`new Vuex.Store({options})`方法,会先通过`this._modules = new ModuleCollection(options)`递归将options转换为树结构\n   ```js\n   const root = {\n    _raw: rootModule, // 当前模块的原始数据\n    _children: {}, // 子module\n    state: {}, // 当前模块的数据\n  };\n   ```\n3.传入树结构和初始化`path=[]`,递归执行`installModule`方法,遍历每个module.这样递归的时候,path存储每个module的命名空间,然后根据namespace拼接为state的key,也变成树结构.\n```js\nstate:{\n  age:10,\n  ModuleA:{\n    age:10,\n    ModuleA-A:{\n      age:10,\n    }\n  },\n  ModuleB:{\n    age:10,\n  },\n}\n```\n4.为每个module都增加一个context属性,表示当前module的上下文,其包含(state、mutations、actions),目的是各个模块都有自己的方法(经过拼接namespace重写)\n5.然后定义`this._actions、this._mutations、this._wrappedGetters`用来存放包括modules的所有方法.因为上面是递归遍历module树,所以拼接好namespace,循环往数组后里面push\n6.当我们访问$store.state.xx时即访问Store的get state() {return this._vm._data.$$state;}\n7.遍历store._wrappedGetters塞入computed中,同时通过Object.defineProperty在store.getters上绑定store._vm[key],访问store.getters.xx即访问store._vm[key]\n8. 通过new Vue传入state、computed存入`store.vm`,结合67步, 就可以实现响应(数据改动,视图更新) \n\n## 疑问解答\n\n### mutation同步,action异步?\n为什么在mutation中不应该执行异步操作?而实际在里面放入异步操作貌似也没什么问题.参考[vuex官网](https://vuex.vuejs.org/zh/guide/mutations.html#mutation-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0).\n- 在Vuex中，mutation是唯一用于更改状态的途径。每个mutation执行完成后，都会对应到一个新的状态变更。这种同步的特性使得Vue DevTools谷歌插件能够轻松地追踪每一个状态的变化。它能够在每次mutation被调用时打个快照，形成一个状态变更的历史记录。这种机制对于调试和性能优化都非常有帮助。\n- 如果mutation支持异步操作，就会引发一个问题：我们将无法精确知晓状态是何时更新的。异步操作的执行时间是不确定的，这使得状态变更的时机变得模糊不清。这样一来，在调试过程中就难以准确追踪状态的变化，给开发者带来不小的困扰。所以将异步操作以dispath分层\n\n### 多个action, promise.all\n```js\n\n new Vue({\n      el: \"#app\",\n      store: new Vuex.Store({\n        // 存放数据,响应式,数据改变视图也会改变\n        state: {\n          age: 10,\n        },\n        // 计算属性,和computed原理一样,有缓存,依赖的数据变化才会重新计算\n        getters: {\n          myAge(state) {\n            return state.age + 20;\n          },\n        },\n        // 修改state的唯一方式,同步的\n        mutations: {\n          changeAge(state, payload) {\n            state.age += payload;\n          },\n        },\n        // 异步操作,提交mutation,然后再去修改state\n        actions: {\n          changeAge({ commit }, payload) {\n            return new Promise((resolve, reject) => {\n                  setTimeout(() => {\n                    resolve();\n                  }, 1000);\n                });\n       \n          },\n        },\n        modules: {\n          ModuleB: {\n            state: {\n              age: 100,\n            },\n            getters: {\n              myAge(state) {\n                return state.age + 20;\n              },\n            },\n            mutations: {\n              changeAge(state, payload) {\n                state.age += payload;\n              },\n            },\n            actions: {\n              changeAge({ commit }, payload) {\n                return new Promise((resolve, reject) => {\n                  setTimeout(() => {\n                    resolve();\n                  }, 2000);\n                });\n              },\n            },\n          },\n        },\n      }),\n      mounted() {\n        console.log(this, \"root\");\n        // this.$store.commit(\"add\");\n      },\n      methods:{\n        test(){\n          console.time('dispatch异步');\n          this.$store.dispatch('changeAge',1).then(()=>{\n            // console.log('dispatch异步');\n            console.timeEnd('dispatch异步');\n          })\n        }\n      }\n    });\n```\n上面代码,moduleB是没有namespace的,所以就是全局的,我们可以看到Store中会有2个\n\n<img src=\"images/6.jpg\" width=\"80%\"/>\n\n- 当我们执行test函数时候,2s后才会打印结果,原理是Promise.all全部结束后才会返回.\n- 如果不是promise,则push的时候会被包装成promise\n\n","categories":["vue2源码","vuex"]},{"title":"13.vue.use","url":"/ypf-blog/2024/02/02/vue2源码/13.vue.use/","content":"## 用法\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <!-- <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.min.js\"></script> -->\n    <script src=\"./dist/vue.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <div class=\"33\" style=\"color: red\"></div>\n    </div>\n  </body>\n  <script>\n    //    Vue.use插件\n    const myPlugin = {\n      install(Vue, ...reset) {\n        console.log(Vue, reset);\n        Vue.mixin({\n          created() {\n            console.log(\"插件\");\n          },\n        });\n      },\n    };\n    const myPlugin1 = {\n      install(Vue, ...reset) {\n        console.log(Vue, reset);\n        Vue.mixin({\n          created() {\n            console.log(\"插件1\");\n          },\n        });\n      },\n    };\n    Vue.use(myPlugin,1,2,3);\n    Vue.use(myPlugin1,4,5,6);\n    Vue.use(myPlugin1,7,8,9);\n    const vm = new Vue({\n      el: \"#app\",\n    });\n    console.log(vm);\n    console.dir(Vue);\n  </script>\n</html>\n```\n- `Vue.use(plugin,a,b,c,d...)`是Vue的全局方法,一般我们使用该方法给Vue 添加全局功能,如指令、混入、修改Vue.prototype等\n- 参数:第一个是插件plugin(可以为对象/函数,如果有install方法优先使用),剩下插件的参数,可以有多个\n- 插件只会被注册一次(`_installedPlugins会判断`),即使多次调用`vue.use`也会只会执行第一次.上面我们对myPlugin1使用了2次,只打印了第一次 **456**\n\n上面代码打印下,\n<img src=\"images/1.jpg\" width=\"80%\"/>\n\n## 原理\n\n```js\n修改src/global-api/index.js\nexport function initGlobalAPI(Vue) {\n  ...\n  // 1.新增use方法\n  Vue.use = function (plugin) {\n    const installedPlugins =\n      this._installedPlugins || (this._installedPlugins = []); // 存放已经安装的插件\n    if (installedPlugins.indexOf(plugin) > -1) {\n      // 如果已经安装过了,则直接返回this,目的是为了链式调用\n      return this;\n    }\n    const args = Array.prototype.slice.call(arguments, 1); // 获取参数,如Vue.use(plugin,1,2,3),则args=[1,2,3]\n    args.unshift(this); // 将Vue放到第一个参数,如Vue.use(plugin,1,2,3),则args=[Vue,1,2,3]\n    if (typeof plugin.install === \"function\") {\n      // 如果plugin是一个对象,并且有install方法,则调用install方法\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === \"function\") {\n      // 如果plugin是一个函数,则直接调用\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin); // 将插件放到已安装插件中\n    return this; // 返回this,目的是为了链式调用\n  };\n}\n```\n\n## 总结\n\n### slice\n- `arr.slice(start,end)` 返回一个新的数组,包含从 start 到 end （不包括该元素）\n- 如果省略 end ，那么 slice 从 start 一直到数组末尾\n- 原数组不会被修改\n  \n### arguments\n- arguments是一个伪数组,没有slice方法,所以需要借用`Array.prototype.slice.call(arguments, 1)`来获取参数\n- 也可以先通过`Array.prototype.slice.call(arguments)`将arguments转换为数组,然后`slice(1)`即可.\n- 下面是this指向回顾\n```js\n//                  正常模式下              严格模式下\na.call();           //window               undefined\na.call(null);       //window               null\na.call(undefined);  //window               undefined\na.call(1);          //Number{1}            1\na.call('1');         //String{'1'}           '1'\na.call(true);       //Boolean{true}        true\na.call(b);          //function b(){}       function b(){}\na.call(obj);        //Object               Object\n```\n### 对象比较\n```js\nlet obj1={a:1}\nlet obj2={a:2}\nconst arr=[obj1,obj2]\nconsole.log(obj1===obj1) // true 指向同一内存地址\nconsole.log(obj1===obj2) // false 不是一个内存地址,==也是false\nconsole.log(arr.indexOf(obj1)>-1) // true\nconsole.log(arr.findIndex(item=>item===obj1)) // 0 指向同一内存地址\n```\n**同理任何类型都符合上述规律**\n\n### 解析原理\n1. 定义`installedPlugins`,先通过`indexOf`判断plugin是否存在\n```js\nconst installedPlugins =\n  this._installedPlugins || (this._installedPlugins = []); // 存放已经安装的插件\nif (installedPlugins.indexOf(plugin) > -1) {\n  // 如果已经安装过了,则直接返回this,目的是为了链式调用\n  return this;\n}\n```\n2. arguments是一个伪数组,没有slice方法,所以需要借用`Array.prototype.slice.call(arguments, 1)`来获取参数,然后通过`unshift(this)`将Vue放到数组第一项\n```js\n const args = Array.prototype.slice.call(arguments, 1); // 获取参数,如Vue.use(plugin,1,2,3),则args=[1,2,3]\n args.unshift(this); // 将Vue放到第一个参数,如Vue.use(plugin,1,2,3),则args=[Vue,1,2,3]\n```\n3. 判断plugin有install就执行install里面方法,将上面args传过去.如果是函数直接调用\n```js\n   if (typeof plugin.install === \"function\") {\n      // 如果plugin是一个对象,并且有install方法,则调用install方法\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === \"function\") {\n      // 如果plugin是一个函数,则直接调用\n      plugin.apply(null, args);\n    }\n```\n4.将plugin放到`已安装插件数组installedPlugins`中,最后`return this`用来链式调用\n\n```js\n installedPlugins.push(plugin); // 将插件放到已安装插件中\n return this; // 返回this,目的是为了链式调用\n```","categories":["vue2源码"]},{"title":"基础-8","url":"/ypf-blog/2024/01/25/gwy/LFTT/基础-8/","content":"## 案例\n### 案例1\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-1.jpg\" width=\"50%\"/>\n\n案例特点:图形相交\n考点:相交图形的边数、图形特征(纯曲、纯直)\n练习题1: **相交图形的边数**\n规律:分别是343344,所以选C\n\n### 案例2\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-2.jpg\" width=\"50%\"/>\n\n案例特点:图形外有2个圆圈\n考点:圆圈连线\n练习题1: **连线是体/面对角线**\n所以选A\n\n\n### 案例3\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-3.jpg\" width=\"50%\"/>\n\n案例特点:乍一看以为是移动规律,但是移动规律一般不考分组\n练习题1: **分离、相邻**\n156左边的圆圈相邻,234右边的圆圈相邻,所以选D\n\n### 案例4\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-4.jpg\" width=\"50%\"/>\n\n案例特点:看到纯文字、字母、数字等,要想到空间、部分、横竖线条数量、最大/最小封闭/开放\n练习题1: **最大最小数字与形状**\n126形状最大的数字最大,345状最大的数字最小\n\n### 案例5\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-5.jpg\" width=\"50%\"/>\n\n案例特点:一笔画、交点\n练习题1: **一笔画**\n分别是221121,所以选B\n\n### 案例6\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-6.jpg\" width=\"50%\"/>\n\n案例特点:复杂程度不单调(逻辑运算)\n练习题1: **轮廓数量-内部线条数**\n分别是34 44 45 55 45 66,所以选D\n\n### 案例7\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-7.jpg\" width=\"50%\"/>\n\n案例特点:切点数、切线数、交点数\n练习题1: **切点数**\n分别是221211,所以选C\n\n### 案例8\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-8.jpg\" width=\"50%\"/>\n\n案例特点:封闭/开放\n规律1: **封闭/开放**\n145开放236封闭,所以选C\n规律1: **整体/分离**\n135整体246分离\n\n### 案例9\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-9.jpg\" width=\"50%\"/>\n\n案例特点:对称轴位置\n练习题1: **对称轴方向**\n146一组,235一组,所以选D\n\n### 案例10\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-10.jpg\" width=\"50%\"/>\n\n案例特点:**外直内曲/外曲内直**\n124外直内曲,356外曲内直,所以选A\n\n### 案例11\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/8-11.jpg\" width=\"50%\"/>\n\n案例特点:多要素做差、复杂程度不单调、如果单要素考直角数量、 轮廓上交点\n考点:**直角数**,\n分别是454455,所以选C","categories":["gwy","LFTT"]},{"title":"基础-7","url":"/ypf-blog/2024/01/24/gwy/LFTT/基础-7/","content":"## 案例\n### 案例1\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-1.jpg\" width=\"50%\"/>\n\n考点:几组平行线,常见的图案 `Z N H I M、梯形、平行四边形、长方形等`,要想到考几组平行线(注意: 数几组一般是,2条线数过了,就不算了(不能说这条线和多条线平行就算多组))\n练习题1: **平行线**\n规律:都是 1 2 3组平线线,所以选C\n\n### 案例2\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-2.jpg\" width=\"50%\"/>\n\n案例特点:阴影部分都是直角三角形\n考点:阴影面积(可以画辅助线好判断)\n练习题1: **阴影面积**\n规律:阴影面积都占1/4,所以选D\n\n### 案例3\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-3.jpg\" width=\"50%\"/>\n\n案例特点:空间形状相似\n考点:空间形状、空间数量(如相同形状的空间数量)\n练习题1: **相同形状的空间数量**\n规律:三角形数量为434334分组,或者四边形分组也可以\n---\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-3-1.jpg\" width=\"50%\"/>\n\n练习题2: **空间数量**\n规律: 分别是699966来分组\n\n### 案例4\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-4.jpg\" width=\"50%\"/>\n\n案例特点:纯封闭、T字形、对称\n考点:空间形状、对称、直角数量\n练习题1: **对称(对称轴位置)**\n规律:对称轴和会和图形的一条线重合,所以选D\n\n### 案例5\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-5.jpg\" width=\"50%\"/>\n\n案例特点:出头、类圆曲线\n考点:曲直交点\n练习题1: **曲直交点(曲线与直线交点数)**\n规律:分别是23423?所以选C\n\n### 案例6\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-6.jpg\" width=\"50%\"/>\n\n案例特点:阴影数量一致、6边形轮廓\n考点:内外环移动\n练习题1: **内外环移动**\n规律:外环是顺时针每次移动3格,内环是逆时针每次移动2格,所以选D\n\n### 案例7\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-7.jpg\" width=\"50%\"/>\n\n案例特点:存在空白缺口位置\n考点:缺口位置移动(可以把缺口画个三角形占位)\n练习题1: **缺口位置移动**\n规律:第一个缺口顺时针外环每次移动2格,第二个缺口顺时针外环每次移动1格,所以选A\n\n### 案例8\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-8.jpg\" width=\"50%\"/>\n\n案例特点:坐标轴\n考点:交点数、上下位置关系、还有之前讲过的与坐标轴形成的直角数\n练习题1: **上下空间数量逻辑运算**\n规律:看交点数量,分别是023 345 56?没有规律,\n    所以再看上下空间数量,分别是00 01 11; 11 12 22; 22 32 ?, 所以做差选C\n\n### 案例9\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-9.jpg\" width=\"50%\"/>\n\n案例特点:出头\n考点:交点数、一笔画、曲直交点、内部交点、轮廓上交点\n练习题1: **一笔画**\n规律:笔画数分别是111 222\n---\n练习题2: **一笔画**\n规律:笔画数分别是211 122分组\n\n### 案例10\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/7-10.jpg\" width=\"50%\"/>\n\n案例特点:图形分离\n考点:元素种类、曲直元素、空间位置\n练习题1: **元素种类**\n规律:按行分别是1种元素、2种元素、3种元素,所以选D\n---\n练习题2: **元素种类**\n规律:245都是相同大小元素,136都是不同元素\n\n## 总结\n- 看到平行线、`Z N H I M、梯形、平行四边形、长方形等`,要想到考几组平行线\n- 看到阴影三角形要想到阴影面积\n- 看到空间形状相似的图形,要想到相同空间的数量、或者空间数量\n- 看到对称要想到对称轴位置、数量\n- 看到T字形要想到直角数\n- 看到曲直图形,要想到曲直交点\n- 看到阴影图形且轮廓一致,要想到内外环移动\n- 看到空白缺口,可以把空白填充一个三角形,要想到空白位置移动\n- 看到坐标轴要想到线条与坐标轴交点、上下空间数、与坐标轴形成的直角数\n- 看到图形分离要想到相同元素种类","categories":["gwy","LFTT"]},{"title":"12.组件component和Vue.extend","url":"/ypf-blog/2024/01/18/vue2源码/12.组件component和Vue.extend/","content":"## 用法\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <!-- <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.min.js\"></script> -->\n    <script src=\"./dist/vue.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <div class=\"33\" style=\"color:red\"></div>\n      <my-component></my-component>\n      <my-component1></my-component1>\n    </div>\n  </body>\n  <script>\n    // 创建全局组件 Vue.component\n    Vue.component(\"my-component\", {\n      template: \"<div>全局组件</div>\",\n    });\n      // 或者\n    Vue.component(\"my-component1\", Vue.extend({\n      template: \"<div>全局组件1</div>\",\n    }));\n    const vm = new Vue({\n      el: \"#app\",\n      components: {\n        \"my-component\": {\n          template: \"<div>局部组件</div>\",\n        },\n      },\n    });\n  </script>\n</html>\n\n```\n1. Vue可以通过`Vue.componet`创建全局组件, 有2种写法 [官网链接](https://v2.cn.vuejs.org/v2/api/#Vue-component)\n  ```js\n   // 传入一个扩展过的**构造器** \n  Vue.component('my-component', Vue.extend({ /* ... */ }))\n   // 传入一个**选项对象** (vue还是会自动调用 Vue.extend) \n  Vue.component('my-component', { /* ... */ })\n  ```\n  \n1. 局部组件是直接传入配置来创建,最终核心都是调用了Vue.extend来创建组件的.\n   ```js\n   components: {\n      \"my-component\": {\n        template: \"<div>局部组件</div>\",\n      },\n    },\n    // 或者(不过这种写法就多此一举了) \n    components: {\n      \"my-component\":  Vue.extend({\n        template: \"<div>局部组件</div>\",\n      }),\n    },\n    ```\n   \n2. 如果全局组件和局部组件重名,vue会**优先去$options上找局部组件,找不到再去找全局组件**,我们打印下vm,可以看到$options上的局部组件,原形上是全局组件.\n\n<img src=\"images/demo.jpg\" width=\"50%\"/>\n   \n## 组件的好处\n- **最主要的就是组件更新**,不会影响其他组件,只会更新当前组件\n- 组件可以复用\n- 组件化开发,提高开发效率\n\n## 实现原理\n```js\n/src/global-api/index.js\n// 说明：全局api\nexport function initGlobalAPI(Vue) {\n  Vue.options = {}; // 用来存放全局api\n  // 说明：合并options\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin); // 合并options赋值給this.options,下次再调用Vue.mixin时，this.options就是上次合并后的结果\n  };\n  // 1.存放全局组件\n  Vue.options.components = {}; // 放全局组件\n  // 2.定义方法\n  Vue.component = function (id, definition) {\n    if (typeof definition === \"object\") {\n      definition.name = definition.name || id;\n      definition = this.extend(definition); // 调用构造函数\n    }\n    this.options.components[id] = definition; // 将组件放到全局组件中\n  };\n  // 核心,返回一个构造函数\n  Vue.extend = function (options) {\n    const Super = this; // Vue\n    const Sub = function VueComponent(opts) {\n      this._init(opts); // 调用父类的_init方法进行初始化\n    };\n    // 要继承父组件的属性\n    Sub.prototype = Object.create(Super.prototype); // 子类的原型指向父类的原型\n    Sub.prototype.constructor = Sub; // 修正constructor指向,即this指向\n    Sub.options = mergeOptions(Super.options, options); // 合并options\n    // 子组件\n    return Sub;\n  };\n}\n\n```\n```js\n/src/utils/index.js\n// 3.定义components钩子函数\nstrats.components = function (parentVal, childVal) {\n  const res = Object.create(parentVal); // 原型上放置全局组件\n  if (childVal) {\n    for (let key in childVal) {\n      res[key] = childVal[key]; // 局部组件\n    }\n  }\n  return res;\n};\n// 说明：合并options\nexport function mergeOptions(parent, child) {\n  const options = {};\n  // 说明：合并parent有，但是child中没有的key\n  for (let key in parent) {\n    mergeField(key);\n  }\n  // 说明：合并child中有，但是parent中没有的key\n  for (let key in child) {\n    mergeField(key);\n  }\n  function mergeField(key) {\n    // 4.因为components有函数定义,所以触发合并\n    if (strats[key]) {      \n      options[key] = strats[key](parent[key], child[key]);\n    } else {\n      options[key] = child[key] || parent[key];\n    }\n  }\n  console.log(options,'options');\n  return options;\n}\n```\n```js\nsrc/vdom/index.js\n\n// 创建虚拟dom（之前_c的参数：tag,data,多个子节点）\nfunction createElement(vm, tag, data = {}, ...children) {\n  //  判断tag是否是普通标签\n  if (typeof tag === \"string\" && isReservedTag(tag)) {\n    // 普通标签\n    return vnode(tag, data, data.key, children);\n  }\n  // 5.新增组件判断\n  else {\n    // 组件\n    let Ctor = vm.$options.components[tag]; // 组件的构造函数\n    return createComponentVnode(vm, tag, data, children, Ctor);\n  }\n} \nfunction isReservedTag(tagName) {\n  let str =\n    \"html,body,base,head,link,meta,style,title,\" +\n    \"address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,\" +\n    \"div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,\" +\n    \"a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,\" +\n    \"s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,\" +\n    \"embed,object,param,source,canvas,script,noscript,del,ins,\" +\n    \"caption,col,colgroup,table,thead,tbody,td,th,tr,\" +\n    \"button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,\" +\n    \"output,progress,select,textarea,\" +\n    \"details,dialog,menu,menuitem,summary,\" +\n    \"content,element,shadow,template,blockquote,iframe,tfoot\";\n  let obj = {};\n  str.split(\",\").forEach((tag) => {\n    obj[tag] = true;\n  });\n  return obj[tagName];\n}\n// 6.创建组件\nfunction createComponentVnode(vm, tag, data, children, Ctor) {\n  // 如果是对象，调用extend需要转换成构造函数\n  if (typeof Ctor === \"object\") {\n    Ctor = vm.constructor.extend(Ctor);\n  }  \n  data.hook = {\n    init(vnode) {\n      // 调用子组件的构造函数，创建子组件实例\n      let vm = new Ctor({ data: {} });\n      // 将子组件实例挂载到vnode上，用于后面创建 dom元素时，判断有没有子组件实例，如果有，说明是组件，直接取出组件实例的$el属性即可\n      vnode.componentInstance = vm;\n      // 将子组件的dom元素挂载到vnode上\n      vm.$mount();\n    },\n  };\n  // 返回虚拟dom\n  return vnode(`vue-component-${tag}`, data, data.key, undefined, undefined, {\n    Ctor,\n    children,\n  });\n}\n```\n```js\n/src/vdom/patch.js\nexport function createElm(vnode) {\n  let { tag, children, key, data, text } = vnode;\n  if (typeof tag === \"string\") {\n    // 8.判断是组件,直接返回$el\n    if (createComponent(vnode)) {\n      return vnode.componentInstance.$el;\n    } else {\n      // 元素\n      vnode.el = document.createElement(tag); // 创建元素\n      updateProperties(vnode); // 更新属性\n      children.forEach((child) => {\n        vnode.el.appendChild(createElm(child)); // 递归渲染子节点\n      });\n    }\n  } else {\n    // 文本\n    vnode.el = document.createTextNode(text);\n  }\n  return vnode.el;\n}\n// 7.新增创建组件方法\nfunction createComponent(vnode, tag, data, children, Ctor) {\n  let i = vnode.data;\n  // 相当于 i= i.hook i = i.init\n  if ((i = i.hook) && (i = i.init)) {\n    i(vnode);\n  }\n  if (vnode.componentInstance) {\n    return true;\n  }\n  return false;\n}\n```\n## 总结\n我们来分步解释下上面的逻辑.\n\n### 构造函数\n```js\nconst Fn= function(){\n  console.log(111);\n}\nFn.prototype.a=1\nFn.b=1\nconsole.log(Fn,'Fn')\nconst instance=new Fn()\nconsle.log(instance,'instance')\n```\n<img src=\"images/1.jpg\" width=\"50%\"/>\n我们再次打印以下结果都为true\n```js\nconsole.log(instance.__proto__ === Fn.prototype); // 实例的 __proto__ 指向构造函数的 prototype\nconsole.log(instance.constructor === Fn); // 实例的 constructor 指向构造函数\nconsole.log(Fn.prototype.constructor === Fn); // 构造函数的 prototype 的 constructor 指向构造函数\n```\n我们再次打印\n```js\nconsole.log(instance.constructor)\nconsole.log(Fn.prototype)\n```\n<img src=\"images/2.jpg\" width=\"50%\"/>\n\n### 继承\n```js\nconst Fn1 = function () {\n  // Fn.call(this);\n};\nFn1.prototype = Object.create(Fn.prototype);\nFn1.prototype.constructor = Fn1; // 添加constructor,否则找不到constructor就会继续向上找,找到Fn.prototype.constructor,这样就不对了\nconst instance1 = new Fn1();\nconsole.log(Fn1.prototype);\n```\n我们先看一个奇怪的问题,为什么继承后要加`Fn1.prototype.constructor`将指针指向修正?\n我们看下打印,没修正,少一个constructor属性,就会导致找不到继续向上找,找到了Fn.prototype.constructor即Fn\n<img src=\"images/constructor2.jpg\" width=\"50%\"/>\n修正,会多一个constructor属性Fn1\n<img src=\"images/constructor1.jpg\" width=\"50%\"/>\n\n实际上,不加上这句话继承也是没有问题,都能继承到方法属性,那为什么还要加呢?\n- 最重要的修正意义应该还是针对显示调用的时候,比如本来`Fn1.prototype.constructor就应该===F1` ,如果不修正就是`Fn.prototype.constructor即Fn`了,就导致我们显示调用创建实例的时候`new Fn1.prototype.constructor()`用的是Fn创建的实例,而不是Fn1创建的了,所以我们要修正\n- 网上还看到一种说法, constructor其实没有什么用处，只是JavaScript语言设计的历史遗留物。由于constructor属性是可以变更的，所以未必真的指向对象的构造函数，只是一个提示。不过，从编程习惯上，我们应该尽量让对象的constructor指向其构造函数，以维持这个惯例。\n\n### 原理讲解\n\n1. 全局挂载`Vue.component`方法,先判断如果是对象,调用`Vue.extend`,该方法主要是创建一个子类(构造函数-里面很简单,和Vue一样就是`this._init(opts)`进行初始化)继承父类Vue原型上的方法然后return出去,同时通过`this.options.components[id] = definition`存入全局组件.\n```js\nexport function initGlobalAPI(Vue) {\n  Vue.options = {}; // 用来存放全局api\n  // 说明：合并options\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin); // 合并options赋值給this.options,下次再调用Vue.mixin时，this.options就是上次合并后的结果\n  };\n  // 1.存放全局组件\n  Vue.options.components = {}; // 放全局组件\n  // 2.定义方法\n  Vue.component = function (id, definition) {\n    if (typeof definition === \"object\") {\n      definition.name = definition.name || id;\n      definition = this.extend(definition); // 调用构造函数\n    }\n    this.options.components[id] = definition; // 将全局组件放到全options中\n  };\n  // 核心,返回一个构造函数\n  Vue.extend = function (options) {\n    const Super = this; // Vue\n    const Sub = function VueComponent(opts) {\n      this._init(opts); // 调用父类的_init方法进行初始化\n    };\n    // 要继承父组件的属性\n    Sub.prototype = Object.create(Super.prototype); // 子类的原型指向父类的原型\n    Sub.prototype.constructor = Sub; // 修正constructor指向,即this指向\n    Sub.options = mergeOptions(Super.options, options); // 合并options\n    // 子组件\n    return Sub;\n  };\n}\n```\n2. 重点来了`Sub.options = mergeOptions(Super.options, options);`这段代码的主要作用就是往components的原型上挂载全局组件,这样如果局部组件和全局组件重名,优先用局部组件.\n```js\n// 3.定义components钩子函数\nstrats.components = function (parentVal, childVal) {\n  const res = Object.create(parentVal); // 原型上放置全局组件\n  if (childVal) {\n    for (let key in childVal) {\n      res[key] = childVal[key]; // 局部组件\n    }\n  }\n  return res;\n};\n// 说明：合并options\nexport function mergeOptions(parent, child) {\n  const options = {};\n  // 说明：合并parent有，但是child中没有的key\n  for (let key in parent) {\n    mergeField(key);\n  }\n  // 说明：合并child中有，但是parent中没有的key\n  for (let key in child) {\n    mergeField(key);\n  }\n  function mergeField(key) {\n    // 4.因为components有函数定义,所以触发合并\n    if (strats[key]) {      \n      options[key] = strats[key](parent[key], child[key]);\n    } else {\n      options[key] = child[key] || parent[key];\n    }\n  }\n  console.log(options,'options');\n  return options;\n}\n```\n\n<img src=\"images/3.jpg\" width=\"50%\"/>\n\n3. 当我们在页面中使用组件时,`<my-component></my-component> <my-component1></my-component1>`,编译后来到创建虚拟dom(下面会回忆下如何创建vdom), 要区分是html标签还是组件的标签,通过`isReservedTag函数`,如果是组件标签,直接获取`vm.$options.components[tag]`通过`createComponentVnode`创建组件vdom.\n```js\nsrc/vdom/index.js\nfunction isReservedTag(tagName) {\n  let str =\n    \"html,body,base,head,link,meta,style,title,\" +\n    \"address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,\" +\n    \"div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,\" +\n    \"a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,\" +\n    \"s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,\" +\n    \"embed,object,param,source,canvas,script,noscript,del,ins,\" +\n    \"caption,col,colgroup,table,thead,tbody,td,th,tr,\" +\n    \"button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,\" +\n    \"output,progress,select,textarea,\" +\n    \"details,dialog,menu,menuitem,summary,\" +\n    \"content,element,shadow,template,blockquote,iframe,tfoot\";\n  let obj = {};\n  str.split(\",\").forEach((tag) => {\n    obj[tag] = true;\n  });\n  return obj[tagName];\n}\n// 创建虚拟dom（之前_c的参数：tag,data,多个子节点）\nfunction createElement(vm, tag, data = {}, ...children) {\n  //  判断tag是否是普通标签\n  if (typeof tag === \"string\" && isReservedTag(tag)) {\n    // 普通标签\n    return vnode(tag, data, data.key, children);\n  }\n  // 1.新增组件vdom创建\n  else {\n    // 组件的构造函数\n    let Ctor = vm.$options.components[tag];\n    return createComponentVnode(vm, tag, data, children, Ctor);\n  }\n} \n```\n4.`createComponentVnode`主要目的是,\n- 组件是对象通过extend转化: 判断`vm.$options.components[tag]`是对象的要通过`vm.constructor.extend(Ctor)`转化, 注意⚠️,全局函数直接在Vue.component里面已经判断转化,局部组件才会走到这里进行判断转换.\n- tag重命名: 本身tag标签是如 `my-component`,拼接上前缀`vue-component-`来标示,后面组件更新时通过标示判断是组件跳过.\n- 往data中注入`hook对象`: 回忆下vnode的data是干嘛用的(存储属性用的,如style、属性等),hook对象里面有个`init函数`,用于执行子组件`new Ctor({ })`,上面讲了构造函数里面就是`this._init(opts)`形成了闭环.同时在vnode上面绑定了实例`vnode.componentInstance = vm`为了后面创建真实dom节点时候,判断有vm肯定是组件通过构造函数生成的.最后执行`vm.$mount()`进行挂载$el.\n```js\nfunction createComponentVnode(vm, tag, data, children, Ctor) {\n  // 局部组件是对象，调用extend需要转换成构造函数, \n  if (typeof Ctor === \"object\") {\n    Ctor = vm.constructor.extend(Ctor);\n  }  \n  data.hook = {\n    init(vnode) {\n      // 调用子组件的构造函数，创建子组件实例\n      let vm = new Ctor({ });\n      // 将子组件实例挂载到vnode上，用于后面创建 dom元素时，判断有没有子组件实例，如果有，说明是组件，直接取出组件实例的$el属性即可\n      vnode.componentInstance = vm;\n      // 将子组件的dom元素挂载到vnode上\n      vm.$mount();\n    },\n  };\n  return vnode(`vue-component-${tag}`, data, data.key, undefined, undefined, {\n    Ctor,\n    children,\n  });\n}\n// 构造虚拟dom结构\nfunction vnode(tag, data, key, children, text, componentOptions) {\n  return {\n    tag,\n    data,\n    key,\n    children,\n    text,\n    componentOptions,\n  };\n}\n```\n我们看下vnode的结构\n<img src=\"images/4.jpg\" width=\"50%\"/>\n5. 接下来是通过vdom生成真实dom结构,先回忆下如何创建vdom的,第一次渲染,走了$mount,挂载到#app下,后面有个_render就是创建vdom的即上面第三、四步.\n<img src=\"images/5.jpg\" width=\"80%\"/>\n<img src=\"images/6.jpg\" width=\"80%\"/>\n\n`_render`\n<img src=\"images/6-1.jpg\" width=\"80%\"/>\n<img src=\"images/6-2.jpg\" width=\"80%\"/>\n<img src=\"images/7.jpg\" width=\"80%\"/>\n6. 最后走到patch方法\n   \n```js\nexport function patch(oldVnode, vnode) {\n  // 组件渲染时，没有oldVnode\n  if(!oldVnode){\n    return createElm(vnode); \n  }\n  console.log(oldVnode, vnode, \"patch\");\n  // 1.判断是更新还是第一次渲染，第一次传的是真实的dom节点$el,后面更新传递的是虚拟dom\n  const isRealElement = oldVnode.nodeType;\n  if (isRealElement) {\n    // 渲染\n    const oldElm = oldVnode; // div id=\"app\"\n    const parentElm = oldElm.parentNode; // body\n    let el = createElm(vnode); // 创建真实dom\n    parentElm.insertBefore(el, oldElm.nextSibling); // 将创建的真实dom插入到老的dom的后面\n    parentElm.removeChild(oldElm); // 删除老的dom\n    return el;\n  } else {\n    // 更新\n    patchVnode(oldVnode, vnode);\n  }\n}\n```\n第一次渲染,我们打印oldVnode\n<img src=\"images/8.jpg\" width=\"80%\"/>\n然后走到createElm,通过`createComponent(vnode)`判断是组件该方法主要执行了取出patch传过来的vdom的data中之前定义的hook.init函数,进行执行`vnode.data.hook.init(vnode)`,因为执行中我们上面讲了往vdom上绑定了实例表示已经初始化了`let vm = new Ctor({ });vnode.componentInstance = vm;`我们判断`if (vnode.componentInstance) { return true;}`表示是组件,因为已经new实例话渲染过了,所以已经有了$el,所以判断是组件直接返回了`vnode.componentInstance.$el`.\n\n```js\nexport function createElm(vnode) {\n  let { tag, children, key, data, text } = vnode;\n  if (typeof tag === \"string\") {\n    // 1.判断是组件\n    if (createComponent(vnode)) {\n      // 如果返回true，说明是组件\n      return vnode.componentInstance.$el;\n    } else {\n      // 元素\n      vnode.el = document.createElement(tag); // 创建元素\n      updateProperties(vnode); // 更新属性\n      children.forEach((child) => {\n        vnode.el.appendChild(createElm(child)); // 递归渲染子节点\n      });\n    }\n  } else {\n    // 文本\n    vnode.el = document.createTextNode(text);\n  }\n  return vnode.el;\n}\n\nfunction createComponent(vnode, tag, data, children, Ctor) {\n  let i = vnode.data;\n  // 相当于 i= i.hook i = i.init\n  if ((i = i.hook) && (i = i.init)) {\n    i(vnode);\n  }\n  if (vnode.componentInstance) {\n    return true;\n  }\n  return false;\n}\n```\n\n**注意:**\n- 组件的加载顺序是自上而下的，也就是先加载父组件，再递归地加载其所有的子组件。\n- 组件渲染顺序是按照深度优先遍历的方式，也就是先渲染最深层的子组件，再依次向上渲染其父组件\n- 全部组件加载成功后(有了dom节点$el),才会执行mounted钩子函数\n- 子组件更新自己的属性不会影响父组件(即不会触发父组件的updated、beforeUpdate)\n\n<img src=\"images/9.jpg\" width=\"80%\"/>\n比如\n```html\n<div id=\"app\">\n  <my-component></my-component>\n</div>\n```\n\n先渲染template,发现<my-component>判断是组件,最后走到patch函数,vue需要有个根结点,如#app,第一次是真实dom节点`vm.$mount(vm.$options.el)`直接先走到`if (isRealElement) {}中`,而子组件因为`vm.$mount()传的是空`,所以代码上面就`if(!oldVnode){\n    return createElm(vnode); \n  }`return掉,直到生成$el完毕,最后父组件才会mounted完毕\n\n<img src=\"images/10.jpg\" width=\"80%\"/>\n\n","categories":["vue2源码"]},{"title":"基础-6","url":"/ypf-blog/2024/01/18/gwy/LFTT/基础-6/","content":"## 案例\n### 案例1\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-1.jpg\" width=\"50%\"/>\n\n案例特点: 对称、纯封闭、2笔画\n考点: 空间数量、对称、一笔画\n练习题1: **对称轴数量**\n134一组2条对称轴, 256一组一条对称轴\n\n### 案例2\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-2.jpg\" width=\"50%\"/>\n\n案例特点: 对称、纯封闭、1笔画\n考点: 空间数量、对称、一笔画\n练习题1: **对称轴角度**\n规律是:对称轴顺时针依次旋转45度,所以排除AC, 在看题目发现对称轴都会过一个点,所以选D\n\n### 案例3\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-3.jpg\" width=\"50%\"/>\n\n案例特点: 典型2笔画\n考点: 交点数量、一笔画\n练习题1: **一笔画**\n规律:分别是1笔画、2笔画、3、4,所以选D\n\n### 案例4\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-4.jpg\" width=\"50%\"/>\n\n案例特点: 三角形位置变化()\n考点: 修正空间数量\n练习题1: **空间数量**\n规律:空间数分别是2、3、4、5,所以只剩下BD,再观察案例,都是对称的,所以选D\n\n### 案例5\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-5.jpg\" width=\"50%\"/>\n\n案例特点: 一笔画、点连接、对称、交点\n练习题1: **交点数量**\n规律:分别是2、3、4、5、6,所以选B\n\n---\n练习题1: **点/线连接**\n规律:125是线连接、346是点连接\n\n### 案例6\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-6.jpg\" width=\"50%\"/>\n\n案例特点: 内含正方形区域\n考点:正方形面积、位置\n练习题1: **正方形位置**\n规律:136正方形都是最小区域,245都是大区域\n\n### 案例7\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-7.jpg\" width=\"50%\"/>\n\n案例特点: 两个元素部分重合\n考点:重合区域形状(相似性、线条数量、曲直定性)\n练习题1: **重合区域条线数量**\n规律:分别是3456,所以选C\n---\n练习题2: **重合区域条线数量**\n规律:都是5,所以选A\n---\n练习题3: **重合区域条线数量**\n规律:125一组都是4边形,346一组都是5边形\n\n### 案例8\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-8.jpg\" width=\"50%\"/>\n\n案例特点: 奔驰标志变形、2笔画、三个空间且形状不规则\n练习题1: **图形两两都有公共边**\n规律:125一组,346一组\n---\n练习题2: **1笔画**\n规律:都是1笔画,所以选D\n\n### 案例9\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-9.jpg\" width=\"50%\"/>\n\n案例特点: 单区域纯封闭图形\n考点:曲直数量、交点、对称、逻辑运算\n练习题1: **交点数量**\n规律:分别是34567,所以选B\n---\n练习题2: **逻辑运算(曲线数量与直线数量之差)**\n规律:134都是直线数量-曲线数量=1, 256都是曲线数量-直线数量=1\n---\n练习题3: **交点数量**\n规律:第一组是357,第二组也是35?所以选C\n---\n练习题4: **逻辑运算(对称轴数量-空间数=0)**\n规律:所以选A\n\n### 案例10\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-10.jpg\" width=\"50%\"/>\n\n案例特点: 2个空间相连接\n考点:对接考法、空间形状、对称\n练习题1: **对称轴特性(2个图形的对称轴位置关系)**\n规律:2个图形的对称轴位置关系分别为平行、相交、垂直、平行、相交、?,所以选D\n---\n练习题2: **对称轴特性(2个图形的对称轴位置关系)**\n规律:2个图形的对称轴位置关系分别为重合、重合、垂直、垂直、重合、垂直\n---\n练习题3: **对接考法(对接边条数)**\n规律:分别是0 1 2 3 4 ?选C\n---\n练习题4: **对称轴特性(2个图形的对称轴位置关系)**\n规律:位置关系是存在平行、相交、存在平行、存在平行、相交、相交,所以134一组,256一组\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/6-10-1.jpg\" width=\"50%\"/>\n\n练习题5: **对称轴特性(2个图形的对称轴位置关系)**\n规律:分别是平行、相交、垂直; 平行、相交、? 选D\n---\n练习题6: **对称轴特性(2个图形的对称轴位置关系)**\n规律:都是内外对称轴垂直? 选A, B不选是因为不是内外关系\n\n## 总结\n- 两图形相交,要想到相交的图形对称轴的位置关系、对接公共边条数、组成的重合区域线条数、点/线连接等\n- 内都都含有正方形图形或者同样的图形,要想到该图形的位置,如都在最大区域、最小区域等\n- 看到图形修正,如三角形有内到外,要想到空间数量\n- 看到对称图形要想到对称轴位置、一笔画、空间数、","categories":["gwy","LFTT"]},{"title":"基础-5","url":"/ypf-blog/2024/01/15/gwy/LFTT/基础-5/","content":"## 案例\n### 案例1\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-1.jpg\" width=\"50%\"/>\n\n案例特点: 字母九宫格\n考点: 曲直数量位置、封闭元素数量位置、空间数量\n练习题1: **曲直数量位置**\n分别是:  第一行第二行,曲的位置是123,所以选D\n\n### 案例2\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-2.jpg\" width=\"50%\"/>\n\n案例特点: 📎曲别针、不规则开放图形却出现在第一个\n考点: 空间数量、一笔画\n练习题1: **空间数量**\n分别是: 0 1 2 3 ?, 选A \n\n--- \n练习题2: **一笔画**\n分别是: 都是1笔画, 选D \n\n--- \n练习题3: **一笔画**\n分别是: 都是1笔画, 选A\n### 案例3\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-3.jpg\" width=\"50%\"/>\n\n案例特点: 分离色彩,上面放大镜有4部分(包含正方形轮廓)\n考点: 元素、部分数量、分离/整体\n练习题1: **分离**\n分别是: 125分离,346整体\n\n### 案例4\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-4.jpg\" width=\"50%\"/>\n\n案例特点: 回旋折线\n考点: 进出口线的位置关系(平行、垂直、方向一致)\n练习题1: **进出口线位置**\n分别是: 125垂直,346平行\n\n### 案例5\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-5.jpg\" width=\"50%\"/>\n\n案例特点: 对称图形\n考点: 对称轴方向、数量、方式、轴线位置关系\n练习题1: **对称轴方向-每次旋转45度、轴线位置关系**\n所以只剩下BD,观察发现轴线位置关系分别是重合、不重合进行循环,所以选B\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-5-1.jpg\" width=\"50%\"/>\n\n常考的对称轴考点优先级3+3: \n第一优先级: 对称轴方向、数量、方式\n第二优先级: 其次是轴线位置关系(重合>垂直)、对称轴点到点,还是过线、对称轴分割2遍都有同样图形\n\n上图就介绍了第二优先级的类型.\n\n### 案例6\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-6.jpg\" width=\"50%\"/>\n\n案例特点: 对称图形+单区域图形\n考点: 上面介绍的6+6考点\n练习题1: **对称轴点到点,还是过线**\n所以145一组,236一组\n\n--- \n练习题2: **对称轴点到点,还是过线**\n所以125一组,346一组\n\n### 案例7\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-7.jpg\" width=\"50%\"/>\n\n案例特点: 黑白阴影、只看阴影\n考点:黑白形状面积关系\n练习题1: **黑白面积(黑面积=白面积)**\n所以126一组,345一组\n\n---\n练习题2: **黑白面积(黑面积=白面积)**\n所以选B\n\n---\n练习题3: **黑白面积(黑面积=白面积)**\n所以134一组,256一组\n\n---\n练习题4: **黑白轮廓数量**\n分别是:65 44 33 , 76 55 ?, 选C\n\n### 案例8\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-8.jpg\" width=\"50%\"/>\n\n案例特点:纯直图形\n考点:曲直定性、曲直线条数量\n\n练习题1: **曲直定性**\n按行分别是纯直、纯曲、曲直,所以选A\n\n---\n练习题2: **曲直定性**\n按行分别是纯直、纯曲、曲直,所以选D\n\n### 案例9\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-9.jpg\" width=\"50%\"/>\n\n案例特点:单区域轮廓+一个小圆圈\n考点:标记考法\n练习题1: **小圆圈在直角/钝角**\n所以125直角一组,346锐角一组\n--- \n练习题2: **小圆圈在长边/短边**\n所以136短边一组,245长边一组\n--- \n练习题3: **小圆圈在凹角/凸角**\n所以123凹角一组,456凸角一组\n\n### 案例10\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-10.jpg\" width=\"50%\"/>\n\n案例特点:类圆曲线+出头色彩\n考点:曲直交点、曲曲交点 (数的时候一条一条曲线数)、交点数\n\n练习题1: **曲直交点数量=曲线数量2倍**\n分别是: 42 63 21 42 84, 所以选D\n---\n练习题2: **相切**\n246相切一组,135一组\n---\n练习题3: **相切且与圆有一个交点**\n所以选C\n\n### 案例11\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-11.jpg\" width=\"50%\"/>\n\n案例特点:元素相同但位置不同\n考点:元素位置\n练习题1: **元素位置**\n分别是: 第一组是圆圈分别在外、内、包含, 第二组三角形同样规律,所以选C \n\n### 案例12\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-12.jpg\" width=\"50%\"/>\n\n案例特点:元素上下位置关系呈现\n考点:上下要素关系\n练习题1: **上下一笔画作差**\n分别是: 12 12 21 21 ? 选D\n\n### 案例13\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-13.jpg\" width=\"50%\"/>\n\n案例特点:数字修正变形\n考点:直角数量\n练习题1: **直角数量**\n分别是: 按行看,都是123,所以选D\n\n### 案例14\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-14.jpg\" width=\"50%\"/>\n\n案例特点:立体图形\n考点:面数量\n练习题1: **面数量**\n都是6面体,所以选A\n\n### 案例15\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-15.jpg\" width=\"50%\"/>\n\n案例特点:平面图形+立体图形\n考点:交点数量\n练习题1: **交点数量**\n交点数量分别是3 4 5 6 ? 选A\n\n### 案例16\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-16.jpg\" width=\"50%\"/>\n\n案例特点:图形相似,元素减少\n考点:去同存异、去异留同\n练习题1: **去同存异**\n选D\n### 案例17\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/5-17.jpg\" width=\"50%\"/>\n\n案例特点:轮廓相同,阴影数量不一致\n考点:逻辑加减,如黑白运算\n练习题1: **黑白运算**\n白+白=白 黑+白=黑, 所以选A\n\n---\n练习题2: **黑白运算**\n白+白=白 黑+白=黑, 所以选C\n\n\n## 总结\n\n- 黑白图形要想到黑白去同存异、黑白分割空间数、黑白分割线一笔画、黑白面积(黑=白面积)、只看黑阴影、黑白轮廓数量等\n- 看到立体图形+平面图形要想到交点数量,只有立体图形要想到面数量\n- 看到数字修正变形要想到直角数\n- 看到上下排版图形,要想到上下逻辑计算(如上下一笔画计算)\n- 常考的对称轴考点优先级3+3: \n  第一优先级: 对称轴方向、数量、方式\n  第二优先级: 其次是轴线位置关系(重合>垂直)、对称轴点到点,还是过线、对称轴分割2遍都有同样图形\n- 看到图形有一个小圆圈,要想到小圆圈的位置(钝角/直角、凹/凸、长边/短边), 2个小圆圈要想到圆圈连线位置,如两圆圈连线经过的图形位置、方向、小圆圈相对图形位置(如一个圆内、一个圆外或圆上、一个正方形一个三角形内、一个边上一个顶点上)\n- 看到回旋折线,要想到进出口位置关系(平行、垂直、方向一致)\n- 看到曲别针且出现在首位,要想到空间数量递增、一笔画\n- 看到字母九宫格,要想到曲直","categories":["gwy","LFTT"]},{"title":"基础-4","url":"/ypf-blog/2024/01/03/gwy/LFTT/基础-4/","content":"## 案例\n\n### 案例1\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-1.jpg\" width=\"50%\"/>\n\n案例特点: 中心对称、九宫格中心位置\n考点: 对称、数量个数、元素种类变化(有几种元素、颜色)\n练习题1: **数量个数**\n规律: 对角数量之和是中心5的2倍,所以选B\n\n--- \n练习题2: **数量个数+种类(颜色)变化+**\n规律:\n第一行: 6 1 7\n第二行: 7 3 10\n第三行: ? 9 13\n所以排除A,再看规律,发现每行,第一列和第二列的颜色到第三列都会反过来,所以选C\n\n### 案例2\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-2.jpg\" width=\"50%\"/>\n\n案例特点: 对称、封闭\n考点:对称、交点、空间、平行\n\n--- \n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-2-1.jpg\" width=\"50%\"/>\n\n练习题: **对称轴条数**\n规律: 134都是1条对称轴,256都是2条\n\n### 案例3\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-3.jpg\" width=\"50%\"/>\n\n案例特点: 四笔画经典图形、内外是一样的图形、对称、纯封闭\n考点:一笔画、内外交点数量、空间位置、对称\n练习题: **对称**\n规律: 134都是一条对称轴,256都是多条\n\n### 案例4\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-4.jpg\" width=\"50%\"/>\n\n案例特点: 都是三角形组成、纯封闭\n考点:三角形数量、空间数量、外轮廓规则(运算)\n练习题: **外轮廓规则(运算)**\n规律: 外轮廓数量-空间数量=0,所以选A\n\n### 案例5\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-5.jpg\" width=\"50%\"/>\n\n案例特点: 纯封闭、对称\n考点:一笔画、空间数量、空间形状、对称、空间面积\n练习题: **空间数量**\n规律:  2 3 4  3 4 ? ,所以选A\n\n---\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-5-1.jpg\" width=\"50%\"/>\n\n规律: **空间面积**\n内部存在一个空间面积=其余面积之和\n\n### 案例6\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-6.jpg\" width=\"50%\"/>\n\n案例特点: 圆轮廓出头很多线条、圆内部无线条\n考点:延伸线考法(延伸线数量有几条、延伸线每条分为几段、延伸线与图形位置关系)\n\n这里讲练习题前,我们先看下几种案例:\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-6-0.jpg\" width=\"50%\"/>\n\n1. 延伸线在外面,我们关注点在外面\n2. 延伸线从里到外, 我们关注点在里面\n3. 延伸线全部在里面且连接了轮廓,我们关注点在圆内和圆轮廓上\n4. 延伸线在里面且有部分没连接轮廓,我们关注点在点数量和一笔画\n\n练习题: **延伸线数量有几条**\n规律:  2 3 4 5 ? 所以选B\n\n--- \n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-6-1.jpg\" width=\"50%\"/>\n\n规律:  **延伸线与图形位置关系**\n145相切, 236从点延伸\n\n---\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-6-2.jpg\" width=\"50%\"/>\n\n1. 延伸线数量 1 2\n2. 延伸线线段数量 1 2 ,和上面一个是线条、一个是线段\n3. 分别是延伸线从线触发、延伸线从点出发\n4. 延伸线线段数量=图形轮廓数量\n5. 延伸线存在一条线段与图形垂直/平行\n\n### 案例7\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-7.jpg\" width=\"50%\"/>\n\n案例特点: 延伸线+简单图形\n考点: 重点在图形,图形轮廓数量, 延伸线就是干扰了\n练习题: \n规律: **图形轮廓数量**\n轮廓数分别是: 3 4 5 6 ? 8 所以选B\n\n### 案例8\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-8.jpg\" width=\"50%\"/>\n\n案例特点: 圆形轮廓、线条贯穿内外、线条基本不封闭\n考点: 圆内点(交点等)、线、面数量\n练习题:  **交点数量**\n规律: 交点数量分别是0 1 2 3 4 ? 所以选 C\n\n--- \n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-8-1.jpg\" width=\"50%\"/>\n\n练习题1:\n规律: **交点数量**\n第一行都是1,第二行都是2, 所以选C\n\n---\n练习题2: \n规律: **面的数量**\n分别是 1 2 3 4 5 ?所以选A\n\n### 案例9\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-9.jpg\" width=\"50%\"/>\n\n案例特点: 圆形轮廓、纯封闭\n考点: 轮廓上要素、轮廓内要素\n练习题:  **轮廓内要素(线条数量)**\n规律: 分别是 1 2 3 4 ? 所以选D\n\n--- \n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-9-1.jpg\" width=\"50%\"/>\n\n规律: **轮廓上点数**\n轮廓上点数量分别是 0 1 2 ? 4 所以选D\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-9-2.jpg\" width=\"50%\"/>\n\n规律: **轮廓上点数**, 所以145一组都是3个, 236一组都是4个\n\n\n## 总结\n\n### 黑白点\n{% post_link gwy/LFTT/基础-3 上一篇基础-3 %} 黑白点规律总结有一部分,该节新增\n- 黑白数量个数变化(第一个+第二个=第三个总数)\n- 第一个和第二个颜色到第三个颜色反了\n\n### 典型四笔画\n看到典型四笔画或者内外都一样图形,要考虑对称、交点数量\n\n### 三角形\n- 看到三角形要考虑三角形数量、空间数量、轮廓与空间数量运算、一个空间面积=其余面积之和\n\n### 轮廓+延伸线\n\n1. 轮廓是圆形,考点有延伸线数量、延伸线线段数量、延伸线和轮廓数量、延伸线和轮廓位置关系、延伸线从线/点出发\n2. 轮廓不是圆形,关注点在轮廓,不在延伸线, 此时考察轮廓线条数量\n3. 延伸线贯穿图形内外,优先级考虑轮廓内/轮廓上的点, 点、线、面数量\n\n## 案例\n### 案例1\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-10.jpg\" width=\"50%\"/>\n\n案例特点: 实物简笔画\n考点: 空间数量、线条数量、图形特征(封闭/开放等)\n练习题1:  **空间数量**\n规律: 分别是 3 4 5 6 ? 所以选C\n\n--- \n\n练习题2:\n规律: **图形特征(封闭/开放)**\n156都是封闭, 234都是开放\n\n### 案例2\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-11.jpg\" width=\"50%\"/>\n\n案例特点: 外部规则、内部不规则\n我们总结一下常用规律:\n- 外部规则看外部\n- 外部不规则看内部\n- 内外分离结合看(结合外部、内部综合计算等)\n- 轮廓相同都要看(都要看指的是全部都看,如轮廓外、内、轮廓上等)\n- 内外都乱,定性看(此时就不是数数量了,要看图形特征,如外直内曲等)\n\n--- \n练习题1:  **外部规则看外部-外部轮廓数量**\n左边分别是 4 5 6, 右边是1 2 ?, 所以选C\n\n--- \n\n练习题2: **内外分离结合看-外轮廓数和内部线条数量**\n分别是:65 55 44 44 32 43\n所以234一组,156一组\n\n### 案例3\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-12.jpg\" width=\"50%\"/>\n\n规律: **中心区域图形形状**\n145中心区域为曲线,236为直线\n\n### 案例4\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-13.jpg\" width=\"50%\"/>\n\n规律: **轮廓对角线方向**\n146一组,235一组\n\n### 案例5\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-14.jpg\" width=\"50%\"/>\n\n规律: **曲直定性**\n124为外直内曲, 356为外曲内直\n\n### 案例6\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-15.jpg\" width=\"50%\"/>\n案例特点: 火柴头\n考点: 看首、尾、拐点的移动位置规律、 如果火柴头没有头,只有线,可能会考经过的格子数量\n\n--- \n练习题1:  **首、尾、拐点的移动位置**\n头分别**外圈**顺时针移动2格,尾**内圈**逆时针移动一格,拐点为外圈顺时针移动一格,所以选B\n\n--- \n练习题2:  **线经过的格子数量**\n自己数一下即可.\n\n### 案例7\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-16.jpg\" width=\"50%\"/>\n\n案例特点:圆、线、有切点\n考点:曲线与曲线的切点数量和直线与曲线的切点数量\n练习题1:  **曲线与曲线的切点数量和直线与曲线的切点数量**\n分别为: 21 12 32 12 12 21, 所以\n### 案例8\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-17.jpg\" width=\"50%\"/>\n\n案例特点: 纯文字\n考点: 空间数量、部分数量、**横竖线条数量**\n练习题1: **横竖线条数量**\n分别为: 11 22 33 44 55 ?, 所以选A\n\n### 案例9\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-18.jpg\" width=\"50%\"/>\n\n案例特点: 字母、文字\n考点: 部分数量、空间数量、曲直\n练习题1:**空间数量**\n竖着看,空间数量分别为0 1 2, 所以选C\n\n### 案例10\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-19.jpg\" width=\"50%\"/>\n\n案例特点: 轮廓下字母\n考点: 空间、部分数量\n练习题1:**部分数量**\n部分数量都是2,所以选A\n\n### 案例11\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-20.jpg\" width=\"50%\"/>\n\n案例特点: 九宫格里面都是纯质、纯曲切出头\n考点: 元素要素(行或列看)\n练习题1:**元素要素**\n竖着看:第一列线段数量分别是321,第二列空间数量分别为432,第三列交点数分别为? 4 3,所以选D\n\n\n### 案例12\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-21.jpg\" width=\"50%\"/>\n\n案例特点: 田字格轮廓\n考点:对称性\n练习题1: **相同图形的对称性**\n146相同对象都为对角、235都是同侧\n\n### 案例13\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-22.jpg\" width=\"50%\"/>\n\n案例特点: 图形对接变都为2条\n考点:夹角度数\n练习题1: **夹角度数**\n126是钝角、345是直角\n\n---\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-22-1.jpg\" width=\"50%\"/>\n\n上图可以看出,除去夹角度数,也可以考 **对接线完全包含/部分包含、对接线是曲直、对接线数量、对接线是最长/最短边**\n\n### 案例14\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-23.jpg\" width=\"50%\"/>\n\n案例特点: 每幅图都有2个小圆圈\n考点:两圆圈连线经过的图形位置、方向、小圆圈相对图形位置(如一个圆内、一个圆外或圆上、一个正方形一个三角形内、一个边上一个顶点上)\n练习题1: **两圆圈连线经过的图形位置**\n123都经过最大图形、456都经过最小图形\n\n--- \n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-23-1.jpg\" width=\"50%\"/>\n\n### 案例15\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-24.jpg\" width=\"50%\"/>\n\n案例特点: 斜线阴影\n考点: 阴影的方法、阴影与轮廓重合线数量\n练习题1: **阴影与轮廓重合线数量**\n分别是: 3 3 3 3 ?, 所以选C\n### 案例16\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-25.jpg\" width=\"50%\"/>\n\n案例特点: 十字坐标轴\n考点: 坐标轴与图形夹角等\n练习题1: **坐标轴与图形夹角**\n分别是: 数时针夹角 所以选A\n\n---\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/4-25-1.jpg\" width=\"50%\"/>\n\n也可以考**上下坐标轴的空间数量**, 如上图分别是上下 12 22;\n也可以考 **坐标轴交点数量**,如上图分别是3 5\n### 总结\n- 看到实物简笔画(如钟表、齿轮、量杯等),要想到空间数量、线条数量、都是封闭/都是开放图形\n- 火柴头(或不带头),要想到起头、尾、拐点移动规律(外圈、内圈、象限)、或者经过格子数量\n- 看到纯文字、字母等,要想到空间、部分、横竖线条数量\n- 看见曲线、直线,要想到曲线与曲线切点、直线与曲线切点\n- 均有中心区域,要想到中心区域图形(轮廓、曲直等)\n- 图形内部均有对角线,要看对角线方向\n- 看到图像有2个圆圈,要想到2圆圈连线位置,如两圆圈连线经过的图形位置、方向、小圆圈相对图形位置(如一个圆内、一个圆外或圆上、一个正方形一个三角形内、一个边上一个顶点上)\n- 看到线阴影,要想到阴影与轮廓重合线数量\n- 看到图形对接,要想到夹角、对接线完全包含/部分包含、对接线是曲直、对接线数量、对接线是最长/最短边\n- 看到坐标轴,要想到图形与坐标轴的夹角图案、位置、上下坐标轴的空间数量、坐标轴交点数量\n\n**特殊规律: 一般是正方形/圆形轮廓,里面一些复杂图形**\n- 外部规则看外部\n- 外部不规则看内部\n- 内外分离结合看(结合外部、内部综合计算等)\n- 轮廓相同都要看(都要看指的是全部都看,如轮廓外、内、轮廓上等)\n- 内外都乱,定性看(此时就不是数数量了,要看图形特征,如外直内曲等)","categories":["gwy","LFTT"]},{"title":"基础-3","url":"/ypf-blog/2023/12/27/gwy/LFTT/基础-3/","content":"## 案例\n### 案例1\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-1.jpg\" width=\"50%\"/>\n\n案例特点: 纯封闭, 空间数量都一致\n考点:空间形状、空间位置、空间数量,(**,此时出题人一般都是让空间数量一致,选项也和题目空间数量一致,让考生往形状、位置想,而不是往数量想**)\n\n所以测试图的规律是 **空间位置**——最大空间呈中心对称,所以选A\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-1-1.jpg\" width=\"50%\"/>\n上图要求排除一个规律不同的.\n\n此题考的是 **空间数量**——都是2个三角形 + 一个四边形组成,所以选B\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-1-2.jpg\" width=\"50%\"/>\n\n上图规律是 **空间形状**: 246一组(**外轮廓形状和最大面一样**), 135一组(**外轮廓形状和最小面一样**)\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-1-3.jpg\" width=\"50%\"/>\n\n上图规律是 **空间形状**: 内部存在2个相似的图形,但ABC都存在,仔细观察题目是**最小与最大面相似**, 所以选C\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-1-4.jpg\" width=\"50%\"/>\n\n上图规律是 **空间形状**:内部存在2个相同即**一摸一样**的图形,所以选B, 注意D虽然有2个平行四边形,但是大小不一样,所以不同.\n\n### 案例2\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-2.jpg\" width=\"50%\"/>\n\n案例特点: logo阴影类.\n考点: 部分数量、空间数量、对称\n测试第二组的规律是:**部分数量**.: 4 7 7 4 4 7 ,注意数的是**分离的部分**\n测试第二组的规律是: 134属于一个**整体**, 256属于**分离**的.\n\n## 总结\n\n1. 对于纯封闭,空间数量一致的图,我们要从下面3个角度考虑\n  - 空间位置:对称性、内部最大/最小/存在对称图形\n  - 空间形状: 外轮廓和内部最大/最小一样、 内部存在2个相似/相同的图形\n  - 空间数量: 如都是2个三角形+1个四边形\n  \n2. 对于logo阴影图形,要从下面3个角度考虑\n  - 部分数量, 如几部分(分离的部分数)\n  - 整体性, 如是一个整体还是分离的\n  - 对称性, 是否是对称图形\n\n## 案例\n### 案例1\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-3.jpg\" width=\"50%\"/>\n\n案例特点: 图形里含有直角三角形\n考点: 直角数量(考的最多)、直角三角形数量、一笔画, 一般我们看到规则的直角,如 `L T +、正方形等`都要快速想到直角\n练习题: **直角数量**\n1 2 1 2 2 1, 所以245一组\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-3-1.jpg\" width=\"50%\"/>\n直角数量: 1 2 3 4 5 ?, 所以选B\n\n### 案例2\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-4.jpg\" width=\"50%\"/>\n\n案例特点:单区域,扇形\n考点: 扇形的面积(即夹角度数)、曲直数量(扇形是1曲2直)、对称、一笔画\n练习题: **曲直数量**\n都是1直,曲线是1 2 3 4 ?,所以选D\n\n---\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-4-1.jpg\" width=\"50%\"/>\n\n规律:**扇形的面积(度数)**,分别是0 45 90 135 180 ? 所以选A\n\n---\n\n### 案例3\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-5.jpg\" width=\"50%\"/>\n\n案例特点: 图形通过点/线连接、对称、封闭\n考点:连接方式、空间数量、对称方式、切点/切线数量、一笔画\n\n#### 点连接和线连接的定义\n- 点连接: 图形通过线连接起来,线不属于图形的边就是点连接, 如果**属于图形的公共边**(图都有这条线)就是线连接.\n  如果多个图形,有点连接也有线连接, 也属于线连接\n\n练习题: **空间数量**\n考的是空间数量, 2 4 2 2 4 4,所以134一组\n\n### 案例4\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-6.jpg\" width=\"50%\"/>\n\n案例特点: Z字形\n考点:几组平行线,常见的图案 `Z N H I M、梯形、平行四边形、长方形等`,要想到考几组平行线(注意: 数几组一般是,2条线数过了,就不算了(不能说这条线和多条线平行就算多组))\n练习题: **平行线**\n规律:左边都是2组平行线,右边都是3组,所以选A\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-6-1.jpg\" width=\"50%\"/>\n\n规律:都是 1 2 3组平线线,所以选C\n\n## 总结\n\n- 看到图形里含有直角三角形或者规则的直角(L T +、正方形等),要想到考直角数量、直角三角形数量\n- 看到扇形,要想到考扇形面积(度数)、曲直数量、对称\n- 看到Z字形或常见的(Z N H I M、梯形、平行四边形、长方形等),要想到考几组平行线\n\n## 案例\n\n### 案例5\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-7.jpg\" width=\"50%\"/>\n\n案例特点:黑白点,轮廓不规则(啥意思呢,可以对比下面黑白点例子就知道轮廓规不规则了)、黑白的数量不相等\n考点:黑白分割区域数量即空间数、黑色/白色一笔画\n练习题: **一笔画**\n126黑色都是2笔画,345黑色都是1笔画\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-7-1.jpg\" width=\"50%\"/>\n\n规律: **黑白分割区域数量即空间数**\n两组都是由黑色区域分割为: 3 2 1, 所以选D\n\n### 案例6\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-8.jpg\" width=\"50%\"/>\n\n案例特点:黑白点,轮廓规则(**这里就能看出来了,上面一看就不规则,这个就是规则的**)、黑白数量不等\n考点:黑白分割区域数量即空间数、黑色/白色一笔画、对称(因为规则了)、位置传递\n\n练习题: **分割区域空间数**\n规律: 1 2 3 4 ?,所以选D\n\n---\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-8-1.jpg\" width=\"50%\"/>\n\n规律: **位置传递**\n1、2图相对比,只有第一行图形变化;\n2、3图相对比,只有第二行图形变化\n3、4图相对比,只有第三行图形变化\n4、5图相对比,只有第四行图形变化\n所以选C\n\n---\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-8-2.jpg\" width=\"50%\"/>\n\n规律: **对称性**\n1、4、6黑色对称\n2、3、5白色对称\n\n---\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-8-3.jpg\" width=\"50%\"/>\n\n规律: **空间数+黑白数量是否一致**\n空间数都是2, 所以只有B、D符合,但是黑色都是3个,所以选D\n\n### 案例6\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-9.jpg\" width=\"50%\"/>\n\n案例特点: 阴影数量一致(上图都是2黑点)、轮廓一致(都是n*n)\n考点:元素位置考法, 一般我们按行、列、对角线去找黑点数量不变\n练习题: **元素位置**\n规律: 第四列每次移动一个,对角线也是每次移动一个, 所以选A\n\n### 案例7\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/3-10.jpg\" width=\"50%\"/>\n\n案例特点: 轮廓一致、黑白点、相连接\n考点: 点连接、线连接、黑白点数\n练习题: **点连接+黑白点数量**\n规律: 都是点连接,所以CD符合,但是黑块数量是5,所以选C\n\n## 总结\n\n- 看见黑白点,且轮廓不规则、黑白数量不一致, 要考虑一笔画、黑白空间数\n- 看见黑白点,且轮廓规则、黑白数量不一致, 要考虑一笔画、黑白空间数、黑白对称、位置传递(如两两对比,可能依次第一行、第二行、第三行变化了)\n- 看见黑白点,且轮廓规则、黑白数量一致, 要考虑元素位置(如行、列、对角线移动)\n- 看见黑白点,如果有明显的点连接, 要考虑点连接+选项黑白数量是否和题目一致\n- 看见黑白点,要考虑黑白数量个数变化,如第一个+第二个=第三个总数\n- 看见黑白点,要考虑黑白颜色变化,如第一个和第二个颜色到第三个颜色反了\n\n### 回顾之前黑白规律\n\n- 黑白logo图,要考虑部分数量(几部分)、 是否分离(分离和一个整体)、对称","categories":["gwy","LFTT"]},{"title":"基础-2","url":"/ypf-blog/2023/12/26/gwy/LFTT/基础-2/","content":"## 案例\n### 案例1\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/2-1.jpg\" width=\"50%\"/>\n\n上图特点**田字格**,可以考 **一笔画(2),对称、空间数量(4)**\n所以例子:\n对称:很明显第五个不是\n笔画数:都是1,选项笔画数 2 2 2 1,所以选D\n\n### 案例2\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/2-2.jpg\" width=\"50%\"/>\n\n上图特点,1笔画、纯封闭、对称,相当于奥迪最后一个圈,少了一半,但还是1笔画.\n\n### 案例3\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/2-3.jpg\" width=\"50%\"/>\n上图都是线条,最先想到是\n\n**交点数量、一笔画、曲直定性**\n\n例子,都是1笔画,选项笔画数是2 1 2,所以选中间那个\n注意,第2个图:去除圆,去除五角星,就剩一个箭头,所以是1笔画.\n\n### 案例4\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/2-4.jpg\" width=\"50%\"/>\n\n- 案例:1笔画,3条线,6交点,7空间\n- 左下角:1笔画,3条线,6交点,4空间\n例子:笔画数:1 1 2 2 1 ?\n    交点数:2 3 4 5 6 \n所以,选项交点数为 18 8 7 8,选C\n\n**注意,笔画数一般不会考计算,如1+1=2 或者 11 22 11这种数列**\n\n### 案例5\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/2-5.jpg\" width=\"50%\"/>\n\n案例规律: **两个相同的元素组成,十分容易出现三角形,所以此时要注意三角形数量**\n所以测试题目:\n三角形数量: 1 2 3 4 5 ?, 所以选B,三角形数量为6\n### 案例6\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/2-6.jpg\" width=\"50%\"/>\n\n这里图形的主要特点 **纯封闭、复杂程度不单调**.啥叫复杂程度不单调,目前我仍不太理解,只是解析说图形由 `简单->复杂->简单或者复杂->简单->复杂`.\n比如案例,第一个很简单,第二个就复杂了,第三个又简单了.\n**此时考点一般是内外元素关联考法**,比如外轮廓线数量-内部空间数量=固定值.\n所以下方测试题目:\n规律都为 **外轮廓线数量-内空间数=2**,所以选C\n\n--- \n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/2-6-1.jpg\" width=\"50%\"/>\n\n上图规律也是 **外轮廓线数量-内部空间数量=固定值0**,所以选C\n\n--- \n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/2-6-2.jpg\" width=\"50%\"/>\n\n上图规律是 **外轮廓线数量-内部最大空间轮廓数量=固定值0**,注意上面是自己画的图,第三个的平行四边形是连着的,没画好.\n\n\n## 总结\n\n1. 看到**田字格**优先考虑一笔画、对称、空间数\n2. 看到**奔驰、奥迪**以及这两种的**变形**,比如奥迪少了个圈,奔驰变成Y等,优先考虑一笔画\n3. 看到**线条、出头**,优先考虑交点数、1笔画、空间数\n4. 看到**相同图形交错**,考虑三角数\n5. 看到**纯封闭,图形简单复杂变化**,考虑 **关联考法**\n   - 外轮廓线条数-内部空间数\n   - 外轮廓线条数-内部最大/最小空间轮廓数量等\n\n\n","categories":["gwy","LFTT"]},{"title":"基础-1","url":"/ypf-blog/2023/12/25/gwy/LFTT/基础-1/","content":"## 案例\n### 案例1\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/1-1.jpg\" width=\"50%\"/>\n\n上图可以看出的角度:\n- 空间数量:**3个**, 圆把正方形分割成了3个空间\n- 中心对称\n- 一笔画\n- 相切(切点数),2个\n\n#### 什么一笔画?\n\n何为笔画数? 即将封闭图形去掉,剩下的笔画数量,即为几笔画(如果剩下0,也为1笔画).**注意,为同一个空间,如果2个没有交集的图形,分开数**.\n所以上图,去除长方形、圆形,没有了,所以为1笔画.\n\n所以,上图下方关联图形,笔画数量为: **1 1 1**\n#### 中心对称、轴对称?\n\n中心对称: 把一个图形**绕某一点**旋转180度后能与另一个图形重合，这两个图形成中心对称.\n轴对称: 一个图形**沿一条直线**折叠,如果重合,则，这两个图形成中心对称.\n\n### 案例2\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/1-2.jpg\" width=\"50%\"/>\n\n分析上面图形:\n- 笔画数: 1 1 2 1 ? 1\n- 空间数: 2 3 4 2 ? 4\n\n所以选B\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/1-2-1.jpg\" width=\"50%\"/>\n上图笔画数都是1,\n切点数: 1 1 2 1 2 2,所以 3,5,6一组.\n\n### 案例3\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/1-3.jpg\" width=\"50%\"/>\n\n分析上面图形:\n笔画数: 2 1 2 1 2 ?\n但是看下图笔画数是1的有A B D,所以我们还有一个规律 **曲直定性-纯直、曲直、纯曲**,所以选A\n\n### 案例4\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/1-4.jpg\" width=\"50%\"/>\n笔画数:1 1 1 1 1 ?\n看选项笔画数: 2 2 1 2, 所以选C\n\n### 案例5\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/1-5.jpg\" width=\"50%\"/>\n需要记住的是,上图\n笔画数:2\n面数:3\n交点数:7\n线条数:9\n\n如果考内外结构, 上图 **内部3条线,外部6条线,类似拍扁奔驰的标志**\n### 案例6\n\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/1-6.jpg\" width=\"50%\"/>\n\n上图案例, 我们可以看到2个特点(**出头、轮廓对称**),可能的考点:\n\n- 一笔画\n- 交点数量\n- 轮廓对称轴与线的位置\n\n所以上面第一道列子:\n笔画数: 全部都是1\n分组: 3、4、6为一组,都存在对称轴与线垂直\n### 案例7\n<img src=\"/ypf-blog/assets/images/gwy/LFTT/1-7.jpg\" width=\"50%\"/>\n\n上图事例特点:**可以看做奥迪图标**\n笔画数都是1,所以选B\n\n## 总结\n\n1. 看到**封闭图形、出头、对称图形**要想到**1笔画、切点数量、轮廓和线的对称性, 以及曲直定性-纯直、纯曲、曲直**\n2. 看到题目或选项有**标志图形**,如奥迪（一笔画）、奔驰（2笔画）、田字格（2笔画），要想到考1笔画。\n\n","categories":["gwy","LFTT"]},{"title":"进程与线程","url":"/ypf-blog/2023/12/25/浏览器/进程与线程/","content":"\n## 什么是进程\n\n查阅百度定义。\n\n- 进程：是系统对程序进行资源分配和调度的基本单位，是操作系统结构的基础。\n\n- 线程：程序执行流的最小单元。\n\nWhat?什么意思，我不理解。那么直接看例子。平常我们在使用电脑过程中，假如我想登录微信，那么我双击微信图标登录即可。从表面上看，桌面打开了微信界面。实际上，系统也相应的开启了一个进程（一个程序可能会有多个进程，比如qq主进程，qq辅助进程等）。系统会给进程分配相应的cpu资源以及内存资源来保证进程运行。\n\n\n我们来打开任务管理器，我事先已经打开了谷歌浏览器，可以看到，任务管理器中也会有浏览器相对应的进程，以及该进程的cpu占用率、内存占用资源。\n\n<img src=\"images/task.png\"/>\n\n## 什么是线程\n\n现在应该理解进程是什么意思了吧，那么线程又是什么鬼？\n\n实际我们一个程序对应一个进程（这里直接按对应一个来举例），进程也可以细分即线程。比如我通过微信正在聊天，我想看看朋友圈，相应的微信进程会分配朋友圈线程来执行（当然系统的微信进程不会直接分配线程，其内部也有自己的各个主进程来分配协调线程，分配内存等，如分配朋友圈线程）。即进程是种类，线程是种类下的具体列表。进程管理着线程。\n> 即公司（系统）- 各个部门（系统任务管理器的微信进程）-部门领导（微信进程中负责协调线程的主进程）-员工（线程）\n\n\n所以，应该更容易理解了：进程是cpu资源分配的最小单位（系统会给它分配内存）\n最后，再用较为官方的术语描述一遍：\n- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n\n理解了进程和线程，我们来看{% post_link 浏览器/浏览器进程 下一篇-浏览器进程 %}。\n\n\n\n\n\n\n\n\n\n\n","categories":["浏览器"]},{"title":"零宽字符","url":"/ypf-blog/2023/12/25/每日一练/零宽字符/","content":"  \n## 什么是零宽字符\n\n> 零宽字符是Unicode字符集中一类特殊的字符，叫 ZWJ（zero width joiner），也叫非打印字符、不可见字符。\n\n那什么是Unicode字符集，还有我们常听说的ASCII字符集具体是什么，这个后面会单独开一篇文章解释{% post_link javascript/字符集 下一篇-字符集 %}。\n\n## 零宽字符的特点\n\n- 对于计算机来说，它依然会占用空间，在 Unicode 字符集中拥有独立的编码，你在 Word 键入这一字符它仍会被计入字数统计，同样在代码中打印这类字符的长度可以看到也是会占用长度的。\n- 零宽字符的宽度为 0，对于肉眼而言不可见，在我们常用的一些软件中并不会显示，比如浏览器、word等。\n\n## 常见的零宽字符\n\n<table>\n<thead>\n<tr>\n  <th width=\"120\">标题</th>\n  <th>Unicode</th>\n  <th>HTML转译字符</th>\n  <th>HTML转译字符（因为不会显示，所以去除最前面的&号）</th>\n  <th>HTML预览控制台看到的代码（因为不会显示，所以去除最前面的&号）</th>\n</tr>\n</thead>\n<tbody>\n  <tr>\n    <td>零宽空格符</td>\n    <td>U+200B</td>\n    <td>&#8203;</td>\n    <td>#8203;</td>\n    <td>ZeroWidthSpace;</td>\n  </tr>\n  <tr>\n    <td>零宽非断开空格符</td>\n    <td>U+FEFF</td>\n    <td>暂没查到</td>\n    <td>暂没查到</td>\n    <td>ZeroWidthSpace;</td>\n  </tr>\n  <tr>\n    <td>零宽不连字符</td>\n    <td>U+200C</td>\n    <td>&#8204;</td>\n    <td>#8204;</td>\n    <td>zwnj;</td>\n  </tr>\n  <tr>\n    <td>零宽连字符</td>\n    <td>U+200D</td>\n    <td>&#8205;</td>\n    <td>#8205;</td>\n    <td>zwj;</td>\n  </tr>\n  <tr>\n    <td>左至右符号</td>\n    <td>U+200E</td>\n    <td>&#x200E; 或 &#8206;</td>\n    <td>#x200E; 或 #8206;</td>\n    <td>lrm; 或 lrm;</td>\n  </tr>\n  <tr>\n    <td>右至左符号</td>\n    <td> U+200F</td>\n    <td>&#x200F; 或 &#8207;</td>\n    <td>#x200F; 或 #8207;</td>\n    <td>rlm; 或 rlm;</td>\n  </tr>\n  <!-- <tr>\n    <td>字节顺序标记</td>\n    <td>U+FEFF</td>\n    <td>无</td>\n    <td>无</td>\n  </tr> -->\n</tbody>\n</table>\n\n具体解释下：\n- 零宽空格符：用于单词的换行分隔\n- 零宽空格非断符：用于阻止特定位置的换行分隔\n- 零宽不连字符：放在两个字符之间，抑制本来会发生的连字\n- 零宽连字符：使两个本不会发生连字的字符产生了连字效果\n- 左至右符号：用于计算机的双向文稿排版中。\n- 右至左符号：用于计算机的双向文稿排版中。\n\n\n## 如何输入零宽字符\n\nhtml中需要使用HTML转译字符\n```html\n<div>&#8203;12</div>\n```\njs中需要使用Unicode码并做下处理(将上面表格的Unicode码`增加 \\ 并去除+号`),大小写无所谓都可以\n\n```js\nconsole.log('\\u200b');\n```\n\n## 作用\n\n### 选中分隔\n\n```html\n<div>1234</div>\n```\nhtml中有个1234，用户双击，会选中某个整个1234，假如用户想双击12和34呢，我们可以改成即可\n```html\n<div>&#8203;</div>\n```\n\n### 加解密\n``` js \n // 加密： str -> 零宽字符\n  function strToZeroWidth(str) {\n    return str\n      .split(\"\")\n      .map(\n        (char) =>\n          char\n            .charCodeAt(0) // 每个字符转换为对应的 Unicode编码  [27979, 35797]\n            .toString(2) // 把数值转换为2进制(除了二进制，我们也可以使用更大的进制来缩短加密后的信息长度，以此提升效率) ['110110101001011', '1000101111010101']\n      )\n      .map((item) => {\n        return (\n          item\n            .split(\"\")\n            .map((item) => (item === \"1\" ? \"\\u200d\" : \"\\u200c\"))\n            // 这里按照1-零宽度连字符\\u200d\t 0-零宽度不连字符\\u200c  空格-零宽空格\\u200b ,也可以随便自定义顺序\n            // [\n            //   [\"​\",\"​\",\"‌\",\"​\",\"​\",\"‌\",\"​\",\"‌\",\"​\",\"‌\",\"‌\",\"​\",\"‌\",\"​\",\"​\"],\n            //   [\"​\",\"‌\",\"‌\",\"‌\",\"​\",\"‌\",\"​\",\"​\",\"​\",\"​\",\"‌\",\"​\",\"‌\",\"​\",\"‌\",\"​\"]\n            // ]\n            .join(\"\\u200b\")\n        ); // 数组转换为字符传，并用零宽空格连接\n      }).join(\"\\u200b\") // 数组转换为字符传，并用零宽空格连接\n  }\n\n```\n\n解密按照加密的规则进行解密\n\n","categories":["每日一练","待完善"]},{"title":"浏览器进程","url":"/ypf-blog/2023/12/25/浏览器/浏览器进程/","content":"\n\n## 浏览器有哪些进程\n\n通过{% post_link 浏览器/进程与线程 上一篇-进程与线程 %}我们了解了操作系统通过进程控制着程序的运行,程序也有自己的主进程控制线程。那么浏览器有哪些进程？\n> <b class=\"red\">1.浏览器进程（Browser进程):</b>浏览器的主进程，只有一个，（负责协调、主控）\n- 负责浏览器界面显示，与用户交互。如前进，后退等\n- 负责各个页面的管理，创建和销毁其他进程\n- 将渲染（Renderer）进程得到的内存中的Bitmap（位图），绘制到用户界面上\n- 网络资源的管理，下载等，现在已经独立出来为网络进程\n\n> <b class=\"red\">2.第三方插件进程：</b>每种类型的插件对应一个进程，仅当使用该插件时才创建\n> <b class=\"red\">3.GPU进程：</b>最多一个，用于3D绘制等\n> <b class=\"red\">4.渲染进程（Renderer进程，内部是多线程的）（即通常所说的浏览器内核）：</b>主要作用为页面渲染，脚本执行，事件处理等，我们在浏览器打开一个个tab页，就相当于创建了一个个独立的渲染进程\n> <b class=\"red\">5.网络进程：</b>负责页面中发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程\n\n**注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了，譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个渲染进程。（所以每一个Tab标签对应一个渲染进程并不一定是绝对的）**\n\n类似windows的任务管理器，我们可以打开谷歌的进程管理器。\n\n<img src=\"images/browser-task.png\"/>\n\n在上图中我们可以看到有个浏览器进程、GPU进程等非tab页面进程，但是对于我们前端才做来说，我们需要真正关系的是-渲染进程（浏览器内核），因为页面渲染，js执行，事件处理都是在这里面进行的。\n\n## 浏览器渲染进程（内核）\n\n上一节我们讲过进程和线程，所以渲染进程由线程组成。下图列出了组成：\n\n<img src=\"images/线程.webp\"/>\n\n接下来我们着重讲解浏览器内核的各个线程；\n\n### GUI渲染线程\n- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和Render树，布局和绘制等。\n- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\n- 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n\n下面我们详细讲解下一个html页面如何通过渲染进程显示出来的。\n\n#### 构建dom树\n通过 `html解析器`解析html转换成dom树。在控制台可以尝试打印document，这就是解析出来的DOM树。\n<img src=\"images/dom.webp\"/>\n\n#### 样式计算\n解析css代码，解析出样式表（CSS Object Model），给每一个节点计算出最终的样式值。在控制台打印document.styleSheets，这就是解析出的样式表。\n<img src=\"images/css.jpg\" width=\"50%\"/>\n因为涉及到CSS的继承和层叠规则，我们可以看到上图中，有个parentStyleSheet，表示此节点的父级样式。\n\n注意：DOM树 和 CSSOM编译都是以 Bytes → characters → tokens → nodes → object model. 这样的方式生成最终的数据。\n\n<img src=\"images/token.png\"/>\n\n#### DOM 和 CSSOM 合并后生成 Render树\n合并成render树后，有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout\n#### 布局定位Layout\n顾名思义就是计算出每个节点在屏幕中的位置，然后进行平面合成。具体流程如下：\n创建布局树：遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；而不可见的节点会被忽略掉，如 head 标签下面的全部内容，再比如包含 dispaly:none的元素也没有被包进布局树,而 visibility: hidden 则会（所以，如果某个节点最开始是不显示的，设为 display:none 是更优的）。然后进行布局计算，通过已经加载的js和css，计算每个dom元素在页面上的位置。\n\n#### 绘制（Painting）\nLayout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。具体如下步骤：\n\n##### 图层分层\n\n页面中有很多复杂的效果，3D变换，页面滚动，定位元素，z-index,文字内容超过容器就会产生剪裁或者出现滚动条等，都会提升为单独图层。\n\n举个🌰，\n```css\np{\n  width:10px;\n  overflow: auto;\n}\n<p>2sdsdfdsfsdfdsfdsffdsfsdfsf</p>\n```\n打开开发者工具，选择Layers，就可以看到页面的分层元素了.控制台可以360度拖动自由变换\n\n<img src=\"images/layer.gif\"/>\n\n##### 图层绘制\n\n对上面生成的每个图层进行绘制。 首先会把图层拆解成一个一个的绘制指令，按照指令顺序生成绘制列表，在上文提到的开发者工具的Layers面板中，双击图层，detail中的profiler可以看到绘制列表（绘制列表是用来记录绘制顺序和绘制指令的）。用过canvas的就可以看出来，和canvas绘制指令比较像。\n\n<img src=\"images/profiler.jpg\"/>\n\n##### 栅格化（光栅化）\n至此，**渲染进程的主线程**已经完成了它所有任务，绘制操作是由**渲染进程的合成线程**来完成的。当绘制列表完成，主线程会把绘制列表提交到合成线程，合成线程按照绘制列表将图层分为图块。然后交给GPU进程，gpu进程会开启多个线程将图块快速转换成位图。并且优先处理视口（viewport，用户可以看到的区域）的图块，最后将生成的位图保存到GPU内存中。这就叫栅格化。 所以**栅格化就是将图块生成位图，图块是栅格化的最小单位，**。\n\n##### 显示\n图块被栅格化后完成后，合成线程会拿到每个层、每个图块的位图，从而生成一个个「指引（quad）」信息。指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。变形发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因。之后，合成线程会将指令-DrawQuad并提交给浏览器主进程。浏览器主进程接收到DrawQuad指令，通知GPU进程然后将位图绘制到内存中，最后由显卡将图像信息传给屏幕。\n一般，每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，所以**通常情况下**，显卡的更新频率和显示器的刷新频率是一致的，正常显示器是60帧/s（或者60FPS）。\n\n\n\n#### 总结\n现在我们总结下：\n1. html经过html编译器**解析成dom树**\n2. 解析css，**生成CSSOM**（CSS Object Model）\n3. dom树和cssOM合**并成render树**\n4. **布局**，遍历dom树的可见节点，以及根据css和js计算节点位置\n5. **绘制**，通过显卡，把内容画到屏幕上。绘制步骤如下：\n    1. 对于定位、裁剪的元素进行**分（图）层**\n    2. **绘制图层**（图层拆分为绘制指令，按照指令顺序生成绘制列表交给合成线程）\n    3. **栅格化图层**（由合成线程按照绘制列表将图层分为图块，交给gpu进程优先按照视口区域将图块转化成位图即栅格化）\n    4. **显示**（合成线程把位图生成quad指引指令交给浏览器主进程，主进程通知gpu进程将位图绘制到位图中，最后由显卡将信息传给屏幕渲染出来）\n\n\n#### 宏观角度剖析\n\n上面我们梳理了浏览器如何渲染的，下面我们换个角度。\n\n**浏览器准备解析html时候，主进程先通过预加载扫描器扫描整个文档中的静态资源（link、script、图片，CSS ,JS，字体等资源），然后通知网络进程去请求这些资源，同时通知渲染进程开始渲染。在渲染过程中，如果已有静态资源请求结束就会立刻执行，所以就带来了阻塞性问题。**\n\n#### 问题1-css阻塞，js阻塞？\n\n我们在以前开发过程中，经常听到，把css代码放头部，js代码放底部。那么到底为啥呢？在这之前，我们先了解document的两个事件，有助于后面的分析。\n\n##### DOMContentLoaded 和 load事件\n- DOMContentLoaded事件:DOM树已经构建完毕就会触发DOMContentLoaded事件，而无需等待样式表、图像完成加载，此时可以获取到dom节点；\n- load事件：load仅用于检测一个页面是否完全加载，当页面的html、css、js、图片等资源都已经加载完之后才会触发 load 事件。\n\n##### css阻塞性\n\n先说结论，```css不会阻塞DOM解析，但会阻塞DOM渲染```\n\n\n\n\n```css不会阻塞DOM解析，但会阻塞DOM渲染，js影响dom解析和渲染```\n\n\n\n \n\n\n\n\n\n\n\n\n\n> https://zhuanlan.zhihu.com/p/481622194\n","categories":["浏览器"]},{"title":"手写代码-call、apply、bind","url":"/ypf-blog/2023/12/25/手写代码/手写代码-call、apply、bind/","content":"\n{% post_link javascript/傻傻分不清楚-call、apply、bind 傻傻分不清楚-call、apply、bind %}\n\n## 案例\n\n``` js\nconst fn1=function(a,b){\n  console.log(this,this===window,a,b) // window true 1 2\n}\nconst fn2=function(){\n  console.log(this)\n}\nfn1(1,2)\n```\n> **目的: 让fn1中的this===fn2**\n### call、apply、bind\n``` js\nconsole.log( fn1.call(fn2,1,2) )\nconsole.log( fn1.apply(fn2,[1,2]) )\nconsole.log( fn1.bind(fn2,1,2)() )\n```\n所以,这个三个函数目的就是 ```被执行函数中的this === 传递过来的第一个参数``` ,即改变了this的指向\n\n\n## 手写代码\n\n### call\n\n``` js\nFunction.prototype.call1=function(context,...args){\n  context=context||window\n  context.fn=this\n  const result=context.fn(...args)\n  delete context.fn\n  return result // 函数有可能有返回值,返回出来\n}\n```\n### apply\n\n``` js\nFunction.prototype.call1=function(context,args=[]){\n  context=context||window\n  context.fn=this\n  const result=context.fn(...args)\n  delete context.fn\n  return result\n}\n```\n### bind\n\n``` js\nFunction.prototype.bind1=function(context,...args){\n  context=context||window\n  context.fn=this\n  return function (){\n    return context.fn(...args)\n  }\n  //  无法执行删除了\n  delete context.fn\n}\n```\n上面因为要return函数,无法删除了,多了冗余代码.\n\n现在我们复盘下上面三个手写函数, 有没有发现什么不足?\n\n## 改善点\n\n### context=context || window ?\n\n我们通过`context=context || window`判断传递过来的this指向, 假如我们这样使用\n``` js\nconst fn1=function(){\n  console.log(this) // Number{0} 基本类型包装对象,相当于 new Number(0)\n  console.log(new Number(0)) // Number{0}\n}\nfn1.call(0,1,2)\n```\n<img src=\"images/number.jpg\" width=\"50%\"/>\n\n\n- context不传，或者传null，undefined， 函数中的this指向window对象\n- context为原始值（数字，字符串，布尔值），函数中this指向该原始值的自动包装对象（如 String、Number、Boolean）\n- context为一个对象，函数中的this指向这个对象\n- context为一个函数名，函数中的this指向该函数\n- 前四点是默认在非严格模式下，如果在严格模式下，会略有不同。\n\n所以我们上面判断,传0 ,false 都是使this指向window, 我们需要改下 `context=`\n\n``` js\n    if (context === null || context === undefined) {\n        context = window // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)\n    } else {\n        context = new Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象,new可以省略\n    }\n```\n\n不知道啥意思的,可以看看 {% post_link javascript/傻傻分不清楚-Object()、{}、new Object()、Object.create() 傻傻分不清楚-Object()、{}、new Object()、Object.create()%}\n\n### context.fn?\n\n我们在代码里创建了一个临时函数fn并赋值this, 那假如context本来就存在一个名字为fn的属性呢,这样就会被覆盖掉了,所以我们使用`Symbol`进行改写.\n\n``` js\n    Function.prototype.call1 = function (context, ...args) {\n      if (context === null || context === undefined) {\n        context = window // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)\n      } else {\n        context = new Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象,new可以省略\n      }\n      const fn=Symbol()\n      context[fn] = this;\n      const result=context[fn](...args);\n      delete context[fn];\n      return result\n    };\n```\n\n### bind\n\n上面bind我们发现没发删除fn了,那我们不用fn不就行了,我们改写下:\n\n\n``` js\nFunction.prototype.bind1=function(context,...args){\n  if(context===null || context===undefined){\n    context=window\n  }else{\n    context=Object(context)\n  }\n  const that=this\n  return function (){\n    console.log(this===window) // true, 或者用箭头函数,就不需要用that存了\n    return that.apply(context,args) // 必须return,因为函数可能有返回值\n  }\n}\n```\n\n> https://juejin.cn/post/6844903906279964686#heading-17","categories":["手写代码"]},{"title":"2.数据劫持-对象","url":"/ypf-blog/2023/12/25/vue2源码/2.数据劫持-对象/","content":"{% post_link vue2源码/1.rollup搭建环境.md  上一篇-vue2源码/1.rollup搭建环境.md %}\n\n## 初始化数据\n\n``` js\n修改src/index\nimport { initMixin } from \"./init\";\nfunction Vue(options) {\n  this._init(options); // 初始化参数\n}\ninitMixin(Vue)\nexport default Vue;\n```\n那么上面的`_init`从哪里来? 我们新建`init.js`,可以看到我们给vue的原型上绑定了该方法\n\n``` js\nsrc/init\nimport { initState } from \"./state\";\nexport function initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this;\n    vm.$options=options // 将options挂载到实例上\n    initState(vm); // 初始化数据\n  };\n}\n```\n\n我们新建`state.js`\n\n```js\nimport { observe } from \"./observer/index\";\nexport function initState(vm) {\n  const opts = vm.$options;\n  if (opts.props) {\n    initProps(vm);\n  }\n  if (opts.methods) {\n    initMethods(vm);\n  }\n  if (opts.data) {\n    initData(vm);\n  }\n  if (opts.computed) {\n    initComputed(vm);\n  }\n  if (opts.watch) {\n    initWatch(vm);\n  }\n}\nfunction initData(vm) {\n  let data = vm.$options.data;\n  //   需要call, 否则 data(){ }中的this为window\n  data = vm._data = typeof data === \"function\" ? data.call(vm) : data;\n  //   数据劫持\n  observe(data);\n}\n```\n\n## 数据劫持\n我们新建`observer/index.js`\n\n```js\nobserver/index.js\nexport function observe(data) {\n  // 注意， typeof null 也是object, Object.keys(null)会报错, 不能遍历，所以需要判断直接返回\n  if (typeof data !== \"object\" || data === null) {\n    return data;\n  }\n  return new Observer(data);\n}\n\nclass Observer {\n  constructor(value) {\n    this.walk(value);\n  }\n  walk(data) {\n    Object.keys(data).forEach((key) => {\n      defineReactive(data, key, data[key]);\n    });\n  }\n}\nfunction defineReactive(obj, key, value) {\n  observe(value); // 对象如果又嵌套对象\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get() {\n      console.log(\"获取值\");\n      return value;\n    },\n    set(newValue) {\n      if (value === newValue) {\n        return;\n      }\n      console.log(\"更新值\");\n      observe(newValue); // 更改属性值为新对象,默认不会劫持,所以需要重新劫持\n      value = newValue;\n    },\n  });\n}\n```\n\n目录结构\n<img src=\"images/dir.jpg\" width=\"50%\"/>\n\n\n\n我们修改index.html\n\n```js\n   const aa= new Vue({\n      el: \"#app\",\n      data() {        \n        return {\n          a: 1,\n          b: [1, 2, 3],\n          c: {\n            key: 1,\n            d:{\n              key:1\n            }\n          },\n        };\n      },\n    });\n    console.log(aa,aa._data);\n    aa._data.a={\n      c:2\n    }\n\n```\n<img src=\"images/object.jpg\" width=\"50%\"/>\n\n我们可以发现, 对象都被绑定上get、set函数,修改或者获取对象属性,都会出发get、set方法.至此我们完成了**对象的劫持**\n\n## 注意\n\n###  更改属性要重新劫持\n### data为什么用函数return对象,而不是直接用对象?\n- 如果 data 属性是一个简单的对象，那么所有的组件实例都将共享同一个对象，对象属于引用类型，会影响到所有的实例。如果使用函数,每复用一次组件就会返回新的data，类似于给每个组件实例创建一个私有的数据空间，保护各自的数据互不影响。\n- 如果不考虑组件,那data直接用对象也没问题\n- 上面源码我们也可以看到,我们还在`vm._data`绑定了data, 都是指向同一内存地址","categories":["vue2源码"]},{"title":"前端安全-CSRF攻击","url":"/ypf-blog/2023/12/25/javascript/前端安全-CSRF攻击/","content":"{% post_link javascript/前端安全-XSS攻击 上一篇-前端安全-XSS攻击 %}\n\n## csrf攻击定义\n\n> csrf 全称跨站请求伪造（Cross-site request forgery），指的是攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送请求(利用受害者在被攻击网站已经获取的注册凭证(存放在cookie中))，达到冒充用户对被攻击的网站执行某项操作的目的。\n\n一个典型的CSRF攻击有着如下的流程：\n\n- 用户登陆`a.com`,此时cookie中该域名下有登陆token\n- 攻击者诱导用户进入`b.com`\n- 在`b.com`中,含有自动请求`a.com`的代码,如 `<img src=\"http://a.com?a=1\">`\n- 我们知道浏览器发送请求会在header自动带上请求域名的cookie\n- 这样就在b.com完成了a.com的攻击\n\n关键点:\n1. 登陆信息存在token中\n2. 如何诱导用户进入攻击网站\n3. 浏览器发送请求会在header自动带上请求域名的cookie\n4. 在攻击网站发送受害者网站的请求\n\n## 几种常见的攻击类型\n举个例子,用户登陆银行网站进行提取操作, 此时正常触发 `http://bank.example/withdraw?amount=10000`\n\n### GET类型的CSRF\n\nGET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：\n```html\n<img src=\"http://bank.example/withdraw?amount=10000&for=hacker\" >\n```\n\n在受害者访问含有这个img的攻击页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次请求。\n\n### POST类型的CSRF\n这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：\n```html\n<form action=\"http://bank.example/withdraw\" method=POST>\n    <input type=\"hidden\" name=\"account\" value=\"xiaoming\" />\n    <input type=\"hidden\" name=\"amount\" value=\"10000\" />\n    <input type=\"hidden\" name=\"for\" value=\"hacker\" />\n</form>\n<script> document.forms[0].submit(); </script> \n```\n用户访问攻击页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。\n\n### 链接类型的CSRF\n链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：\n\n``` html\n <a href=\"http://bank.example/withdraw?amount=1000&for=hacker\" taget=\"_blank\">\n  重磅消息！！\n  <a/>\n```\n\n## 如何防护\n上面我们知道,csrf是在攻击者网站发起攻击,那么我们禁止在外域（或者不受信任的域名）中对我们发起请求,不就可以吗?\n\n### GET接口只用于查询，不要用于任何写入操作\n上面我们讲了通过img标签进行攻击,这是 GET 型 CSRF 攻击的要害，千万不要在 GET 请求中做修改数据库、更新状态等类似操作，只要 GET 请求仅用于查询，即可有效防御此类攻击。\n\n\n### 同源检测\n那么问题来了,我们如何判断请求是否来自外域呢？\n- Origin Header\n- Referer Header\n在HTTP协议中，每一个请求都会携带两个Header，用于标记来源域名,这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。从而阻止不受信任的域名.具体这两个的区别,可以看这篇文章[origin 、referer]()\n\n当Origin和Referer头文件不存在时该怎么办？\n\n### CSRF Token(JWT认证)\n\n前面讲到用户信息是存放在cookie中随浏览器请求发出的,那么我们可以要求所有的用户在请求时候,都携带一个的Token单独放到请求参数里面,并在服务器端验证该 token，则能够防御 CSRF 攻击,例如\n\n```js\n  GET http://bank.example/withdraw?amount=1000&csrfToken=xxx\n  POST http://bank.example/withdraw\n       将 token 放在 Authorization 头部传递给后端做验证。\n```\n用户登录后，服务端生成 token 并放在 session 中，后面该用户的每个请求都从 session 拿出这个 token，与请求中的 csrfToken 进行比对，若不一致则拒绝请求。\nToken是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。\n\n### cookie的SameSite属性\n\n[cookie的SameSite属性]()\n\n\n\n\n## 记录下小知识点\n\n1. form的action和src、href一样不受同源限制的影响,可跨域\n2. 我们在跨域请求时,浏览器会提示CORS跨域错误,实际上后台已经接收到请求并响应,只不过浏览器拦截掉罢了\n\n---\n> [前端安全系列之二：如何防止CSRF攻击？](https://juejin.cn/post/6844903689702866952)\n   \n\n","categories":["javascript"]},{"title":"前端安全-XSS攻击","url":"/ypf-blog/2023/12/25/javascript/前端安全-XSS攻击/","content":"\n## XSS攻击是什么?\n\n### XSS定义\n\n>XSS攻击,中文名叫跨站脚本(Cross Site Script)攻击,缩写应该是 CSS，但是为了和 CSS(Cascading Style Sheet)层叠样式有所区别，所在在安全领域叫做 “XSS”。\n\n### XSS分类\n- 反射型XSS（Reflected XSS）\n- 存储型XSS（Stored XSS）\n- DOM-based XSS\n\n下面我们来一一介绍\n## 反射型XSS（Reflected XSS）\n\n顾名思义，反射型 XSS，只是将用户输入的数据“反射”给浏览器。其是一种非持久型xss攻击，依赖于**服务器**对恶意请求的反射,仅对当次的页面访问产生影响\n常见于通过 URL 传递参数的功能，如网站搜索、跳转等场景。\n\n攻击步骤如下:\n1. 攻击者构造含有script脚本的恶意链接,诱导用户点击\n2. 用户点击后,服务端取出url上的恶意代码,直接返回前端(前端通过innerHTML直接插入代码),或者以前的jsp模式,后端直接拼接html返回渲染,就会触发反射型XSS\n\n举个🌰:\n比如访问链接:`https://test.com/index.html?q=<script>alert(1)</script>`,页面里面含有从服务端取出content字段,并且`document.getElementById(\"seachKeyWords\").innerHTML = content`,用来展示当前搜索的内容的逻辑,这样就会触发**反射**.\n\n## 存储型 XSS（Stored XSS）\n\n顾名思义，存储型 XSS，就是攻击者的数据已经存储在服务端，比如用户在文本框中输入评论，然后提交保存到后台。然后其他用户浏览评论，导致触发存储型 XSS。其是一种持久型xss,攻击时效将伴随着攻击数据一直存在。\n常见于带有用户保存数据的网站功能，比如论坛发帖、商品评价、用户私信等场景。\n\n攻击步骤如下:\n1. 攻击者将恶意代码作为参数提交到目标网站的数据库中\n2. 用户访问页面,页面渲染接口返回的数据触发xss,如果多用户可以访问,都会触发\n   \n举个🌰:\n比如用户评论某篇文章, 评论内容是`<script>alert(1)</script>`,提交到后台,前端通过innerHTML直接渲染到评论区,那么所有用户访问该评论区,都会alert,所以存储型 XSS一旦被发现,影响巨大\n\n## DOM-based XSS\n\n从效果上看,DOM-based XSS其实也属于反射型XSS,但是其区别是, 反射型的xss脚本来自于服务端(如前端提交到后台,后台处理后返回), dom型的xss脚本来自于前端,和服务端没关系,dom型属于前端自身的漏洞,和后端没关系.\n常见于从URL参数、cookie、LocalStorage中取内容的场景。\n\n攻击步骤如下:\n1. 前端 JavaScript 取出 URL中的恶意代码\n2. innerHTML插入代码导致渲染触发xss\n\n举个🌰:\n比如访问链接:`https://test.com/index.html?q=<script>alert(1)</script>`,页面里面含有直接从url上取出content字段,并且`document.getElementById(\"seachKeyWords\").innerHTML = content`,用来展示当前搜索的内容的逻辑,这样就会触发 DOM-based XSS\n\n## 如何触发、危害?\n\n\n### 如何触发\n\n1. 反射型和dom型,难点在于构造恶意链接如何让用户去点击,所以常见的方式是通过邮箱、短信等发送给用户,诱导用户点击\n2. 存储型依靠代码漏洞,通过提交恶意数据到数据库来触发\n\n### 危害\n\n1. 窃取用户信息进行违法行为\n2. 引流(嵌入重定向脚本)\n\n## 常见XSS代码方式?\n\n<!-- <div style=\"background-url:(javascript:alert(1))\" aa=\"<script>alert(1)</script>\">22</div> -->\n<!-- <div style=\"background:url(javascript:alert(1))\">1</div> -->\n<!-- <div class=\"javascript:alert(1)\">1</div> -->\n<!-- <div class=\"<script>alert(1)</script>\">2</div> -->\n<!-- <div class=\"\"><script>alert(1)</script>\">2</div> -->\n<!-- <img src=\"javascript:alert(&lt;p&gt;hello&lt;/p&gt;)\"> -->\n<!-- text-size: \"expression(alert('XSS'))\";  -->\n<!-- <img onclick=\"alert(1)\" onerror=\"alert('&lt;p&gt;hello&lt;/p&gt;')\" src=\"error.png\"> -->\n<!-- <img oNcLiCk=\"alert(1)\" onerror=\"alert(2)\" src=\"error.png\"> -->\n<!-- <script>new Function(\"alert(1)\")</script> -->\n\n\n\n\n\n```html\n html\n// 内联事件监听器中包含恶意代码\n<img oNcLiCk=\"alert(1)\" onerror=\"alert(2)\" src=\"error.png\">\n// 恶意代码经过htmlEncode编码后 https://tool.chinaz.com/tools/htmlencode.aspx\n<img onclick=\"alert(1)\" onerror=\"alert('&lt;p&gt;hello&lt;/p&gt;')\" src=\"error.png\">\n// 链接内包含恶意代码 \n<a href=\"javascript:alert(1)\">1</a>\n// 大小写、空格/回车/tab等\n<a href=\"JAvaScript:    alert(1)\">1</a>\n// 带有脚本代码的svg图片,通过embed标签加载\n<embed src=\"https://svg.digi.ninja/xss.svg\" type=\"\" />\n// background:url标签/style标签里面使用background:url(谷歌内置拦截器会拦截)\n<div style=\"background:url(javascript:alert(1))\">1</div>\n// 在属性中增加闭合标签\n<div class=\"<ScRipt>alert(1)</script>\">2</div>\n我们在<script>前面增加 \"> 代码就变成\n<div class=\"\"><script>alert(1)</script>\">2</div>\n\n\njs\n<script>\n// setTimeout() 中调用恶意代码\nsetTimeout(\"alert(1)\")\n// setInterval() 中调用恶意代码\nsetInterval(\"console.log(2)\",1000)\n// location 调用恶意代码\nlocation.href = 'javascript:alert(1)'\n// open 调用恶意代码\nwindow.open('javascript:alert(1)')\n// eval() 中调用恶意代码\neval(\"alert(1)\")\n</script>\n\n```\n\n谷歌内置拦截器会拦截background:url标签\n<img src=\"images/background.jpg\" width=\"50%\" height=\"50%\"/>\n\n总结下:\n1. 避免html内联事件绕过:如 onclick、onerror、onload、onmouseover 等,在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全\n2. 在插入html属性要做过滤处理\n3. a标签的href、img的src、background的url\n4. svg图片含有js代码\n5. JavaScript 的 eval()、setTimeout()、setInterval()、location.href、windowopen 等都能把字符串作为代码运行 \n**注意:** 谨慎使用.innerHTML、.outerHTML、document.write() ，不要把不可信的数据作为 HTML 插到页面上。如果使用的模版,比如ejs,尽量使用 <%= data %> 而不是 <%- data %>； 如果使用框架(vue),尽量使用`{{}}`,少使用v-html ;\n\n\n\n## 如何防御?\n\n上面我们讲了常见的xss代码攻击方式,那么我们如何防御呢?\n**1.转义字符**\n对于用户的输入应该是永远不信任的，最普遍的做法就是转义输入输出的内容，对于括号，尖括号，斜杠进行转义\n\n``` javascript\nfunction escape(str) {\n  str = str.replace(/&/g, '&amp;')\n  str = str.replace(/</g, '&lt;')\n  str = str.replace(/>/g, '&gt;')\n  str = str.replace(/\"/g, '&quto;')\n  str = str.replace(/'/g, '&#39;')\n  str = str.replace(/`/g, '&#96;')\n  str = str.replace(/\\//g, '&#x2F;')\n  return str\n}\n// -> &lt;script&gt;alert(1)&lt;&#x2F;script&gt;\nescape('<script>alert(1)</script>')\n\n```\n\n实际上,我们需要根据具体场景使用不同的转义规则\n常用的前端插件有 [xss.js](https://jsxss.com/zh/index.html)，[DOMPurify](https://github.com/cure53/DOMPurify)\n\n\n\n\n**2.设置Cookie httpOnly**\n禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法document.cookie获取cookie\n\n**3.输入内容长度、类型的控制**\n对于不受信任的输入，都应该限定一个合理的长度，并且对输入内容的合法性进行校验（例如输入email的文本框只允许输入格式正确的email，输入手机号码的文本框只允许填入数字且格式需要正确）。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。\n\n**4.CSP**\n[内容安全策略(Content-Security-Policy)]()\n\n\n## vue XSS?\n\n<img src=\"images/vue.png\" width=\"50%\" height=\"50%\"/>\n我们在使用vue中,常用的插入内容标签有\n ``` javascript \n {{ }}\n v-html\n```\n我们找到双括号源码,发现,vue是通过createTextNode生成文本字符串,所以不会存在xss, 不过v-html是有风险的,需要谨慎使用 .\n<br/>\n<br/>\n\n{% post_link javascript/前端安全-CSRF攻击 下一篇-前端安全-CSRF攻击 %}\n\n---\n\n\n>[前端安全系列（一）：如何防止XSS攻击？](https://juejin.cn/post/6844903685122703367)\n>[xss的绕过方式](https://blog.csdn.net/weixin_55821558/article/details/123534829)\n>[掀起XSS的盖头来](https://juejin.cn/post/6844904122429210638#heading-9)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["javascript"]},{"title":"图片预加载与懒加载","url":"/ypf-blog/2023/12/25/javascript/图片预加载与懒加载/","content":"\n>预加载和懒加载的字眼总会看到。其实预加载和懒加载不仅仅是用于加载图片资源。其他资源，文字，视频。都可以。但实际工作过程中，我们较常用或较需要使用的场景就是加载图片资源。\n\n## 什么是图片懒加载?\n\n懒加载，也叫延迟加载图片资源，指的是图片在可视范围才进行加载。一般图片较多的电商网站用的比较多。\n\n### 原理\n1. 所有img标签的src设置loading.gif，真实的url放到自定义属性上，如`<img src=\"loading.gif\" data-src=\"1.jpg\"/> <img src=\"loading.gif\" data-src=\"2.jpg\"/>`\n2. 监听浏览器滚动事件（window.onscroll），**判断图片的位置（什么时候进入可视范围）**，去除data-src替换loading，并增加一个已经加载的属性标识如 data-lazy=\"loaded\",用来后面监听的时候不用又去替换（这个可有可无，因为图片加载过会有浏览器缓存）\n\n**注意：我们还常见很多网站，滚动后加载图片，也就是滚动翻页（当滚到头加载下一页，请求接口生成img插入到文档中），这也可以叫懒加载，只不过是后台分页，我们这里说的是我们已经有所有的图片url，前端进行懒加载**\n\n### 如何判断可视区域\n\n#### 方法1\n**A-document.documentElement.clientHeight 或者 document.body.clientHeight 可视窗口的高度**\n**B-element.offsetTop dom相对于文档顶部的距离**\n**C-document.documentElement.scrollTop 滚动条滚动的距离**\n**B - C <= A 即说明元素在可视区域内**\n#### 方法2:getBoundingClientRect\n\n`getBoundingClientRect`是原生js方法，用户获取某个元素的左，上，右和下分别相对浏览器可视窗口的位置，这个方法没有参数。 主流浏览器都支持,可以放心使用。\n\n```js\nconst rectObject = el.getBoundingClientRect(); \nrectObject.top：元素上边到视窗上边的距离;相当于第一种方法的 B-C\nrectObject.right：元素右边到视窗左边的距离;\nrectObject.bottom：元素下边到视窗上边的距离;\nrectObject.left：元素左边到视窗左边的距离;\nrectObject.width：是元素自身的宽\nrectObject.height:是元素自身的高\n```\n\n所以我们只需要判断rectObject.top<=可视窗口（document.documentElement.clientHeight）即可\n\n**注意**\n- 可视窗口不是分辨率，是浏览器html，body的区域`document.documentElement.clientHeight 或者 document.body.clientHeight`，分辨率是 `widow.screen.width window.screen.height`\n- 一般我们提前100px左右就开始加载，不会卡着点，这样页面滚动时候，图片提前加载，用户体验更好，即 B-C-100<=A\n- 我们监听onscroll事件，一般会用节流，减少触发频率，因为用户会滚动很快。\n```js\nwindow.onscroll = _.throttle(function () {\n    console.log(111);\n}, 200);\n```\n\n[vue-lazyload](https://github.com/hilongjw/vue-lazyload) 封装了vue的懒加载指令，可以自己去研究源码。\n\n## 什么是图片预加载?\n预加载，简单来说就是将所有所需的资源提前在浏览器请求，这样后面在需要用到时就直接从缓存取资源，这样能立马展示出来；\n那我们是不是可以想到，弄一个隐藏图片，先提前把资源请求过来？\n\n### 通过css预加载\n我只在chrome浏览器测试：\n```\n<img src=\"img1.jpg\" style=\"display: none\" />  \n<img src=\"img1.jpg\" style=\"visible: hidden\" /> \n<img src=\"img1.jpg\" style=\"position:absolute;z-index:-1;\" /> \n<img src=\"img1.jpg\" style=\"width:0;height:0 /> \n.test1 { background: url(bg1.jpg); display: none; }   \n```\n上面虽然通过css隐藏了元素，但资源也会加载， 这样我们可以通过上面这些css方式进行预加载图片\n\n### 通过js预加载\n1.创建dom但不插入文档\n```js\nvar el = document.createElement('div');   \nel.innerHTML = '<img src=\"img1.jpg\" />';  \n```\n2.通过`Image`也不插入文档\n```js\nconst image = new Image()\nimage.src = \"img1.jpg\"  \n```\n\n上面代码在chrome测试，虽然没有append dom节点，但也会加载图片，这样就可以达到既不插入dom，又预加载了图片。（Opera浏览器貌似必须append节点才会加载图片，没测试）\n\n\n{% post_link javascript/前端安全-CSRF攻击 拓展-预加载静态资源-preload、prefetch、dns-prefetch、defer和async %}\n","categories":["javascript"]},{"title":"HTTP缓存","url":"/ypf-blog/2023/12/25/http/http缓存/","content":"\n本片文章从2个方面理解http缓存\n> 1.缓存的分类详解     2.nginx缓存实战\n   \n## 缓存的作用\n\n- 节省带宽\n- 更快的加载页面\n- 减少服务器负载，避免服务器过载的情况出现。\n\n## 缓存的分类\n\nhttp缓存分为**强缓存和协商缓存**\n\n### 强缓存\n\n> 1.强缓存使用Expires、Cache-Control 两个头字段。\n> 2.当命中强缓存的时候，客户端不会再发请求，直接从缓存中读取内容，并返回HTTP状态码200。\n\n#### Expires\n\n具体流程如下：\n当浏览器请求服务器的时候，服务器会返回资源的同时还会带上响应头Expires，表示资源的过期具体时间，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求，可以直接在缓存里面拿。\n\n```js\n    Expires: Mon, 30 Jan 2023 06:25:20 GMT\n```\n上面例子表示缓存在2023-01-30 14:25:20过期，我们在js中可以通过 `new Date().toGMTString()` 来获取GMT时间\n> 1.它是HTTP/1.0版本中定义缓存的字段\n> 2.它表示缓存过期的**绝对**时间，是一个格林尼治(GMT)格式的标准时间。\n> 3.由服务端设置，所以它只会出现在响应头中\n\n但其存在一个缺点，\n- 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效。此外，即使不考虑用户修改，客户端和服务端时间存在时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。所以http/1.1 版本新增了Cache-Control字段。Expires和Cache-Control同时存在，Cache-Control优先级高\n\n```js\n    Cache-Control: max-age=10\n```\n上面例子表示缓存将在10s后过期（服务端第一次返回资源开始10s后）\n\n#### Cache-Control\n> 1.它是HTTP/1.1版本中定义缓存的字段\n> 2.它可以表示一个相对时间也可以设置其他值\n> 3.一般由服务度设置，客户端可以设置，所以它既能出现在请求头又能出现在响应头，代表不同意思\n\n下面是Cache-Control一些常用的属性值：\n- **max-age**: 决定客户端资源被缓存多久，单位为 **s**, 是一个相对时间。当为0的时候就是不使用强缓存，类似no-cache。\n- **no-cache**: 表示不使用本地强缓存，需要使用协商缓存。\n- **no-store**: 表示不缓存，永远从服务端拿\n- **public**: 表示资源可以被所有的用户缓存，包括终端用户即浏览器和中间代理服务器。\n- **private**: 只能被终端用户的浏览器缓存，不允许中间缓存代理进行缓存。（默认值）\n- **s-maxage**: 用于表示 cache 服务器上（比如 cache CDN，缓存代理服务器）的缓存的有效时间的，设置时候需要同时设置public，如 `Cache-Control: max-age:3600, s-maxage=3600, public `\n\n**注意：** Cache-Control的属性值，它们可以组合使用，用逗号隔开，但是no-cache和no-store是一组互斥属性，不能同时使用\n比如设置了Cache-Control:max-age=1800,即30分钟缓存. 当12:00访问,此时响应头也会有Expires字段,显示的是`Thu, 20 Feb 2025 12:30:00 GMT`的过期时间。在这中间我们访问都是强缓存, 如果12:31访问,会重新变成304协商缓存看是否更新, 然后再强缓存.\n\n### 协商缓存\n\n在强缓存失效（过期等原因，不是不存在）后，客户端会携带缓存标识向服务端发起请求，服务端会根据缓存标识决定是否使用缓存。\n\n> 协商缓存的标识字段有两组，`Last-Modified / If-Modified-Since`和`Etag / If-None-Match`，如果同时存在，Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。\n> 由服务端设置，下次请求时浏览器携带过去\n> 协商缓存生效时，状态码为304，返回的仅仅是一个状态码而已，并没有实际的文件内容，所以请求时间和资源的大小都会极大的减少\n\n#### Last-Modified / If-Modified-Since\n\n当客户端第一次请求服务器的时候，服务端会返回一个Last-Modified响应头，该字段是一个GMT标准时间。下次客户端请求服务器的时候会带上If-Modified-Since请求头字段，该字段的值就是服务器上次返回的Last-Modified的值。服务器接收到请求后会比较这两个值是否一样，一样就返回304，让客户端从缓存中读取，不一样就会返回状态码200，并返回新文件给客户端并更新Last-Modified响应头字段的值。\n\n```js\nLast-Modified: Mon, 30 Jan 2023 06:25:20 GMT\nIf-Modified-Since: Mon, 30 Jan 2023 06:25:20 GMT\n```\n但是存在一个缺点：\n\n- Last-Modified使用GMT只能精确到秒，如果一个文件在1s内进行修改，客户端在1s内进行多次请求，获取到的仍是缓存\n- 如果只单纯编辑了下文件，如编辑又撤销，并没有更新内容，Last-Modified会被更新，再次请求服务端对比时间，导致缓存失效\n\n所以为了解决上面问题，又引入了Etag 和 If-None-Match\n\n#### Etag 和 If-None-Match\n\n当客户端第一次请求服务器的时候，服务端会返回一个Etag响应头。客户端请求服务器的时候会带上If-None-Match请求头字段，该字段的值就是服务器返回的Etag的值。服务器接收到请求后会比较这两个值是否一样，一样就返回304，让客户端从缓存中读取，不一样就会返回新文件给客户端并更新Etag响应头字段的值。\n\n> Etag 是由文件内容的 hash 值和内容长度计算而成的唯一哈希值，只有当文件文件内容发生变化了Etag的值才会发生变化。\n\n虽然etag解决了上面1s内改动以及文件编辑未更新的问题，但是etag也有缺点\n\n- ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销。如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能。显然，ETag在这样的场景下就不是很适合。\n- ETag有强验证和弱验证，所谓将强验证，ETag生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。ETag还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。\n\n所以，不同于cache-control是expires的完全替代方案。ETag并不是用于last-modified的替代方案。而是last-modified的补充方案，项目中到底是用ETag还是last-modified完全取决于业务场景，这两个没有谁更好谁更坏\n\n### 缓存到底存在哪？\n\n上面我们讲了缓存，那么缓存到底存在哪？浏览器？电脑硬盘？\n实际上，我们可以在浏览器控制台看到缓存的存储方式。\n\n<img src=\"images/network.jpg\" />\n\n- **memory cache**: 内存中的缓存，按照操作系统的常理：先读内存，再读硬盘。\n- **disk cache**: 硬盘上的缓存\n- **Service Worker**: js中的service worker，因为上面2种缓存方式是浏览器自己的行为，浏览器自己控制从内存还是硬盘读取，前端无法控制，service worker给予了我们另外一种更加灵活，可以直接的操作方式，需要手动执行`cache.delete(resource)`进行清除\n\n\n## nginx缓存实战\n\n\n我们先随便搞个vue项目部署到nginx中，不知道怎么部署，看这篇文章 {% post_link nginx/mac配置nginx以及常用命令 mac配置nginx以及常用命令 %}\n\n我的nginx配置如下：\n\n``` bash\nserver {\n    listen 8089;\n    location /test1 {\n        alias  html/test;\n        index  index.html index.htm;\n    }\n}\n\n```\n启动nginx，并访问 `http://localhost:8089/test1`， 此时我们并没有设置缓存，效果如下\n\n<img src=\"images/nginx.gif\" width=\"50%\" height=\"50%\"/>\n\nhtml如下图\n<img src=\"images/nginx-default-html.jpg\" width=\"50%\" height=\"50%\"/>\n\ncss如下图\n<img src=\"images/nginx-default-css.jpg\" width=\"50%\" height=\"50%\"/>\n\n- 我们可以看到，第一次访问，两条请求的状态码都是 200。html和静态资源的响应头都会有 `ETag和Last-Modified`，这不就是协商缓存的字段嘛， 所以nginx默认开启了缓存。\n- 我们刷新页面，发现html的状态码是304，其他静态资源是200，来源于缓存，也就是说每一次html文件都是命中了协商缓存，而js文件都是命中了强缓存。\n  \n细心发现，我可以看到，刷新页面后，\n- html的请求头里面由原来的`Cache-Control: no-cache`变成 `Cache-Control: max-age=0`并且带上了 `If-Modified-Since: Tue, 17 Jan 2023 07:17:36 GMT `和 `If-None-Match: \"63c64b90-31d\"`, 可以看到此时浏览器携带上了协商缓存的相关参数，以此来避免命中强缓存。\n\n<img src=\"images/nginx-f5-html.jpg\" width=\"50%\" height=\"50%\"/>\n\n- 静态资源的请求头如下图（走的缓存看不到具体header信息，浏览器隐藏了，可以抓包看）\n\n<img src=\"images/nginx-f5-css.jpg\" width=\"50%\" height=\"50%\"/>\n\n\n现在我们修改配置\n\n### no-cache\n\n``` bash\nserver {\n    listen 8089;\n    location /test1 {\n        alias  html/test;\n        index  index.html index.htm;\n        add_header Cache-Control no-cache;\n    }\n}\n\n```\n结果如下：\n- html以及静态资源响应头都增加了`Cache-Control: no-cache`，之前没配置nginx，都没有。\n- 静态资源都是协商缓存304,请求时候请求头都带上了`If-Modified-Since和If-None-Match`\n- html和没配置一样，请求时候请求头仍是`Cache-Control: max-age=0`并且带上了 `If-Modified-Since和If-None-Match`\n\n<img src=\"images/nginx-no-cache-all.jpg\" width=\"50%\" height=\"50%\"/>\n<img src=\"images/nginx-no-cache-html.jpg\" width=\"50%\" height=\"50%\"/>\n<img src=\"images/nginx-no-cache-css.jpg\" width=\"50%\" height=\"50%\"/>\n\n### no-store\n\n``` bash\nserver {\n    listen 8089;\n    location /test1 {\n        alias  html/test;\n        index  index.html index.htm;\n        add_header Cache-Control no-store;\n    }\n}\n\n```\n结果如下：\n\n- html以及静态资源响应头都增加了`Cache-Control: no-store`\n- html和静态资源不走缓存，永远取最新的\n- 静态资源请求头没有了`If-Modified-Since和If-None-Match和Cache-Control`\n- html请求头没有`If-Modified-Since和If-None-Match`，但有`Cache-Control: max-age=0`\n\n\n<img src=\"images/nginx-no-store-all.jpg\" width=\"50%\" height=\"50%\"/>\n<img src=\"images/nginx-no-store-html.jpg\" width=\"50%\" height=\"50%\"/>\n<img src=\"images/nginx-no-store-css.jpg\" width=\"50%\" height=\"50%\"/>\n\n\n### max-age=5\n\n``` bash\nserver {\n    listen 8089;\n    location /test1 {\n        alias  html/test;\n        index  index.html index.htm;\n        add_header Cache-Control max-age=5;\n    }\n}\n\n```\n\n我们配置缓存5s,结果如下\n- html以及静态资源响应头都增加了`Cache-Control: max-age=5`\n- html永远是304(请求时永远都携带`Cache-Control: max-age=0`以及 `If-Modified-Since和If-None-Match`)，\n- 静态资源在5s内一直走强缓存，当失效时， 再次刷新页面， 静态资源带上`If-Modified-Since和If-None-Match`发起协商缓存304请求，再次刷新页面，静态资源重新变成强缓存\n\n<img src=\"images/nginx-max-age-all.gif\"/>\n\n综合上面三种测试，我们发现\n- 上面三种无论怎么设置，nginx永远对html进行协商缓存，静态资源根据不同配置，不同结果\n\n## 缓存场景\n\n- 我们现在都是工程化打包，拿vue举例子，打包后的静态资源都有hash值，所以说走强缓存即可\n- html走协商缓存或者不缓存，html因为引用静态资源，又没有hash值，所以更新，都要新的\n- 对于不常变化的静态资源，我们可以单独设置一个很长的max-age，比如`max-age=31536000 (一年)`,这样1年内走强缓存，连协商缓存的请求都省去了。但是为了解决更新问题，需要在url上加版本号/hash等来控制\n\n\n实际中我们可以用类似下面配置进行不同类型判断\n \n``` bash\nserver {\n    listen 8089;\n    location /test1 {\n        alias  html/test;\n        index  index.html index.htm;\n        if ($request_filename ~* ^.*[.](html|htm)$) {\n            #html文件不缓存\n            add_header Cache-Control \"no-store\";\n        }\n    }\n}\n\n```\n\n## 浏览器缓存\n\n最后， 前端中还有个浏览器缓存，简单描述下\n\n- cookie\n- LocalStorage/SessionStorage\n- indexedDB\n\n1. cookie大小为4KB，每个域名下的cookie数量最多为20个（但很多浏览器厂商在具体实现时支持大于20个）\n2. cookie的key和value如果里面含有`;`号，设置都时候就会被截断，因为我们通过`document.cookie`设置本来就是字符串拼接并分号隔开的，所以需要编码下， 实际上中文等特殊字符我们都最好编码下\n3. localStorage/sessionStorage大小为5M，我们通过`localStorage.setItem(key,value)`设置的，所以不会存在截断问题，但是特殊字符啥的最好编码下\n4. IndexedDB为解决前端无法存储大容量数据而生，它的存储容量非常大，取决与你的硬盘。相当于前端的数据库。主流浏览器都支持，看兼容性，可以上[caniuse查询下](https://caniuse.com/?search=indexedDB)\n\n<img src=\"images/indexedDB.jpg\"/>\n\n\n","categories":["http"]},{"title":"傻傻分不清楚-toString()、Object.prototype.toString.call()","url":"/ypf-blog/2023/12/25/javascript/傻傻分不清楚-toString()、Object-prototype-toString-call()/","content":"\n# toString() \n它的作用是:将某一个值转化为字符串\n我们先看个demo：\n\n    var t1 = {a: 1};\n    var t2 = [1,2];\n    var t3 = 'str';\n    var t4= 4\n    var t5=true\n    console.log(t1.toString())  //\"[object Object]\"\n    console.log(t2.toString())  //\"1,2\"\n    console.log(t3.toString())  // \"str\"\n    console.log(t4.toString())  // \"4\"\n    console.log(t5.toString())  // \"true\"\n在上面的例子中，我们定义了对象、数组、字符串、数值、布尔类型来调用`toString`方法，但是结果却完全不一样。奇怪？\n\n**从例子上看，**\n\n- 对象返回的是貌似可以反映出其类型的字符串\n- 数组返回的是字符串列表\n- 字符串返回的是字符串副本（即原样输出）\n\n所以从结果看，貌似不同类型的`toString`的方法功能不一样（虽然名字都叫toString）。\n\n\n\n了解过[对象原型](../数据类型)以及{% post_link javascript/数据类型 基本包装类型 %}的朋友都知道，上面例子中:\n\n- t1调用的是Object.prototype里的方法\n- t2调用的是Array.prototype里的方法\n- t3调用的是String.prototype里的方法\n\n虽然t2也是对象，但其原型链上的第一层`Array.prototype就有toString方法`，所以就会直接继承，而不会再去找`Array.prototype.__proto__即Object.prototype中的toString方法`，所以不同类型的原型链式或多或少都 **重写了toString方法**，所以功能用处都不一样。\n\n接下来，我们再来分析一下不同类型调用toString()方法，返回值有什么不同之处？\n\n## 字符串string（即调用 new String出来的基本包装类型的方法）\n\n>返回字符串的一个副本（即原样输出）\n\n    var str = \"a\";\n    str.toString(); //\"a\"\n    String.prototype.toString.call(str) // \"a\"\n\n## 数值number（即调用 new Number出来的基本包装类型的方法）\n\n> 返回字符串形式的数值\n\n    var num = 520;\n    num.toString(); //\"520\"\n    Number.prototype.toString.call(num) // \"a\"\n\n\n## 布尔值boolean（即调用 new Boolean出来的基本包装类型的方法）\n\n> 返回字符串\"true\"或\"false\"\n\n    var boo = true;\n    boo.toString(); //\"true\"\n    Boolean.prototype.toString.call(boo); //\"true\"\n\n## 独一无二值symbol(即调用构造函数Symbol生成的实例方法，注这里调用和一般的构造函数不一样，不需要new，直接调用)\n\n>返回字符串\"Symbol()\"\n\n    var symbol = Symbol();\n    symbol.toString(); //\"Symbol()\"\n    Symbol.prototype.toString.call(symbol); //\"Symbol()\"\n\n## null和undefined\n\nnull和undefined没有相应的构造函数，所以它们没有也无法调用toString()方法，也就是说它们不能访问任何属性和方法，只是基本类型而已。\n\n## 对象object（即调用Object.prototype的方法）\n\n>返回 `[object type]`，其中type为对象的类型\n\n    var t1 = {a: 1};\n    t1.toString()  //\"[object Object]\"\n    Object.prototype.toString.call(t1); //\"[object Object]\"\n\n## 数组Array（即调用Array.prototype的方法）\n\n>返回由数组中每个值的字符串形式 拼接而成的一个以逗号分隔的字符串\n\n    var array = [1, 's', true, {a: 2}];\n    array.toString();//\"1,s,true,[object Object]\"\n    Array.prototype.toString.call(array);//\"1,s,true,[object Object]\"\n\n## 函数function（即调用Function.prototype的方法）\n\n>返回函数的代码\n\n    function foo(){\n        console.log(1');\n    };\n    foo.toString();\n    <!--\"function foo(){-->\n    <!--    console.log(1);-->\n    <!--}\"-->\n    Function.prototype.toString.call(foo);\n    <!--\"function foo(){-->\n    <!--    console.log(1');-->\n    <!--}\"-->\n\n所以：\n\n    Object.toString();\n    //\"function Object() { [native code] }\"\n    Function.toString();\n    //\"function Function() { [native code] }\"\n    Array.toString();\n    //\"function Array() { [native code] }\"\n    ....\n\n因为\n\n    Array.__proto__===Function.prototype  //true\n    Object.__proto__===Function.prototype  //true\n    Function.__proto__===Function.prototype  //true\n\n## 日期Date（即调用Date.prototype的方法）\n\n>返回带有时区信息的日期和时间\n\n    var date = new Date();\n    date.toString();\n    //\"Fri May 11 2018 14:55:43 GMT+0800 (中国标准时间)\"\n    Date.prototype.toString.call(date);\n    //\"Fri May 11 2018 14:55:43 GMT+0800 (中国标准时间)\"\n\n## 正则表达式RegExp（即调用RegExp.prototype的方法）\n\n>返回正则表达式的字符串形式\n\n    var re = /cat/g;\n    re.toString();// \"/cat/g\"\n    RegExp.prototype.toString.call(re);// \"/cat/g\"\n\n## 全局对象window\n\n>返回 `[object window]`\n\n    window.toString(); //\"[object Window]\"\n    Object.prototype.toString.call(window); //\"[object Window]\"\n\nwindow是js中的特殊对象，Window并不是个构造函数，也就是说并没有Window.prototype原型对象上重写toString()方法，它会顺着原型链查找调用Object.prototype.toString()。\n\n# Object.prototype.toString.call( )\n\n上面我们通过直接调用和call调用两种方式进行`toString`方法测试。我们知道对应object返回的结果是`[object type]`，其中type为对象的类型`，那么我们可以根据其返回对象的功能进行类型判断。\n\n    Object.prototype.toString.call({});\n    <!--\"[object Object]\"-->\n    Object.prototype.toString.call([]);\n    <!--\"[object Array]\"-->\n    Object.prototype.toString.call(function(){});\n    <!--\"[object Function]\"-->\n    Object.prototype.toString.call('');\n    <!--\"[object String]\"-->\n    Object.prototype.toString.call(1);\n    <!--\"[object Number]\"-->\n    Object.prototype.toString.call(true);\n    <!--\"[object Boolean]\"-->\n    Object.prototype.toString.call(null);\n    <!--\"[object Null]\"-->\n    Object.prototype.toString.call(undefined);\n    <!--\"[object Undefined]\"-->\n    Object.prototype.toString.call();\n    <!--\"[object Undefined]\"-->\n    Object.prototype.toString.call(new Date());\n    <!--\"[object Date]\"-->\n    Object.prototype.toString.call(/at/);\n    <!--\"[object RegExp]\"-->\n\n# 直接调用\n\n    toString();\n    <!--\"[object Undefined]\"-->\n\n    (function(){\n        console.log(toString());\n    })();\n    <!--[object Undefined]-->\n\n也就是说直接调用toString()方法，等价于\n\n    Object.prototype.toString.call();\n    <!--\"[object Undefined]\"-->\n    Object.prototype.toString.call(undefined);\n    <!--\"[object Undefined]\"-->\n\n即：**直接调用toString()方法这里不可以理解成为全局作用域调用toString()方法，即window.toString()**\n\n所以直接调用toString()应该就是**变相的**undefined.toString()方法（这里说的是相当于，实际undefined并没有方法，调用会报错）。\n\n# toString.call/apply(类型)\n\n经常有人用toString.call/apply(类型)去代替Object.prototype.toString.call/apply(类型)使用，其实这样是不严谨的，容易导致一些问题，如下所示\n\n    function toString(){\n        console.log(1\")\n    }\n    toString();//1\n    toString.call({});//1\n    toString.call([]);//1\n\n我们可以发现，当我们自定义了toString()方法时，直接调用toString()方法，就不会再默认调用Object类的toString()方法，而是会使用我们自定义的方法，这样可能得不到我们想要的结果，所以我们还是应当尽量使用Object.prototype.toString.call/apply(类型)。\n\n# 类型\n\n类似toString()方法，Object的不同子类型还重写了`toLocaleString()、valueOf()等方法`，这里我想说的是不管对象子类型怎么**重写**方法，只要我们明白这些方法是**哪里来**的，怎么调用的，就能很好的理解这些方法调用后产生的结果！\n\n说到底，对JS中对象和原型的理解真的非常非常重要！\n\n\n\n> [由Object.prototype.toString.call( )引发关于toString( )方法的思考]()\n\n","categories":["javascript","傻傻分不清楚","待完善"]},{"title":"11.watcher和dep思路梳理","url":"/ypf-blog/2023/11/10/vue2源码/11.watcher和dep思路梳理/","content":"## watcher有几种\n\n经过前面的学习,答案显而易见,<font color=\"red\">**有3种**</font>\n\n## watcher定义对比\n\n### 渲染watcher\n\n#### 初始化\n所谓渲染watcher,就是用来执行 `updateComponent`,其中第四个参数传true表示是渲染watcher\n```js\n  const updateComponent = () => {   \n    vm._update(vm._render())\n  }\n  new Watcher(vm,updateComponent,()=>{\n    callHook(vm, \"updated\");\n  },true) // 参数1：实例，参数2：更新函数，参数3：渲染函数，参数4：true表示是渲染watcher\n```\n#### 收集依赖\n<img src=\"images/render-init.jpg\" width=\"70%\"/>\n\n如上图,通过Object.defineProperty触发了**收集依赖**\n\n#### 触发依赖\n<img src=\"images/render-set1.jpg\"  width=\"70%\"/>\n<img src=\"images/render-set2.jpg\"  width=\"70%\"/>\n<img src=\"images/render-set3.jpg\"  width=\"70%\"/>\n<img src=\"images/render-set4.jpg\"  width=\"70%\"/>\n<img src=\"images/render-set5.jpg\"  width=\"70%\"/>\n\n所谓触发依赖,实际本质原理就是`因为每个属性都会有个dep, 本质就是循环dep下面的watcher`\n### watch的watcher(用户watcher)\n\n#### 初始化\n所谓用户watcher,就是咱们平常用的watch函数,其中第四个参数传`user:true`即表示是用户watcher\n```js\n  Vue.prototype.$watch = function (exprOrFn, handler, options = {}) {\n    // 渲染走渲染的watcher，watch走watch的watcher\n    const watcher = new Watcher(this, exprOrFn, handler, {\n      ...options,\n      user: true, // 标识是用户watcher\n    });\n    // 如果用户传入了immediate，应该立即执行\n    if (options.immediate) {\n      handler.call(this, watcher.value);\n    }\n  };\n```\n#### 收集依赖\n上面exprOrFn就是data中定义的变量, 此时会触发watcher源码中初始化的getter函数.\n\n<img src=\"images/watch-init.jpg\" width=\"70%\"/>\n\n如上面截图,当执行了getter函数,就相当于vm实例上获取值,此时的Dep.target=用户watcher, 然后就会和上面渲染函数收集方式一处代码(Object.defineProperty),触发了**收集依赖**,该属性的dep下subs数组(watcher数组)就会append一个用户watcher\n\n#### 触发依赖\n和上面渲染watcher一样,data数据变化就会触发依赖,循环该属性下的subs数组(watcher数组),从而会触发watch回调函数,如下图\n<img src=\"images/watch-set5.jpg\" width=\"70%\"/>\n\n### computed的watcher\n\n#### 初始化\n所谓computed的watcher,就是computed的get函数,其中第四个参数`{lazy:true}`即表示是computed的watcher\n\n```js\nfunction initComputed(vm) {\n  let computed = vm.$options.computed;\n  // 将计算属性的配置放到vm实例上\n  const watchers = (vm._computedWatchers = {});\n  for (let key in computed) {\n    const userDef = computed[key];\n    const getter = typeof userDef === \"function\" ? userDef : userDef.get;\n    // 创建一个watcher实例，这个watcher实例中的lazy为true\n    // 每一个属性都有一个watcher,lazy为true表示不会立即执行,只有用到这个属性的时候才会执行\n    watchers[key] = new Watcher(vm, getter, () => {}, { lazy: true });\n    // 将key代理到vm实例上\n    defineComputed(vm, key, userDef);\n  }\n}\n```\n\n#### 收集依赖\n因为初始化state的劫持只劫持了data中的变量,所以computed需要重新定义Object.defineProperty将computed定义的变量绑定到vm上进行劫持的(注意), get函数就是computed的回调函数.\n<img src=\"images/computed-set1.jpg\" width=\"70%\"/>\n\n#### 触发依赖\n\n我们知道computed的变量在\n- 只有使用的时候才会触发\n- 只有依赖的变量变化才会触发,不依赖的变量变化不会触发\n\n```html\n  <body>\n    <div id=\"app\"></div>\n  </body>\n  <script>\n    const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n          b:1,\n          d:1\n        };\n      },\n      computed: {\n        c() {\n          console.warn('调用');\n          return this.a + this.b;\n        },\n      },\n    })\n\n```\n因为**lazy**的存在,所以只有使用才会触发,**初始化不会触发**\n<img src=\"images/3.jpg\" width=\"70%\"/>\n如果直接使用,如`vm.c`,此时会触发computed自己定义的拦截\n<img src=\"images/4.jpg\" width=\"70%\"/>\n<img src=\"images/5.jpg\" width=\"70%\"/>\n<img src=\"images/6.jpg\" width=\"70%\"/>\n所以上图也解释了为啥只有computed触发只和依赖的变量变化有关,因为里面该方法里面使用了变量导致拦截,其dep的subs会增加一个computed的watcher.\n\n","categories":["vue2源码"]},{"title":"10.computed","url":"/ypf-blog/2023/11/02/vue2源码/10.computed/","content":"## computed用法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.min.js\"></script>\n    <!-- <script src=\"./dist/vue.js\"></script> -->\n  </head>\n  <body>\n    <div id=\"app\">\n    </div>\n  </body>\n  <script>\n    const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n          b: 2,\n        };\n      },\n      computed: {\n        c() {\n          console.log('调用');\n          return this.a + this.b;\n        },\n        // c:{\n        //   get(){\n        //     return this.a + this.b;\n        //   },\n        //   set(val){\n        //     this.a = val;\n        //   }\n        // }\n      },\n    });\n    vm.c\n    vm.c\n  </script>\n</html>\n```\n\n我们知道computed有如下特点\n1. 函数形式或者对象形式(get、set)\n2. 多次调用,只会触发一次,具有缓存机制\n3. 只有computed下定义的属性,其依赖的属性变化,才会触发;或者调用computed下定义的属性,才会触发\n\n我们从上面代码可以看到, 调用了两次`vm.c`,但computed里面只输出了一次 **调用**.\n接下来我们来实现computed.\n  \n## 原理\n\n### 初步实现(无缓存)\n```js\nsrc/state.js\nexport function initState(vm) {\n  const opts = vm.$options;\n  ...\n  // 1. 初始化computed\n  if (opts.computed) {\n    console.groupInfo(\"初始化-computed\");\n    initComputed(vm);\n    console.groupInfoEnd();\n  }\n  ...\n}\n// 2. 新增initComputed方法\nfunction initComputed(vm) {\n  let computed = vm.$options.computed;\n  for (let key in computed) {\n    const userDef = computed[key];\n    const getter = typeof userDef === \"function\" ? userDef : userDef.get;\n    // 将key代理到vm实例上\n    defineComputed(vm, key, userDef);\n  }\n}\nfunction defineComputed(target, key, userDef) {\n  const sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: () => {},\n    set: () => {},\n  };\n  if (typeof userDef === \"function\") {\n    sharedPropertyDefinition.get = userDef;\n  } else {\n    sharedPropertyDefinition.get = userDef.get;\n    sharedPropertyDefinition.set = userDef.set;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n```\n\n此时我们执行代码, 是已经实现了computed, 只不过输出了`两次调用`,说明还没有缓存,现在我们来实现缓存.\n\n### computed有缓存\n\n```js\nfunction defineComputed(target, key, userDef) {\n  const sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: () => {},\n    set: () => {},\n  };\n  if (typeof userDef === \"function\") {\n    // 3.修改为createComputedGetter方法\n    sharedPropertyDefinition.get = createComputedGetter(key);\n  } else {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = userDef.set;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n// 创建计算属性的getter,高阶函数(什么是高阶函数?即函数的返回值是函数或者函数的参数是函数)\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    // 取出watcher\n    const watcher = this._computedWatchers[key];\n    if (watcher) {\n      // 4.缓存核心点 如果watcher.dirty为true，说明依赖的数据发生了变化，需要重新计算,不变化就不计算,初始化的时候为true,因为其值就是lazy\n      if (watcher.dirty) {\n        // 在watcher中重新定义evaluate方法，用来计算\n        watcher.evaluate();\n      }\n      // 如果Dep.target存在,将计算属性watcher添加到渲染watcher的依赖中\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    }\n  };\n}\n```\n- 上面初始化的`watcher.dirty=lazy=true` ,执行完以后`置为false`, 后面多次执行就不会触发了.\n- 只有依赖的data属性变化,才会触发该属性下的subs里的watcher执行.这也是为啥Computed依赖的数据必须在data里面定义,否则依赖改变了,也监听不到,watch也监听不到\n\n具体总结可以看下一节,对比三种watcher.","categories":["vue2源码"]},{"title":"9.diff算法(patch)","url":"/ypf-blog/2023/09/28/vue2源码/9.diff算法(patch)/","content":"## 为何操作dom性能差？\n我们知道vue每次数据变化，在更新dom前都会进行diff对比，再进行操作dom，这极大的提高的页面性能效率，为什么操作dom就浪费性能，操作数据就不浪费？我们来看个案例：\n\n### 案例一\n``` js\n    console.time()\n    for(var i=0;i<1000000;i++){\n        var obj={}\n    }\n    console.timeEnd()\n\n    console.time()\n    for(var i=0;i<1000000;i++){\n        var el=document.createElement('div')\n    }\n    console.timeEnd()\n```\n结果如下：\n\n上面结果大概相差了16倍。\n<img src=\"images/demo1.jpg\" width=\"50%\"/>\n\n### 案例二\n\n```js\n    console.time()\n    for(var i=0;i<1000;i++){\n        document.body.innerHTML=i\n    }\n    console.timeEnd()\n\n    console.time()\n    let num=0\n    for(var i=0;i<1000;i++){\n        num=i\n    }\n    document.body.innerHTML=num\n    console.timeEnd()\n```\n结果如下：\n\n上面结果大概相差了**80倍**，如果涉及到更复杂的dom操作，相差更多。\n<img src=\"images/demo2.jpg\" width=\"50%\"/>\n\n## patch比对\n\n我们先看个案例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.min.js\"></script>\n    <!-- <script src=\"./dist/vue.js\"></script> -->\n  </head>\n  <body>\n    <div id=\"app\">\n      <div\n        :style=\"{color:'red','font-size':a===3?'17px':'12px'}\"\n        id=\"test\"\n      >0</div>\n      <div>{{a}}</div>\n      <div>2</div>\n    </div>\n  </body>\n  <script>\n    const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n        };\n      },\n    });\n    setTimeout(() => {\n      vm.a = 3;\n    }, 1000);\n  </script>\n</html>\n\n```\n\n<img src=\"images/vue.gif\" width=\"50%\"/>\n\n我们更改了样式属性以及data，运行发现，\n**属性只有style变更，dom只有指定节点变更，其他dom都不变。这就是vue diff的强大之处。**\n\n因为我们自己的vue还没有实现模版变量判断等语法，所以我们直接通过下面图例进行`vue diff`讲解。\n\n\n### 回忆\n\n我们回忆下之前讲解的，每次数据改变时候，都会触发watcher`（vm._update(vm._render())）`，我们知道\n- `vm._render()`用来生成虚拟dom\n- `vm._update()`用来渲染真实dom的\n\n```js\n\nsrc/index.js\n  function Vue(options) {\n    this._init(options);\n  }\nsrc/init.js\n  export function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      const vm = this;\n      // vm.$options = options;\n      // 将用户传入的options和全局的options做合并\n      vm.$options = mergeOptions(vm.constructor.options, options);\n      // 说明：初始化生命周期\n      console.log(\"%c生命周期：beforeCreate\", \"color: red\");\n      callHook(vm, \"beforeCreate\");\n      // 初始化状态\n      console.groupInfo(\"初始化state，包括data、computed、methods、watch等\")\n      initState(vm);\n      console.groupInfoEnd()\n      // 说明：初始化生命周期\n      console.log(\"%c生命周期：created\", \"color: red\");\n      callHook(vm, \"created\");\n      // 挂载模版\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n    Vue.prototype.$mount = function (el) {\n      const vm = this;\n      const options = vm.$options;\n      el = document.querySelector(el);\n      vm.$el = el; // 存储当前组件的根元素，用于后续的vdom转换真实dom操作\n      // 默认先会查找有没有render方法，没有render会采用template，template也没有就用el中的内容\n      if (!options.render) {\n        // 对模版进行编译\n        let template = options.template;\n        if (!template && el) {\n          template = el.outerHTML;\n        }\n        const render = compileToFunction(template);\n        options.render = render;\n      }\n      // 挂载组件（主要用到_update和_render方法）\n      mountComponent(vm, el);\n    };\n  }\nsrc/lifecycle.js\n  export function mountComponent(vm, el) {\n    console.log(\"%c生命周期：beforeMount\", \"color: red\");\n    callHook(vm, \"beforeMount\");\n    // render-->vnode-->真实dom\n    // 1.调用vm._render函数，生成虚拟dom  2.调用vm._update,将虚拟dom转换成真实dom\n    // vm._update(vm._render());\n    const updateComponent = () => {   \n      console.log(\"updateComponent\",vm._render())         \n      vm._update(vm._render())\n    }\n    new Watcher(vm,updateComponent,()=>{\n      console.log(\"%c生命周期：updated\", \"color: red\");\n      callHook(vm, \"updated\");\n    },true) // 参数1：实例，参数2：更新函数，参数3：渲染函数，参数4：true表示是渲染watcher\n    console.log(\"%c生命周期：mounted\", \"color: red\");\n    callHook(vm, \"mounted\");\n  }\n  export function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode) {\n      console.log(vnode, \"vnode\");\n      const vm = this;\n      vm.$el = patch(vm.$el, vnode);\n    };\n  })\nsrc/vdom/patch.js\n  export function patch(oldVnode, vnode) {\n    // 渲染\n    const oldElm = oldVnode; // div id=\"app\"\n    const parentElm = oldElm.parentNode; // body\n    let el = createElm(vnode); // 创建真实dom\n    parentElm.insertBefore(el, oldElm.nextSibling); // 将创建的真实dom插入到老的dom的后面\n    parentElm.removeChild(oldElm); // 删除老的dom\n    return el;  \n  }\n```\n上面我简单抽取了几个文件，直接描述了渲染vdom的流程。\n- 第一次加载的时候通过$mount,生成了存储当前组件根元素真实的dom节点，`vm.$el = el`，然后执行`mountComponent`将组件挂载到el下。\n- 挂载过程主要初始化了watcher`（vm._update(vm._render())）`\n- `vm._update(）`执行了patch方法，里面就是通过`createElm(vnode)`创建真实dom，同时更新`vm.$el = patch(vm.$el, vnode);`\n- 后面数据变化会执行watcher队列，重新触发`vm._update(vm._render())`\n\n### 第一次渲染\n\n- Vue第一次的渲染，**比单纯创建dom元素要效率低**，因为通过执行了一大堆生成vdom逻辑，才生成了真实的dom(即上面的patch函数中createElm)。\n- vue的高效体现在响应式数据变化的虚拟dom对比组件依赖的数据收到响应式数据的影响时，重新调用render函数创建虚拟dom树，用新旧虚拟dom树比较，vue会找到最小更新量，然后更新必要的虚拟dom节点，最后修改对应的真实dom。这样就保证了对真实dom达到最小的变动。所以要改造patch函数，因为现在每次更新都相当于第一次创建。\n\n### 更新进行patch对比\n\n```js\n修改src/lifecycle.js\nexport function lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode) {\n    console.log(vnode, \"vnode\");\n    const vm = this;\n    // 1.增加判断\n    const prevVnode = vm._vnode; // 保存上一次的vnode\n    vm._vnode = vnode; // 保存当前的vnode\n    if (!prevVnode) {\n      // 说明是初次渲染\n      vm.$el = patch(vm.$el, vnode); \n    }\n    else {\n      // 说明是更新\n      vm.$el = patch(prevVnode, vnode);\n    }\n  };\n}\n\n```\n```js\n修改src/vdom/patch.js\nexport function patch(oldVnode, vnode) {\n  console.log(oldVnode, vnode, \"patch\")\n  // 判断是更新还是第一次渲染，第一次传的是真实的dom节点$el,后面更新传递的是虚拟dom\n  const isRealElement = oldVnode.nodeType;\n  if (isRealElement) {\n    // 渲染\n    const oldElm = oldVnode; // div id=\"app\"\n    const parentElm = oldElm.parentNode; // body\n    let el = createElm(vnode); // 创建真实dom\n    parentElm.insertBefore(el, oldElm.nextSibling); // 将创建的真实dom插入到老的dom的后面\n    parentElm.removeChild(oldElm); // 删除老的dom\n    return el;  \n  } else {\n    // 更新\n    patchVnode(oldVnode, vnode);\n  }\n}\nfunction patchVnode(oldVnode, vnode) {\n  // 1.比较标签是否一致\n  if (oldVnode.tag !== vnode.tag) {\n    return oldVnode.el.parentNode.replaceChild(createElm(vnode), oldVnode.el);\n  }\n  // 2.比较文本，此时tag===undefined\n  if (!oldVnode.tag) {\n    // 文本\n    if (oldVnode.text !== vnode.text) {\n      return (oldVnode.el.textContent = vnode.text);\n    }\n  }\n  // 3.标签一致且不是文本，比较属性\n  let el = (vnode.el = oldVnode.el); // 标签一样，直接复制老的节点\n  updateProperties(vnode, oldVnode.data); // 更新属性\n  // 4.比较子节点\n  let oldChildren = oldVnode.children || [];\n  let newChildren = vnode.children || [];\n\n  if (oldChildren.length > 0 && newChildren.length > 0) {\n    // 老的有子节点，新的也有子节点\n    updateChildren(el, oldChildren, newChildren);\n  } else if (oldChildren.length > 0) {\n    // 老的有子节点，新的没有\n    el.innerHTML = \"\";\n  } else if (newChildren.length > 0) {\n    // 新的有子节点，老的没有\n    for (let i = 0; i < newChildren.length; i++) {\n      let child = newChildren[i];\n      el.appendChild(createElm(child));\n    }\n  }\n}\n// 比较两个虚拟节点是否一致\nfunction isSameVnode(oldVnode, newVnode) {\n  return (oldVnode.tag === newVnode.tag &&\n    oldVnode.key === newVnode.key &&\n    oldVnode.type === newVnode.type)\n}\n// 比较子节点，更新子节点，需要用到双指针\nfunction updateChildren(parent, oldChildren, newChildren) {\n  // 1.创建双指针\n  let oldStartIndex = 0; // 老的开始索引\n  let oldStartVnode = oldChildren[0]; // 老的开始节点\n  let oldEndIndex = oldChildren.length - 1; // 老的结束索引\n  let oldEndVnode = oldChildren[oldEndIndex]; // 老的结束节点\n\n  let newStartIndex = 0; // 新的开始索引\n  let newStartVnode = newChildren[0]; // 新的开始节点\n  let newEndIndex = newChildren.length - 1; // 新的结束索引\n  let newEndVnode = newChildren[newEndIndex]; // 新的结束节点\n\n  // 2.创建Ovnode映射表\n  function makeIndexByKey(children) {\n    let map = {};\n    children.forEach((child, index) => {\n      map[child.key] = index;\n    });\n    return map;\n  }\n  let map = makeIndexByKey(oldChildren);\n\n  // 3.循环比较\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    // 1.新的开始节点和老的开始节点比较\n    if (!oldStartVnode) {\n      // 老的开始节点不存在，说明已经被移动走了\n      oldStartVnode = oldChildren[++oldStartIndex];\n    } else if (!oldEndVnode) {\n      // 老的结束节点不存在，说明已经被移动走了\n      oldEndVnode = oldChildren[--oldEndIndex];\n    } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n      // 新的开始节点和老的开始节点一样，直接比较属性和子节点\n      patchVnode(oldStartVnode, newStartVnode);\n      // 移动指针\n      oldStartVnode = oldChildren[++oldStartIndex];\n      newStartVnode = newChildren[++newStartIndex];\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      // 新的结束节点和老的结束节点一样，直接比较属性和子节点\n      patchVnode(oldEndVnode, newEndVnode);\n      oldEndVnode = oldChildren[--oldEndIndex];\n      newEndVnode = newChildren[--newEndIndex];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n      // 新的结束节点和老的开始节点一样，直接比较属性和子节点\n      patchVnode(oldStartVnode, newEndVnode);\n      // 将老的开始节点移动到老的结束节点的后面\n      parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling);\n      oldStartVnode = oldChildren[++oldStartIndex];\n      newEndVnode = newChildren[--newEndIndex];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n      // 新的开始节点和老的结束节点一样，直接比较属性和子节点\n      patchVnode(oldEndVnode, newStartVnode);\n      // 将老的结束节点移动到老的开始节点的前面\n      parent.insertBefore(oldEndVnode.el, oldStartVnode.el);\n      oldEndVnode = oldChildren[--oldEndIndex];\n      newStartVnode = newChildren[++newStartIndex];\n    } else {\n      // 以上四种情况都不满足，需要遍历查找\n      // 1.拿到老节点的key和索引的映射表\n      let moveIndex = map[newStartVnode.key];\n      if (moveIndex === undefined) {\n        // 说明新的开始节点在老的节点中不存在，直接插入到老的开始节点的前面\n        parent.insertBefore(createElm(newStartVnode), oldStartVnode.el);\n      } else {\n        // 说明新的开始节点在老的节点中存在，直接移动到老的开始节点的前面\n        let moveVnode = oldChildren[moveIndex];\n        oldChildren[moveIndex] = undefined; // 将移动的节点置为undefined\n        parent.insertBefore(moveVnode.el, oldStartVnode.el);\n        patchVnode(moveVnode, newStartVnode); // 比较属性和子节点\n      }\n      newStartVnode = newChildren[++newStartIndex];\n    }\n  }\n  // 4.循环结束后，老的还有剩余，新的没有，说明需要删除老的节点\n  if (oldStartIndex <= oldEndIndex) {\n    for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n      let child = oldChildren[i];\n      if (child) {\n        parent.removeChild(child.el);\n      }\n    }\n  }\n  // 5.循环结束后，新的还有剩余，老的没有，说明需要新增新的节点\n  if (newStartIndex <= newEndIndex) {\n    for (let i = newStartIndex; i <= newEndIndex; i++) {\n      // parent.appendChild(createElm(newChildren[i]));\n      // 将新的节点插入到老的结束节点的后面\n      let ele =\n        newChildren[newEndIndex + 1] == null\n          ? null\n          : newChildren[newEndIndex + 1].el;\n      parent.insertBefore(createElm(newChildren[i]), ele);\n    }\n  }\n}\n// 更新属性\nfunction updateProperties(vnode, oldProps = {}) {\n  let newProps = vnode.data || {};\n  let el = vnode.el;\n  // 1.遍历老的属性\n  for (let key in oldProps) {\n    // 如果老的不存在新的属性，删除\n    if (!newProps[key]) {\n      el.removeAttribute(key);\n    }\n  }\n\n  // 2.样式处理\n  let newStyle = newProps.style || {};\n  let oldStyle = oldProps.style || {};\n  for (let key in oldStyle) {\n    // 如果老的不存在新的样式，删除\n    if (!newStyle[key]) {\n      // js中删除样式，直接设置为空或者null即可,注意undefined不管用\n      el.style[key] = \"\";\n    }\n  }\n\n  // 3.遍历新的属性\n  for (let key in newProps) {\n    if (key === \"style\") {\n      for (let styleName in newProps[key]) {\n        el.style[styleName] = newProps[key][styleName];\n      }\n    } else if (key === \"class\") {\n      el.className = newProps[key];\n    } else {\n      el.setAttribute(key, newProps[key]);\n    }\n  }\n}\n\nexport function createElm(vnode) {\n  let { tag, children, key, data, text } = vnode;\n  if (typeof tag === \"string\") {\n    // 元素\n    vnode.el = document.createElement(tag); // 创建元素\n    updateProperties(vnode); // 更新属性\n    children.forEach((child) => {\n      vnode.el.appendChild(createElm(child)); // 递归渲染子节点\n    });\n  } else {\n    // 文本\n    vnode.el = document.createTextNode(text);\n  }\n  return vnode.el;\n}\n```\n\n上面那么长的代码，我们来分步剖析。\n<img src=\"images/diff.jpg\" width=\"50%\"/>\n\nvue仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新。因为在前端中，很少会跨越层级移动dom。\n\n#### 标签\n```js\n if (oldVnode.tag !== vnode.tag) {\n  return oldVnode.el.parentNode.replaceChild(createElm(vnode), oldVnode.el);\n }\n```\n先比较tag是否一致，不一致就`不会再去比较子节点`了，直接将旧节点替换成新节点(`createElm(vnode)`)\n#### 文本\n```js\n  // 此时tag===undefined\n  if (!oldVnode.tag) {\n    // 文本\n    if (oldVnode.text !== vnode.text) {\n      return (oldVnode.el.textContent = vnode.text);\n    }\n  }\n```\n然后没有tag，肯定是文本，判断文本是否一致，`不一致再进行更新`（`直接将旧节点的textContent赋值为vdom的text`）\n#### 属性\n```js\n  let el = (vnode.el = oldVnode.el); // 标签一样，直接复制老的节点,不用重新创建了\n  updateProperties(vnode, oldVnode.data); // 更新属性\n```\n如果标签一致且不是文本，就比较属性。因为标签一致，所以直接复制（`vnode.el = oldVnode.el`）老的节点,不用重新创建了。\n\n```js\n// 更新属性\nfunction updateProperties(vnode, oldProps = {}) {\n  let newProps = vnode.data || {};\n  let el = vnode.el;\n  // 1.遍历老的属性\n  for (let key in oldProps) {\n    // 如果老的不存在新的属性，删除\n    if (!newProps[key]) {\n      el.removeAttribute(key);\n    }\n  }\n  // 2.样式处理\n  let newStyle = newProps.style || {};\n  let oldStyle = oldProps.style || {};\n  for (let key in oldStyle) {\n    // 如果老的不存在新的样式，删除\n    if (!newStyle[key]) {\n      // js中删除样式，直接设置为空或者null即可,注意undefined不管用\n      el.style[key] = \"\";\n    }\n  }\n  // 3.遍历新的属性\n  for (let key in newProps) {\n    if (key === \"style\") {\n      for (let styleName in newProps[key]) {\n        el.style[styleName] = newProps[key][styleName];\n      }\n    } else if (key === \"class\") {\n      el.className = newProps[key];\n    } else {\n      el.setAttribute(key, newProps[key]);\n    }\n  }\n}\n```\n更新原则就是：\n- 遍历老的属性，新的不存在就删除\n- 遍历新的属性，老的不存在就增加\n- style也要按上述原则进行遍历\n- class直接覆盖\n#### 子节点children-1\n\n```js\n// 4.比较子节点\n  let oldChildren = oldVnode.children || [];\n  let newChildren = vnode.children || [];\n\n  if (oldChildren.length > 0 && newChildren.length > 0) {\n    // 老的有子节点，新的也有子节点\n    updateChildren(el, oldChildren, newChildren);\n  } else if (oldChildren.length > 0) {\n    // 老的有子节点，新的没有\n    el.innerHTML = \"\";\n  } else if (newChildren.length > 0) {\n    // 新的有子节点，老的没有\n    for (let i = 0; i < newChildren.length; i++) {\n      let child = newChildren[i];\n      el.appendChild(createElm(child));\n    }\n  }\n```\n最后比较children,比较原则就是：\n- 老的有子节点，新的也有子节点，执行updateChildren对比（核心，比较复杂，下面单独讲）\n- 老的有子节点，新的没有，老的直接清空(` el.innerHTML = \"\"`)\n- 新的子节点，老的没有，遍历新的进行新增\n\n#### 子节点children-2(updateChildren)\n```js\n// 比较两个虚拟节点是否一致\nfunction isSameVnode(oldVnode, newVnode) {\n  return oldVnode.tag === newVnode.tag && oldVnode.key === newVnode.key && oldVnode.type === newVnode.type;\n}\n// 比较子节点，更新子节点，需要用到双指针\nfunction updateChildren(parent, oldChildren, newChildren) {\n  // 1.创建双指针\n  let oldStartIndex = 0; // 老的开始索引\n  let oldStartVnode = oldChildren[0]; // 老的开始节点\n  let oldEndIndex = oldChildren.length - 1; // 老的结束索引\n  let oldEndVnode = oldChildren[oldEndIndex]; // 老的结束节点\n\n  let newStartIndex = 0; // 新的开始索引\n  let newStartVnode = newChildren[0]; // 新的开始节点\n  let newEndIndex = newChildren.length - 1; // 新的结束索引\n  let newEndVnode = newChildren[newEndIndex]; // 新的结束节点\n\n  // 2.创建Ovnode映射表\n  function makeIndexByKey(children) {\n    let map = {};\n    children.forEach((child, index) => {\n      map[child.key] = index;\n    });\n    return map;\n  }\n  let map = makeIndexByKey(oldChildren);\n\n  // 3.循环比较\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    // 1.新的开始节点和老的开始节点比较\n    if (!oldStartVnode) {\n      // 老的开始节点不存在，说明已经被移动走了\n      oldStartVnode = oldChildren[++oldStartIndex];\n    } else if (!oldEndVnode) {\n      // 老的结束节点不存在，说明已经被移动走了\n      oldEndVnode = oldChildren[--oldEndIndex];\n    } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n      // 新的开始节点和老的开始节点一样，直接比较属性和子节点\n      patchVnode(oldStartVnode, newStartVnode);\n      // 移动指针\n      oldStartVnode = oldChildren[++oldStartIndex];\n      newStartVnode = newChildren[++newStartIndex];\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      // 新的结束节点和老的结束节点一样，直接比较属性和子节点\n      patchVnode(oldEndVnode, newEndVnode);\n      oldEndVnode = oldChildren[--oldEndIndex];\n      newEndVnode = newChildren[--newEndIndex];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n      // 新的结束节点和老的开始节点一样，直接比较属性和子节点\n      patchVnode(oldStartVnode, newEndVnode);\n      // 将老的开始节点移动到老的结束节点的后面\n      parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling);\n      oldStartVnode = oldChildren[++oldStartIndex];\n      newEndVnode = newChildren[--newEndIndex];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n      // 新的开始节点和老的结束节点一样，直接比较属性和子节点\n      patchVnode(oldEndVnode, newStartVnode);\n      // 将老的结束节点移动到老的开始节点的前面\n      parent.insertBefore(oldEndVnode.el, oldStartVnode.el);\n      oldEndVnode = oldChildren[--oldEndIndex];\n      newStartVnode = newChildren[++newStartIndex];\n    } else {\n      // 以上四种情况都不满足，需要暴力比对遍历查找\n      // 1.拿到老节点的key和索引的映射表\n      let moveIndex = map[newStartVnode.key];\n      if (moveIndex === undefined) {\n        // 说明新的开始节点在老的节点中不存在，直接插入到老的开始节点的前面\n        parent.insertBefore(createElm(newStartVnode), oldStartVnode.el);\n      } else {\n        // 说明新的开始节点在老的节点中存在，直接移动到老的开始节点的前面\n        let moveVnode = oldChildren[moveIndex];\n        oldChildren[moveIndex] = undefined; // 将移动的节点置为undefined\n        parent.insertBefore(moveVnode.el, oldStartVnode.el);\n        patchVnode(moveVnode, newStartVnode); // 比较属性和子节点\n      }\n      newStartVnode = newChildren[++newStartIndex];\n    }\n  }\n  // 4.循环结束后，老的还有剩余，新的没有，说明需要删除老的节点\n  if (oldStartIndex <= oldEndIndex) {\n    for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n      let child = oldChildren[i];\n      if (child) {\n        parent.removeChild(child.el);\n      }\n    }\n  }\n  // 5.循环结束后，新的还有剩余，老的没有，说明需要新增新的节点\n  if (newStartIndex <= newEndIndex) {\n    for (let i = newStartIndex; i <= newEndIndex; i++) {\n      // parent.appendChild(createElm(newChildren[i]));\n      // 将新的节点插入到老的结束节点的后面\n      let ele =\n        newChildren[newEndIndex + 1] == null\n          ? null\n          : newChildren[newEndIndex + 1].el;\n      parent.insertBefore(createElm(newChildren[i]), ele);\n    }\n  }\n}\n```\n在讲解之前，先学习下上面代码中的`isSameVnode`\n\n###### isSameVnode\n\n```js\n// 比较两个虚拟节点是否一致\nfunction isSameVnode(oldVnode, newVnode) {\n  return oldVnode.tag === newVnode.tag && oldVnode.key === newVnode.key && oldVnode.type === newVnode.type;\n}\n```\n此方法用来比较两个虚拟节点是否一致。\n\n```html\n<!-- 不一致，tag不一样 -->\n<div>1</div> <p>2</p> \n<!-- 一致，tag一样、key都为undefined,undefined===undefined -->\n<div>1</div> <div>2</div> \n<!-- 不一致，tag一样、key不一样 -->\n<div key=\"1\">1</div> <div>2</div>\n<!-- 不一致，tag一样、key一样、但type不一样 -->\n<input type=\"text\"> <input type=\"file\"> \n<!-- 一致，tag一样、key一样、type一样 -->\n<input type=\"text\"> <input type=\"text\">\n```\n\n###### insertBefore语法\n\n详见[w3c文档-insertBefore](https://www.w3school.com.cn/jsref/met_node_insertbefore.asp)\n\n`Node.inserBefore(a,b)`\n- 表示在Node的子节点b前面，如果a节点是通过`document.createElement`新创建的，此时表示**插入**a节点到b节点前面。\n- 如果a节点不是新创建的，本来就是Node的子节点，此时表示**移动**a节点到b节点前面。\n- 如果b为null，表示a插入/移动到末尾。\n\n##### updateChildren\n\n上面`updateChildren`方法比较复杂，我们来举个例子配合在网上找的图进行讲解：\n\n假设我们现在的dom是 `a b c d e f`,所以对应的vdom也是`a b c d e f`，更新后的vdom是 `b f g`，此时我们要进行比对\n\n```\na b c d e f\nb f g\n```\n###### 第1步\n\n<img src=\"images/patch1-1.jpg\" width=\"50%\"/>\n\n- 该方法采用双指针模式进行新旧vdom比对，首先定义4个变量，Ovdom头尾双指针index以及指针对应的头尾vdom；定义4个变量，Nvdom头尾双指针index以及指针对应的头尾vdom\n- 第一步：进行`isSameVnode`比对，即有`4种对比，头头(a与b)，尾尾(f与g)，头尾(a与g)，尾头(f与b)`,发现不相等，继续\n- 第二步：将Ovode遍历，生成一个对象映射表（key:index）,\n  判断`newStartVnode.key`在映射表中有，说明在旧节点找到了，此时就开始操作真实dom了\n  ```js\n  else{\n      let moveVnode = oldChildren[moveIndex];\n      oldChildren[moveIndex] = undefined; // 将vdom移动过的节点置为undefined\n      parent.insertBefore(moveVnode.el, oldStartVnode.el); // 移动dom到Ovdom开始指针对应的节点前面\n      patchVnode(moveVnode, newStartVnode); // 比较属性和子节点\n  }\n   newStartVnode = newChildren[++newStartIndex]; // Nvdom第一个节点已经结束，将Nvdom指针往后移动，然后重复循环前面步骤\n  ```\n此时结果如下\n<img src=\"images/patch1-2.jpg\" width=\"50%\"/>\n<img src=\"images/patch1-3.jpg\" width=\"50%\"/>\n\n###### 第2步\n\n<img src=\"images/patch2-1.jpg\" width=\"50%\"/>\n\n###### 第3步\n\n<img src=\"images/dom5.webp\" width=\"50%\"/>\n\n###### 第4步\n\n<img src=\"images/dom7.webp\" width=\"50%\"/>\n\n## 总结\n### 通过映射表对比进行移动过后，Ovdom为什么要设置为undefined，而前4种对比进行移动不需要?\n\n因为对比主要依靠双指针进行移动收缩范围，**映射表对比要设置为undefined**，是因为此时OvdomIndex指针并没有移动，后面循环还会从这里开始，所以改为undefined,会判断不存在直接跳过。\n**前四种不需要**，是因为此时OvdomIndex指针会进行移动，范围就会收缩，后面循环只会在指针内进行，所以设不设置已经无意义，反正不会走进去了（`while(oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex)`）。\n\n### 为什要加key?\n#### key的作用\n\n经常上面的理解,我们可以知道vue更新时候,使用key，diff算法能更加准确和快捷(最小化元素移动的算法).如果不使用key,vue就会**就地更新选择复用节点**,可能会产生一些bug.\n举个例子:\n```html\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <p v-if=\"a\">1:<input type=\"text\" /></p>\n      <p v-else>2:<input type=\"text\"/></p>\n      <button @click=\"a=false\">切换</button>\n    </div>\n  </body>\n  <script>\n    const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: true,\n        };\n      },\n    });\n  </script>\n</html>\n\n```\n我们在input上输入内容,切换按钮,发现input的内容并未清除.原因很简单,因为没有key, vue判断标签一样,所以自然不会更新.\n\n<img src=\"images/key1.gif\" />\n\n#### 使用index作为key产生的问题\n\n从代码的规范性来讲：基本不会考虑用index 做为key；但在实际业务开发过程，也没法强制要求后端同事返回的列表元素携带唯一的id值。\n- 对于一些数据，仅用于渲染表展示的，使用index作为key一般是没有任何问题的\n- 如果在列表中存在输入类的表单dom这种，可能就会产生错误DOM更新，界面也会有问题\n- 有新增，删除，插入，排序等破坏顺序的情况，因为用的index作为key, index变化,导致key也变化, 最终会产生没有必要的对比,降低效率,甚至产生一些问题.\n- 如果列表中是纯文本节点不会有问题,因为也会对比替换,只不过和上面第三点描述的一样, 产生了没有必要的对比.\n- 在使用非文本节点的组件，只要你的组件在遍历渲染时候没有依赖于响应式的props，那么此时对于列表的删除操作会导致视图错乱,有依赖响应式的props，用key做index就不会有问题.\n- 可不可以使用随机数作为key呢？答案自然是不能够。因为key值无论是删除还是反转，根本就不能找到相同的key，diff算法就毫无意义了，压根没有复用性可言。\n\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <ul>\n        <item v-for=\"(item,index) in data\" :key=\"index\"></item>\n      </ul>\n      <button @click=\"change\">change</button>\n    </div>\n  </body>\n  <script>\n    const vm = new Vue({\n      el: \"#app\",\n      components: {\n        item: {\n          template: `<div>{{window.Math.random()}}</div>`,\n        },\n      },\n      data() {\n        return {\n          data: [1, 2, 3, 4, 5],\n        };\n      },\n      methods: {\n        //删除数据\n        change() {\n          this.data.splice(0, 1);\n        },\n      },\n    });\n  </script>\n</html>\n\n```\n上面代码是删除的第一项,但发现每次都是最后一个被删掉.\n\n<img src=\"images/key2.gif\" />\n\nTODO: 后面学习到组件对比会讲解.\n\n\n> https://zhuanlan.zhihu.com/p/225105999\n  ","categories":["vue2源码"]},{"title":"8.watch","url":"/ypf-blog/2023/08/04/vue2源码/8.watch/","content":"## watch的用法\n  \n我们先看下watch的几种用法。\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.min.js\"></script>\n    <!-- <script src=\"./dist/vue.js\"></script>  -->\n  </head>\n  <body>\n    <div id=\"app\" style=\"font-size: 12px; color: red\">{{a}}</div>\n  </body>\n  <script>\n    const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n        };\n      },\n      watch: {\n        a: {\n          handler(newValue, oldValue) {\n            console.log(\"watch: 对象调用：\", newValue, oldValue);\n          },\n        },\n      },\n    });\n    setTimeout(() => {\n      vm.a = 2;\n    }, 1000);\n  </script>\n</html>\n\n```\n\n### 对象\n\n我们通常使用对象形式监听数据变化。\n\n```js\n   watch: {\n        a: {\n          handler(newValue, oldValue) {\n            console.log(\"watch: 对象调用：\", newValue, oldValue);\n          },\n        },\n  },\n```\n如果不需要immediate等属性，可以改成如下形式\n```js\n watch: {\n  a(newValue, oldValue) {\n    console.log(\"watch: 方法调用：\", newValue, oldValue);\n  },\n }\n```\n\n### 数组\n\n我们也可以使用数组的写法\n\n```js\n    watch: {\n        a: [\n          (newValue, oldValue) => {\n            console.log(\"watch: 数组调用：\", newValue, oldValue);\n          },\n          (newValue, oldValue) => {\n            console.log(\"watch: 数组调用：\", newValue, oldValue);\n          },\n        ],\n    }\n```\n\n或者\n```js\nwatch: {\n      a: [\n          {\n            handler(newValue, oldValue) {\n              console.log(\"watch: 对象调用：\", newValue, oldValue);\n            },\n            immediate: true,\n          },\n          {\n            handler(newValue, oldValue) {\n              console.log(\"watch: 对象调用：\", newValue, oldValue);\n            },\n            immediate: true,\n          },\n      ],\n}\n```\n\n数据变化时，上面数组里面的监听方法会依次同时执行。\n\n### 函数\n\n```js\n   methods: {\n      aa(newValue, oldValue) {\n        console.log(\"watch: methods方法调用：\", newValue, oldValue);\n      },\n    },\n    watch: {\n      a: \"aa\",\n    },\n```\n\n我们也可以把函数放到methods中来监听，但是此种写法不能配置immediate等属性，所以一般不用。\n\n### 实例监听\n\n```js\n    const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n        };\n      },\n    })\n    vm.$watch('a',(newValue, oldValue)=>{\n      console.log(newValue, oldValue,1);\n    })\n```\n我们可以直接通过实例原型上的$watch方法监听。\n\n## watch实现原理\n\n```js\nsrc/state.js\nimport { observe } from \"./observer/index\";\nimport { nextTick } from \"./utils/next-tick\";\nimport Watcher from \"./observer/watcher\";\nexport function initState(vm) {\n  const opts = vm.$options;\n  if (opts.props) {\n    initProps(vm);\n  }\n  if (opts.methods) {\n    initMethods(vm);\n  }\n  if (opts.data) {\n    initData(vm);\n  }\n  if (opts.computed) {\n    initComputed(vm);\n  }\n  // 1.增加初始化watch\n  if (opts.watch) {\n    initWatch(vm);\n  }\n}\n\n// 2.增加watch方法\nfunction initWatch(vm) {\n  let watch = vm.$options.watch;\n  for (let key in watch) {\n    const handler = watch[key]; // handler可能是数组，字符串，对象，函数\n    if (Array.isArray(handler)) {\n      // 数组,[handler1,handler2,...]\n      handler.forEach((handle) => {\n        createWatcher(vm, key, handle);\n      });\n    } else {\n      // 字符串，对象，函数\n      // 创建一个方法处理handler\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n// 3.增加watcher生成器\nfunction createWatcher(vm, exprOrFn, handler, options) {\n  // 如果是对象，取出handler\n  if (typeof handler === \"object\") {\n    options = handler; // 因为是对象，所以直接赋值给options配置\n    handler = handler.handler;\n  }\n  // 如果是字符串，取出handler\n  if (typeof handler === \"string\") {\n    handler = vm[handler];\n  }\n  // 函数，最终调用$watch方法来实现\n  return vm.$watch(exprOrFn, handler, options);\n}\nexport function stateMixin(Vue) {\n  Vue.prototype.$nextTick = function (cb) {\n    nextTick(cb);\n  };\n  // 4.Vue实例绑定$watch方法\n  Vue.prototype.$watch = function (exprOrFn, handler, options = {}) {\n    // 渲染走的是watcher，只不过此时目的是渲染，watch也走watcher，只不过此时目的是监听\n    // 数据应该依赖这个watcher，数据变化后应该让watcher从新执行\n    console.log(exprOrFn,typeof exprOrFn,'exprOrFn');\n    \n    const watcher = new Watcher(this, exprOrFn, handler, {\n      ...options,\n      user: true, // 标识是用户watcher\n    });\n    // 如果用户传入了immediate，应该立即执行\n    if (options.immediate) {\n      // handler.call(this);\n      handler.call(this, watcher.value);\n    }\n  };\n}\n```\n\n```js\nsrc/observer/watcher.js\nclass Watcher {\n  constructor(vm, exprOrFn, cb, options) {\n    this.vm = vm; // vm实例\n    this.exprOrFn = exprOrFn; // vm._update(vm._render())  渲染函数\n    this.cb = cb; // 回调函数\n    this.options = options;\n    this.user = options.user; // 标识是用户watcher\n    this.deps = []; // watcher记录有多少dep依赖\n    this.depsId = new Set(); // dep去重\n    this.id = id++; // 每次产生一个watcher都有一个唯一标识，即new Watcher的次数\n    if (typeof exprOrFn === \"function\") {\n      this.getter = exprOrFn; // 用来更新视图\n    } else {\n      // 5.exprOrFn此时是watch的监听key\n      // 字符串变成函数\n      this.getter = function () {\n        // 当去当前实例上取值时，才会触发依赖收集\n        let path = exprOrFn.split(\".\"); // b.b.b\n        let obj = vm;\n\n        for (let i = 0; i < path.length; i++) {\n          obj = obj[path[i]];\n        }\n        return obj;\n      };\n    }\n    // this.get();\n    // 6.this.value存储当前值\n    this.value = this.get(); // 保存watcher的上一次结果\n    get() {\n      pushTarget(this); // 给dep添加watcher\n      const value = this.getter(); // 渲染页面 vm._update(vm._render())\n      popTarget(); // 给dep移除watcher\n      return value; // 7.将当前值返回出去\n    }\n    ...\n    \n    // 7.在数据更新时会走到这里\n    run() {\n      // this.get();\n      let value = this.get(); // 新值\n      let oldValue = this.value; // 旧值\n      this.value = value; // 更新旧值\n      if (this.user) {\n        // 用户handler\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n\n```\n此时我们就完成了watch。接下来我们总结下流程\n\n## 总结\n\n1. 我们在initState进行initWatch,该方法里面判断是数组，就遍历然后调用`createWatcher`，不是数组直接调用`createWatcher进行格式化`。\n2. createWatcher方法的目的是取出data、handler、options，最终调用`vm.$watch(exprOrFn, handler, options)`,所以`createWatcher`判断了\n```js\nfunction createWatcher(vm, exprOrFn, handler, options) {\n  // 如果是对象，取出handler\n  if (typeof handler === \"object\") {\n    options = handler; // 因为是对象，所以直接赋值给options配置\n    handler = handler.handler;\n  }\n  // 如果是字符串，取出handler\n  if (typeof handler === \"string\") {\n    handler = vm[handler];\n  }\n  // 函数，最终调用$watch方法来实现\n  return vm.$watch(exprOrFn, handler, options);\n}\n```\n3. 在vue原型上绑定$watch方法\n\n```js\nexport function stateMixin(Vue) {\n  ...\n  Vue.prototype.$watch = function (exprOrFn, handler, options = {}) {\n    // 渲染走渲染的watcher，watch走watch的watcher\n    // 数据应该依赖这个watcher，数据变化后应该让watcher从新执行\n    const watcher = new Watcher(this, exprOrFn, handler, {\n      ...options,\n      user: true, // 标识是用户watcher\n    });\n    // 如果用户传入了immediate，应该立即执行\n    if (options.immediate) {\n      handler.call(this, watcher.value);\n    }\n  };\n}\n```\n\n4.watch中接收了exprOrFn，之前对数据进行收集时，该字段是函数，即updateComponent，此时这里是data，因为data有可能会很多层，如`a.b.c`，所以进行split切割成数组循环。通过`this.value = this.get()存储当前值`。get方法中会执行`pushTarget(this)`将`Dep.target = watcher`,然后紧接着执行了`const value = this.getter()`,因为该方法里面获取了vm上的属性,从而**触发了拦截.**\n  ```js\n    constructor(vm, exprOrFn, cb, options) {\n      this.vm = vm; // vm实例\n      this.exprOrFn = exprOrFn; // vm._update(vm._render())  渲染函数\n      this.cb = cb; // 回调函数\n      this.options = options;\n      this.user = options.user; // 标识是用户watcher\n      this.deps = []; // watcher记录有多少dep依赖\n      this.depsId = new Set(); // dep去重\n      this.id = id++; // 每次产生一个watcher都有一个唯一标识，即new Watcher的次数\n      if (typeof exprOrFn === \"function\") {\n        this.getter = exprOrFn; // 用来更新视图\n      } else {\n        // 字符串变成函数\n        this.getter = function () {\n          // 当去当前实例上取值时，才会触发依赖收集\n          let path = exprOrFn.split(\".\"); // b.b.b\n          let obj = vm;\n\n          for (let i = 0; i < path.length; i++) {\n            obj = obj[path[i]];\n          }\n          return obj;\n        };\n      }\n      // 初始化更新视图\n      // this.get();\n      this.value = this.get(); // 保存watcher的上一次结果\n    }\n    get() {\n      pushTarget(this); // 给dep添加watcher\n      const value = this.getter(); // 此时该方法获取了vm上的属性会触发拦截\n      popTarget(); // 给dep移除watcher\n      return value;\n    }\n    run() {\n      // this.get();\n      let value = this.get(); // 新值\n      let oldValue = this.value; // 旧值\n      this.value = value; // 更新旧值\n      if (this.user) {\n        // 用户watcher\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  ```\n此时`defineReactive中Dep.target是watch`,因为每个属性都有一个dep,所以,此时该属性dep通过`dep.depend`收集了watcher的依赖\n```js\nfunction defineReactive(obj, key, value) {\n  console.groupInfo(`劫持对象`);\n  console.log(obj, key, value, \"obj, key, value\");\n  // 每个实例都会有dep属性\n  let childDep = observe(value); // 对象又嵌套对象\n  let dep = new Dep(); // 每个属性都有一个dep\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get() {\n      // 依赖收集(即使用vm.属性)\n      console.log(\"获取值\",key,Dep.target);\n      if (Dep.target) {\n        // Dep.target此时是watche\n        dep.depend(); // 收集依赖\n        console.log(dep, \"dep\");\n        if (childDep.dep) {\n          childDep.dep.depend(); // 收集数组依赖，这样对应的构造函数中的dep就会绑定watcher\n          console.log(childDep.dep, \"childDep.dep\");\n        }\n      }\n      return value;\n    },\n    set(newValue) {\n      if (value === newValue) {\n        return;\n      }\n      console.log(\"更新值\");\n      value = newValue;\n      observe(newValue); // 更改已经属性的值为新对象,也需要劫持\n      dep.notify(); // 通知依赖更新\n    },\n  });\n  console.groupInfoEnd();\n}\n```\n<img src=\"images/1.jpg\" width=\"70%\"/>\n<img src=\"images/2.jpg\" width=\"70%\"/>\n\n注意:上图打印的结果是基于下面的html,所以dep只会有个watch的依赖,如果使用了属性,就会有2个,一个watch一个updateComponent\n```html\n  <body>\n    <div id=\"app\" style=\"font-size: 12px; color: red\"></div>\n  </body>\n  <script>\n    const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n        };\n      },\n      watch: {\n        a: {\n          handler(newValue, oldValue) {\n            console.warn(\"watch: 对象调用：\", newValue, oldValue);\n          },\n          // immediate: true,\n        },\n      },\n    });\n  </script>\n```\n当数据更新时候,就会触发`dep.notify()`,\n```js\nclass Dep {\n  constructor() {\n    this.id = id++;\n    this.subs = [];\n  }\n  // 收集watcher\n  depend() {\n    // 我希望watcher也可以存储dep\n    // 双向记忆\n    // this.subs.push(Dep.target);\n    Dep.target.addDep(this); // 让watcher存储dep,实现双向记忆    \n  }\n  // 绑定watcher，因为我们去掉了原来的dep里面push watcher，所以dep下面没有watcher了，所以需要定义该方法来接收watcher\n  addSub(watcher) {\n    this.subs.push(watcher);\n  }\n  // 更新\n  notify() {    \n    this.subs.forEach((watcher) => watcher.update());\n  }\n}\n```\n\n然后执行 `watcher.update()`\n\n```js\n  update() {\n    queueWatcher(this); // 将watcher存储起来\n  }\n  function queueWatcher(watcher) {\n    const id = watcher.id;\n    if (has[id] == null) {\n      // 如果没有就添加到队列中，去重，防止重复更新，类似防抖\n      has[id] = true; // 表示已经存在\n      queue.push(watcher); // 将watcher存储到队列中\n      // 延迟清空队列\n      if (!pending) {\n        pending = true;\n        nextTick(flushQueue); // 相当于定时器，异步更新\n      }\n    }\n  }\n  // 清空队列 flush:冲洗\n  function flushQueue() {\n    console.log(queue, \"queue\");\n    queue.forEach((watcher) => {\n      watcher.run();\n    }); // 执行watcher的更新方法\n    has = {};\n    queue = [];\n    pending = false;\n  }\n  run() {\n    let value = this.get(); // 新值\n    let oldValue = this.value; // 旧值\n    this.value = value; // 更新旧值\n    // if (this.user) {\n      this.cb.call(this.vm, value, oldValue);\n    // }\n  }\n```\n\n最后执行`run，进行触发this.get`，将`新值(this.get())和旧值（this.value）``通过cb(watch回调函数)传出去`。\n","categories":["vue2源码"]},{"title":"7.nextTick和生命周期updated","url":"/ypf-blog/2023/07/26/vue2源码/7.nextTick和生命周期updated/","content":"## 修改数据，重复调用vm._update(vm._render)？\n\n我们看一段代码：\n\n```js\n    const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n          c: [1, 2, 3],\n        };\n      },\n    });\n    setTimeout(() => {\n      vm.a = 2;\n      vm.c.push(4);\n      console.log(vm.$el, \"vm\"); <div>2[1,2,3,4]<div>\n    }, 1000);\n```\n  \n我们上面更改了2次数据，就会走2次`vm._update(vm._render)`,这样肯定会浪费性能（每次都要生成虚拟dom，更新真实dom）.\n<img src=\"images/update.jpg\" width=\"50%\"/>\n\n实际我们只需要更新一次就行。现在我们来实现下。\n\n## 防抖\n\n多次执行，我们很容易想到防抖函数，只执行一次即可。\n\n```js\n修改src/observer/watcher.js\nclass Watcher {\n  ...\n  update() {    \n    // this.get()  // 1.去掉直接更新\n    queueWatcher(this); // 2.将watcher存储起来\n  }\n  run() {\n    this.get();\n  }\n}\n\n// 4.清空队列 flush:冲洗\nfunction flushQueue() {\n  queue.forEach((watcher) => watcher.run()); // 执行watcher的更新方法\n  has = {};\n  queue = [];\n  pending = false;\n}\nlet has = {}; // 用来存储watcher的id，防止重复更新\nlet queue = []; // 将需要批量更新的watcher存储到一个队列中，稍后让watcher执行\nlet pending = false; // 默认没有等待更新\n// 3. 定义防抖函数，等待所有同步代码执行完毕后再执行，防止重复更新\nfunction queueWatcher(watcher) {\n  const id = watcher.id; \n  if (has[id] == null) {\n    // 如果没有就添加到队列中\n    has[id] = true; // 表示已经存在\n    queue.push(watcher); // 将watcher存储到队列中\n    console.log(queue, \"queue\");\n    // 延迟清空队列\n    if (!pending) {\n      pending = true;\n      setTimeout(() => {\n        flushQueue();\n      }, 0);\n    }\n  }\n}\n```\n\n上面代码很容易看懂，先不执行watcher，而是存起来（根据id去重，所以保留了第一次），等主线程结束，执行。这样就只会执行一次了。\n\n<img src=\"images/update1.jpg\" width=\"50%\"/>\n\n上图很明显可以看出只执行一次。但是打印的dom不是最新的了。\n**我们由此可以知道，vue更新Dom是异步更新。**\n\n## nextTick\n\n> 官方对其定义为：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后使用这个方法，才可以获取更新后的 DOM\n\n现在我们结合上面讲解的理解下。\n我们上面更改数据后，打印了`console.log(vm.$el, \"vm\")`。\n- 第一次，没有防抖（多次更新），可以直接拿到最新节点，数据也是最新的\n- 第二次，加上防抖，无法拿到最新节点，但数据是新的，很容易理解，我们是在主线程结束后，才进行的更新。\n所以我们来实现`nextTick`方法\n\n```js\nconsole.log(vm.$el, \"vm\") // 不是最新的\nvm.nextTick(()=>{\n  console.log(vm.$el, \"vm\") // 是最新的\n})\n```\n\n```js\n修改src/observer/watcher.js\n// 定义防抖函数，等待所有同步代码执行完毕后再执行，防止重复更新\nfunction queueWatcher(watcher) {\n  const id = watcher.id; \n  if (has[id] == null) {\n    // 如果没有就添加到队列中\n    has[id] = true; // 表示已经存在\n    queue.push(watcher); // 将watcher存储到队列中\n    console.log(queue, \"queue\");\n    // 延迟清空队列\n    if (!pending) {\n      pending = true;\n      // 1.去除定时器\n      // setTimeout(() => {\n      //   flushQueue();\n      // }, 0);\n      // 2.改成nextTick调用\n      nextTick(()=>{\n        flushQueue();\n      })\n    }\n  }\n}\n```\n\n```js\n新增src/utils/next-tick.js\nlet callbacks = []; // 4. 用来存储nexttick回调函数\nlet pending = false;\n// 7.循环执行回调\nfunction flushCallbacks() {\n  console.log(\"callbacks\", callbacks);\n  callbacks.forEach((cb) => cb());\n  pending = false;\n}\nlet timerFunc;\n// 优雅降级，兼容性处理\nif (Promise) {\n  timerFunc = () => {\n    Promise.resolve().then(flushCallbacks); // 异步处理更新\n  };\n} else if (MutationObserver) {\n  const observer = new MutationObserver(flushCallbacks); // H5的api，监控dom变化，监控完毕后会执行回调，兼容性，ie11以上\n  const textNode = document.createTextNode(1);\n  observer.observe(textNode, { characterData: true }); // 观测文本节点，当文本节点内容发生变化时，会触发回调，处于异步线程，主线程的vm.update早已经执行完毕\n  timerFunc = () => {\n    textNode.textContent = 2; \n  };\n} else if (setImmediate) { // 性能最好，兼容性最差，只有IE支持\n  timerFunc = () => {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n// 3.定义nextTick\nexport function nextTick(cb) {\n  callbacks.push(cb);\n  // 5.多个nextTick只异步执行第一次\n  if (!pending) {\n    pending = true;\n    // 6.执行异步函数（优雅降级）\n    timerFunc();\n  }\n}\n```\n\n上面的代码很容易理解，就是兼容不同浏览器，进行优雅降级。\n\n### MutationObserver\n\n#### 兼容性\n<img src=\"images/mutationObserver.jpg\" width=\"50%\"/>\n\n- 兼容性-ie11及以上\n- 微任务\n\n#### 用法\n> MutationObserver 是一个可以监听DOM结构(属性、子节点等)变化的接口。\n我们来实现一个最简单的demo\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <img src=\"\" alt=\"\" id=\"img\" />\n  </body>\n  <script>\n    // 1.定义要监听的dom\n    var targetNode = document.getElementById(\"img\"); \n    // 2.创建一个observer实例\n    const observer = new MutationObserver((mutations) => {\n      console.log(mutations, 1);\n    });\n    // 3.监听dom变化（属性必填，至少写一个）\n    observer.observe(targetNode, {\n      attributes: true, // 属性变动\n      characterData: true, // 节点内容或节点文本的变动\n      childList: true, // 子节点的变动\n      subtree: true, // 表示是否将观察器应用于该节点的所有后代节点\n      attributeOldValue: true, // 表示观察 attributes 变动时，是否需要记录变动前的属性值\n      characterDataOldValue: true, // 表示观察 characterData 变动时，是否需要记录变动前的值\n      attributeFilter: [\"src\"] // 数组，表示需要观察的特定属性 （比如： [\"class\", \"src\"]）,默认不写，所有属性生效，此处写了src，只对src生效\n    });\n    // 4.测试，我们更改属性，可以看到上面第二步可以打印\n    targetNode.src = \"https://www.baidu.com/img/flexible/logo/pc/result.png\";\n    setTimeout(() => {\n      targetNode.style.width=\"100px\"\n    }, 0);\n  </script>\n</html>\n```\n我们打印监听的变化，MutationRecord，会打印两次，如下图，是个数组：\n<img src=\"images/mutationRecord.jpg\" width=\"50%\"/>\n\n- 注意，如果去掉定时器，相当于初始化就改了2个属性，只会打印一次，只不过数组里面是2个MutationRecord\n\n```js\n  // 停止观察， 调用该方法后，DOM 再发生变动，也不会触发观察器\n  observer.disconnect();\n  // 清除变动记录，即不再处理未处理的变动，改方法返回变动记录的数组。\n  observer.takeRecords();\n\n  // 保存所有没有被观察器处理的变动\n  var changes = observer.takeRecords();\n  console.log(changes, \"changes\");\n  // 停止观察\n  observer.disconnect();\n\n  MutationRecord 对象\n  type： 观察的变动类型\n  target：发生变动的DOM节点\n  addedNodes：新增的DOM节点\n  removeNodes：删除的DOM节点\n  previousSibling：前一个同级节点，如果没有则返回null\n  nextSibling：下一个同级节点，如果没有则返回null\n  attributeName：发生变动的属性。如果这只了 attributeFilter，则只返回预先指定的属性\n  oldValue：变动前的值。这个属性只对 attribute和characterData变动有效，如果发生childList变动，则返回null\n\n```\n\n### setImmediate\n\n<img src=\"images/setImmediate.jpg\" width=\"50%\"/>\n\n- 只有ie10及以上兼容和node\n- 语法为`setImmediate（func，[ param1，param2，...]`\n- setImmediate表示事件循环结束后立即执行，是宏任务,setTimeout/setInterval也是宏任务。\n- setImmediate类似于`setTimeout(fn,0)`,**正常情况下**setImmediate比setTimeout先执行。因为 setImmediate(fn) 并不像 setTimeout(fn, 0) 由event loop检测系统时间是否到点然后向事件队列插入一个事件，然后调用事件的回调方法fn。而是监控UI线程的调用栈，一旦调用栈为空则将handler压栈。但有时候setTimeout(fn,0)比先setImmediate先执行\n\n那为什么两者都代表主线程完成后立即执行，其执行结果是不确定的。我们在node中执行下下面代码\n\n```js\nsetTimeout(() => {\n    console.log(2);\n}, 0);\nsetImmediate(()=>{\n    console.log(1);\n})\n```\n执行上面代码，大部分输出的是`1 2` ,有时候会输出 `2 1`。\n因为：\n\n- node.js里面setTimeout(fn, 0)会被强制改为setTimeout(fn, 1),这在官方文档中有说明。(说到这里顺便提下，HTML 5里面setTimeout最小的时间限制是4ms)。\n- 我们发现关键就在这个1毫秒，如果同步代码执行时间较长，进入Event Loop的时候1毫秒已经过了，setTimeout执行，如果1毫秒还没到，就先执行了setImmediate。\n\n###  实现vm.$nextTick\n```js\n修改src/state.js\n// 1.新增mixin\nexport function stateMixin(Vue) {\n  Vue.prototype.$nextTick = function (cb) {\n    nextTick(cb);\n  };\n}\n修改src/index.js\nimport { initMixin } from \"./init\";\nimport { lifecycleMixin } from \"./lifecycle\";\nimport { renderMixin } from \"./vdom/index\";\nimport { initGlobalAPI } from \"./global-api/index\";\nimport { stateMixin } from \"./state\";\nfunction Vue(options) {\n  this._init(options);\n}\ninitMixin(Vue)\nlifecycleMixin(Vue) // 添加生命周期\nrenderMixin(Vue) // 添加render\ninitGlobalAPI(Vue) // 添加全局api\n// 2.引入\nstateMixin(Vue) // 添加状态\n\nexport default Vue;\n```\n此时我们就可以使用vm.$nextTick访问最新的dom了。\n<img src=\"images/nextTick.jpg\" width=\"50%\"/>\n\n\n## 总结\n\n- nextTick是用来解决多次`vm._update(vm._render())`,该方法里面进行了优雅降级。 `promise>MutationObserver>setImmediate>setTimeout`。\n- vue在观察到数据变化后，会先定义`let queue=[]存储watcher队列`,定义`let has={}存储watcher.id`,定义`let pending=false控制只执行一次更新`，当多个watcher过来的时候,判断没有id添加进去，同时pending置为true防止多次执行nextTick,等主线程结束后，执行异步nextTick进行更新，将队列清空、pending还原：\n\n```js\n if (has[id] == null) {\n    has[id] = true;\n    queue.push(watcher); // 将watcher存储到队列中\n    // 延迟清空队列\n    if (!pending) {\n      pending = true;\n      nextTick(flushQueue); // 相当于定时器，异步更新\n      // setTimeout(() => {\n      //   flushQueue();\n      // }, 0);\n    }\n  }\n```\n- 只更新一次，是因为pending开始为false，先一直添加队列。 将pending直接修改为true，这样只添加一次。\n- 因为是异步线程，所以同步执行完（在下次 DOM 更新循环结束之后）才会nextTick拿到最新dom。\n- vue是异步更新dom\n\n## 生命周期updated\n\n上面我们执行了`合并更新`，那都更新了，肯定到update钩子函数了。我们来实现下：\n\n```js\n修改src/lifecycle.js\nexport function mountComponent(vm, el) {\n  callHook(vm, \"beforeMount\");\n  // render-->vnode-->真实dom\n  // 1.调用vm._render函数，生成虚拟dom  2.调用vm._update,将虚拟dom转换成真实dom\n  // vm._update(vm._render());\n  const updateComponent = () => {   \n    console.log(\"updateComponent\")         \n    vm._update(vm._render())\n  }\n  new Watcher(vm,updateComponent,()=>{\n    callHook(vm, \"updated\"); // 1.增加第三个参数：回调函数，此时走的updated钩子\n  },true) // 参数1：实例，参数2：更新函数，参数3：渲染函数，参数4：true表示是渲染watcher\n  callHook(vm, \"mounted\");\n}\n```\n```js\n修改src/observer/watcher.js\n// 清空队列 flush:冲洗\nfunction flushQueue() {\n  console.log(queue, \"queue\");\n  queue.forEach((watcher) => {\n    watcher.run()\n    watcher.cb() // 2.增加调用cb方法\n  }); \n  has = {};\n  queue = [];\n  pending = false;\n}\n```\n\n这样我们就完成了`updated`,即vue是在`new watcher回调函数中传递updated钩子函数，在异步执行flushQueue清空watcher队列函数里面，循环调用watcher的update同时调用传过来的回调，从而触发updated的`\n>[setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop](https://juejin.cn/post/6844904100195205133?searchId=20230801164819BBB58747D441190201B6#heading-0)","categories":["vue2源码"]},{"title":"6.页面更新之watcher和Dep","url":"/ypf-blog/2023/07/21/vue2源码/6.页面更新之watcher和Dep/","content":"## 修改数据，页面如何更新？\n在讲解watcher和dep之前，我们先看下面例子：\n```html\n修改index.html\n  <div id=\"app\" style=\"font-size: 12px; color: red\">\n    测试{{a}}\n    <h1>1</h1>\n    {{a}}\n    {{a}}\n  </div>\n  <script> \n     const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n        };\n      },\n    });\n    setTimeout(() => {\n      vm.a=2\n      console.log(vm, \"vm\");\n    }, 1000);  \n  </script>\n```\n我们执行上上面代码，发现视图并没有更新，但数据是变化了。原来我们初始化的时候在下面js中调用了`vm._update(vm._render())`进行了页面更新，\n但修改数据又没有调用该方法，所以必然不可能更新视图。\n```js\nsrc/lifecycle.js\n// 挂载组件\nexport function mountComponent(vm, el) {\n  callHook(vm, \"beforeMount\");\n  // render-->vnode-->真实dom\n  // 1.调用vm._render函数，生成虚拟dom  2.调用vm._update,将虚拟dom转换成真实dom\n  vm._update(vm._render());\n  callHook(vm, \"mounted\");\n}\n\n```\n\n我们修改下代码：\n```html\nindex.html\n  <script> \n     const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n        };\n      },\n    });\n    setTimeout(() => {\n      vm.a=2\n      vm._update(vm._render()) // 主动触发下刷新即可\n    }, 1000);  \n  </script>\n```\n\n我们很容易想到，主动触发下属性即可。图我就不截了，答案肯定是可以的，视图会刷新。但实际项目中，不可能每改一个数据，就要调一遍刷新方法吧。所以接下来我们通过**js设计模式之发布订阅模式**来解决这个问题，实现修改数据自动刷新视图。\n\n## js设计模式之发布订阅模式\n\n我们通过一个简单的demo来实现发布订阅模式：\n\n```js\n  // 从订阅杂志角度举例说明发布订阅模式\n    // 1. 创建一个杂志社\n    const magazine = {\n      subscribers: [], // 存储订阅者信息\n      //   订阅者\n      subscribe: function (subscriber) {\n        this.subscribers.push(subscriber);\n      },\n      //   发布者\n      publish: function (message) {\n        this.subscribers.forEach((callback) => {\n          callback(message); // 执行订阅者的回调函数\n        });\n      },\n    };\n    // 2. 创建订阅者\n    const subscriber1 = function (message) {\n      console.log(\"subscriber1\", message);\n    };\n    const subscriber2 = function (message) {\n      console.log(\"subscriber2\", message);\n    };\n    const subscriber3 = function (message) {\n      console.log(\"subscriber3\", message);\n    };\n    // 3. 订阅杂志\n    magazine.subscribe(subscriber1);\n    magazine.subscribe(subscriber2);\n    magazine.subscribe(subscriber3);\n    // 4. 发布杂志\n    magazine.publish(\"hello, magazine\");\n    magazine.publish(\"hello, magazine1\");\n```\n运行结果如下：\n<img src=\"images/demo.jpg\" width=\"50%\"/>\n\n我们来理一下流程：订阅者`subscriber1、2、3`向杂志社`magazine`订阅杂志,那么杂志到了杂志社如何通知订阅者呢？\n很明显，**订阅者相当于回调函数-->传给杂志社-->杂志社通过数组存起来-->循环调用触发回调函数**，这样就完成了一个简单的发布订阅模式。\n\n- 观察者模式(Observer Patterns) 也称订阅/发布（subscriber/publisher）模式,这里的订阅者称为观察者，收集订阅者称为发布者\n- 当一个事件发生，发布者会发布通知所有订阅者，并常常以事件对象形式传递消息.所有浏览器事件（鼠标悬停，按键等事件）都是该模式的例子。\n\n## vue通过发布订阅模式更新视图\n\n理解了上面的发布订阅模式，那么我们从vue的角度思考，谁是订阅/观察者，谁是发布者？\n- 订阅者：watcher-即 `vm._update(vm._render())`\n- 发布者：Dep\n\n什么时候订阅？\n>很容易想到，在数据监听中的get方法订阅即注册\n\n发布者什么时候**通知**订阅者（触发更新）？\n>很容易想到，在数据监听中的set方法通知。\n\n现在我们在vue上实现：\n\n### 创建订阅者\n\n```js\n新建src/observer/watcher.js\nimport { pushTarget, popTarget } from \"./dep\";\n// 通过watcher类实现更新\n// 1.创建观察/订阅者\nlet id = 0;\nclass Watcher {\n  constructor(vm, exprOrFn, cb, options) {\n    this.vm = vm; // vm实例\n    this.exprOrFn = exprOrFn; // vm._update(vm._render())  渲染函数\n    this.cb = cb; // 回调函数\n    this.options = options;\n    this.id = id++; // 每次产生一个watcher都有一个唯一标识，即new Watcher的次数\n    if (typeof exprOrFn === \"function\") {\n      this.getter = exprOrFn; // 用来更新视图\n    }\n    // 初始化第一次更新视图\n    this.get();\n  }\n  get() {    \n    pushTarget(this); // 给dep添加watcher\n    this.getter(); // 渲染页面 vm._update(vm._render())\n    popTarget(); // 给dep移除watcher (多组件绑定不同的watcher，所以需要清除)\n  }\n  update() {\n    this.get()\n  }\n \n}\nexport default Watcher;\n```\n\n### 创建发布者\n```js\n新建src/observer/dep.js\n// 2.创建一个Dep类，用来管理watcher\n// Dep相当于发布订阅模式中的发布者，watcher相当于订阅者\nclass Dep {\n  constructor() {\n    this.subs = [];\n  }\n  // 收集watcher\n  depend() {\n    this.subs.push(Dep.target);\n  }\n  // 更新\n  notify() {\n    this.subs.forEach((watcher) => watcher.update());\n  }\n}\nDep.target = null; // 添加一个静态属性，用来接收订阅者传递过来的回调函数（watcher），\n// 添加watcher\nexport function pushTarget(watcher) {\n  Dep.target = watcher;\n}\n// 移除watcher\nexport function popTarget() {\n  Dep.target = null;\n}\nexport default Dep;\n\n```\n上面订阅/发布两个函数定义完了，我们开始实现初始化订阅方法：\n\n### 初始化订阅方法\n```js\n修改src/lifecycle.js\nimport { patch } from \"./vdom/patch\";\nimport Watcher from \"./observer/watcher\";\n// 挂载组件\nexport function mountComponent(vm, el) {\n  callHook(vm, \"beforeMount\");\n  // render-->vnode-->真实dom\n  // 调用vm._render函数，生成虚拟dom , 调用vm._update,将虚拟dom转换成真实dom\n\n  // vm._update(vm._render()); // 3.注释直接调用的更新方法\n  // 4.将更新方法封装成函数\n  const updateComponent = () => {\n    vm._update(vm._render())\n  }\n  // 5.初始化订阅/观察函数（主要会进行pushTarget，将组件的watch绑定到发布者，\n  // vue没有用上面讲解的，订阅时候才传参给发布者，而是组件初始化就绑定，一个组件对应一个vm._update(vm._render())）\n  new Watcher(vm,updateComponent) // 参数1：实例，参数2：更新函数\n  callHook(vm, \"mounted\");\n}\n...\n```\n- 这里初始化订阅的目的，主要为了将组件的watch绑定到发布者，而不是上面讲解的订阅时传入。\n- 一个组件只对应一个vm._update(vm._render())，所以组件初始化就绑定给了发布者，不用订阅时传入。\n  \n### 开始进行订阅发布\n\n#### 对象\n```js\n修改src/oberver/index.js\nfunction defineReactive(obj, key, value) {\n  observe(value); // 对象又嵌套对象\n  let dep = new Dep(); // 每个属性都有一个dep\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get() { // 依赖收集(即使用vm.属性)\n      console.log(\"获取值\");\n      if (Dep.target) { // 需要判断，因为每个组件初始化给发布者绑定后，就会清除\n        dep.depend(); // 6.开始订阅（收集依赖），模版中用几次，就会有几次watcher,是个数组\n        console.log(dep, \"dep\"); // 打印如下图\n      }\n      return value;\n    },\n    set(newValue) {\n      if (value === newValue) {\n        return;\n      }\n      console.log(\"更新值\");\n      value = newValue;\n      observe(newValue); // 更改已经属性的值为新对象,也需要劫持\n      dep.notify(); // 7.通知发布者依赖更新 \n    },\n  });\n}\n```\n\n至此，我们就完成了自动更新。我们去除上面index.html的手动更新方法，也是可以正常更新的。\n\n注意：\n- 一个组件都只有一个watcher类，id是唯一的，因为只在初始化new一次watcher，即一个dep发布者对应一个Dep.target\n- data中一个属性，对应一个dep发布者。 一个属性在模版中用几次，就有几个watcher订阅者，因为get中监听几次（即在模板中用几次，这个用就是前面讲的转换render函数，通过with(this)会取到变量值从而触发get方法），就有几个watcher，所以dep和wather是一对多关系。\n- 所以一个属性等于一个dep发布者，里面会get时候绑定多个订阅者watcher。\n\n我们可以看下，watcher是个数组，上面index.html中，a属性在页面中用了3处，所以订阅了3次，有三个watcher；\n\n<img src=\"images/watcher.jpg\" width=\"50%\"/>\n\n上面我们index.html只是在对象的拦截做了订阅发布，数组变化，页面是不生效的，我们执行下面index.html可以看到不会生效。\n\n```html\n修改index.html\n  <div id=\"app\" style=\"font-size: 12px; color: red\">\n    测试{{a}}\n    <h1>1</h1>\n    {{b}}\n  </div>\n  <script> \n     const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n          b:[1,2]\n        };\n      },\n    });\n    setTimeout(() => {\n      vm.a=2\n      vm.b.push(3) // 不生效，页面还是显示 [1,2]\n      console.log(vm, \"vm\");\n    }, 1000);  \n  </script>\n```\n\n#### 数组\n\n上面我们完成了对象的订阅发布，那么数组如何处理呢？\n很容易想到，是在数组的拦截（walkArray函数）方法里面处理。那么肯定需要绑定dep来接收watcher。\n我们对象是给每个属性都绑定了dep,但是在defineReactive方法中定义的局部变量，walkArray是无法访问的，那么应该如何绑定？我们想下，每个对象数组都通过了`new Observer`处理的，我们可以在 Observer添加dep，这样每个对象或数组通过 `new Observer`时都会有dep，这样我们就可以访问到了。\n\n我们修改代码：\n```js\n修改src/observer/index.js\nclass Observer {\n  constructor(value) {\n    // 1. 给每个数组或对象绑定dep    \n    this.dep = new Dep(); \n    if (Array.isArray(value)) {\n      this.walkArray(value);\n      this.walkArrayObj(value);\n    } else {\n      this.walk(value);\n    }\n  }\n  ...\n  walkArray(data) {\n        ...\n        if (inserted) {\n          // 用上面存储的this，调用walkArrayObj方法，对插入的数组进行劫持， 因为这里面的this指向的是实例，即aa._data.b\n          that.walkArrayObj(inserted);\n        }\n       \n        const result=ArrayProto[key].apply(this, args)\n        // 4.通知依赖更新(注意，必须在result下面，因为上面执行完，data才会更新)\n        that.dep.notify();\n        return result;\n      };\n    });\n  }\n  ...\n}\nfunction defineReactive(obj, key, value) {\n  // 2.每个实例都会有dep属性\n  let childDep = observe(value); // 对象又嵌套对象\n  let dep = new Dep(); // 每个属性都有一个dep  \n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get() {\n      // 依赖收集(即使用vm.属性)\n      console.log(\"获取值\");\n      if (Dep.target) {\n        // Dep.target是一个watcher类\n        dep.depend(); // 收集依赖\n        // 3.收集数组依赖，这样对应的构造函数中的dep就会绑定watcher\n        if (childDep.dep) {\n          childDep.dep.depend(); \n        }\n      }\n      return value;\n    },\n    set(newValue) {\n      if (value === newValue) {\n        return;\n      }\n      console.log(\"更新值\");\n      value = newValue;\n      observe(newValue); // 更改已经属性的值为新对象,也需要劫持\n      dep.notify(); // 通知依赖更新\n    },\n  });\n}\n```\n\n这样我们就完成了数组的订阅发布，页面会更新为[1,2,3]\n\n#### 总结\n先在生命周期初始化watcher\n- 对象是给每个属性绑定dep，在get拦截中进行收集watcher，set中发布\n- 数组是在每次new Observer里面，在this绑定dep， 在get中（因为value也可能对象类型）拿到new Observer的实例，取出dep进行收集watcher，在数组拦截方法进行发布\n\n**注意**\n- 直接通过修改下标`arr[index]=xx`这种，页面不会更新， 正式的vue也不会更新，因为只是对数组方法进行拦截，没有对下标拦截，可以通过`$set(arr,index,value)`这种来更新，后面会实现该方法。\n\n### Dep和watcher双向绑定\n上面我们实际已经完成了策略发布更新视图，但是目前存在1个问题：\n> watcher重复添加\n因为我们初始化，get会添加一遍watcher，但是在更新数据的时候，触发_render函数，因为要重新生成虚拟dom，（with函数会重新触发get，导致再次dep.depend），所以会重复添加。并且一个属性用几次，就有几个watcher也不合理，因为都是一样的watcher，浪费性能。应该一个属性在组件中无论用几次，都绑定一个watcher。如果不同组件，实际测试，直接有新dep了。\n\n基于上面1个问题，以及后面要讲到的computed，我们需要实现Dep和watcher双向绑定。\n\n\n#### 什么是双向绑定？\n\n因为现在一个属性对应一个dep，一个dep绑定多个watcher, 我们只知道，dep下面subs存储watcher， **但是watcher下面没有存储是哪个dep，如果实现了这层，就实现了双向绑定**。\n\n#### 实现\n\n理一下思路：\n我们先把dep绑定watcher去掉，使得dep下的watcher关系也不存在，这样双方目前都没关系。\n```js\n修改src/oberver/dep.js\nclass Dep {\n  constructor() {\n    this.subs = [];\n  }\n  // 收集watcher\n  depend() {\n    // this.subs.push(Dep.target); // 1.去掉直接push操作，此时dep下面没有watcher了，也没有依赖关系    \n  }\n  ...\n```\n要实现双向绑定：相当于dep里面定义addSub方法接收watcher， watcher定义addDep方法接收dep，也就是说dep里面添加watcher，watcher里面添加dep，最后收集依赖的时候执行这两个方法。\n\n##### dep定义addSub接收watcher\n\n```js\n修改src/oberver/dep.js\n\nlet id = 0; // 4. 存入watcher前增加id唯一标识用来去重\nclass Dep {\n  constructor() {\n    this.id = id++;\n    this.subs = [];\n  }\n  // 收集watcher\n  depend() {\n    // 我希望watcher也可以存储dep\n    // 双向记忆\n    // this.subs.push(Dep.target); // 去掉直接push操作，此时dep下面没有watcher了\n    Dep.target.addDep(this); // 4.开始执行双向绑定，Dep.target就是watcher，相当于watcher.addDep,将当前dep存入watcher\n    console.log(Dep);\n    \n  }\n  // 2. 定义该方法来接收watcher\n  addSub(watcher) {\n    this.subs.push(watcher);\n  }\n```\n此时我们修改watcher\n\n##### watcher定义addDep接收dep\n```js\nclass Watcher {\n  constructor(vm, exprOrFn, cb, options) {\n    this.vm = vm; // vm实例\n    this.exprOrFn = exprOrFn; // vm._update(vm._render())  渲染函数\n    this.cb = cb; // 回调函数\n    this.options = options;\n    this.deps = []; // 5.用来存储dep依赖\n    this.depsId = new Set(); // 6.用来存储dep依赖的id，去重\n    this.id = id++; // 每次产生一个watcher都有一个唯一标识，即new Watcher的次数\n    if (typeof exprOrFn === \"function\") {\n      this.getter = exprOrFn; // 用来更新视图\n    }\n    // 初始化更新视图\n    this.get();\n  }\n  get() {\n    pushTarget(this); // 给dep添加watcher\n    this.getter(); // 渲染页面 vm._update(vm._render())\n    popTarget(); // 给dep移除watcher\n  }\n  // 3.定义该方法来接收dep\n  addDep(dep) {\n    let id = dep.id;\n    // 7. 没有，增加进去\n    if (!this.depsId.has(id)) {\n      this.depsId.add(id);\n      this.deps.push(dep);\n      // 8.watcher绑定了dep的同时，做dep绑定watcher处理，将watcher传给dep\n      dep.addSub(this);\n    }\n  }\n```\n至此我们完成了双向绑定，并且解决了重复添加问题。\n\n理一下思路：\n因为是在depend里面触发更新，`push(watcher)`是直接dep绑定watcher的，但是为了给watcher绑定dep，所以需要在dep里面，从`Dep.target.addDep(this)`来触发watcher绑定dep，addDep方法主要逻辑是，判断dep.id是否存在，存在说明已经添加过了，不存在的话，通过`this.deps.push(dep)存储`，接着执行`dep.addSub(this)`将watcher传给dep。相当于每执行一次`Dep.target.addDep(this)`就执行一次`dep.addSub(this)。\n\n\n## 总结\n\n1. 为了实现修改数据自动调用`vm._update(vm._render())`，需要用到订阅发布模式。（`vm._update(vm._render())`相当于订阅者）。\n2. 创建订阅者Watcher.js和发布者Dep.js\n3. 因为初始化我们在lifecycle执行了`vm._update(vm._render())`，所以我们也把第一次也改成通过订阅发布执行。即将`const updateComponent = () => {vm._update(vm._render())}`,放到updateComponent函数中，不直接执行，而是放到watcher里面执行，执行`new Watcher(vm, updateComponent)`，Watcher就在自己类中初始化（constructor）就执行了`updateComponent以及调用dep里面的pushTarget方法，将Watcher类存储到dep.target`。\n4. 订阅数据以及双向绑定：怎样做到数据有更新就调用updateComponent呢？那肯定要先订阅数据，所以在**对象**的每一个key拦截中`Object.defineProperty的get`都绑定一个dep`let dep = new Dep()`，然后调用`dep.depend`进行订阅，dep.depend里面的逻辑是执行`Dep.target.addDep(this)`来触发watcher绑定dep，addDep方法主要逻辑是，判断dep.id是否存在，存在说明已经添加过了，不存在的话，通过`this.deps.push(dep)存储`，接着执行`dep.addSub(this)`将watcher传给dep。相当于每执行一次`Dep.target.addDep(this)`就执行一次`dep.addSub(this)`,里面的逻辑是`this.subs.push(watcher);`。\n5.发布：当拦截到数据更新时，在set进行发布（执行dep里面的notify，实际就是循环subs执行watcher的update方法）\n6. 数组订阅和发布:前面订阅是给每个属性绑定dep，但是数组也需要绑定，所以在Observer类（typeof是对象）绑定了dep（this.dep = new Dep()），在`Object.defineProperty的get`中执行`let childDep = observe(value);childDep.dep.depend()`进行订阅，再在拦截push等等操作里面进行发布更新。\n   \n注意：\n- 完成双向绑定后，一个属性对应一个dep，也就是有个唯一的depId,因为有判断去重，所以，一个属性在一个组件里面用了无论多少次，都会只有一个watcher，因为depId一样，不是上面讲的一个属性用几次就有几个watcher，那样太浪费性能了。如果不同组件，通过props使用了同一个属性，但实际测试，直接有新dep存自己的watcher，new watcher都是新执行的。 ","categories":["vue2源码"]},{"title":"5.生命周期和vue.mixin","url":"/ypf-blog/2023/07/19/vue2源码/5.生命周期和vue.mixin/","content":"## Vue.mixin\n在学习生命周期之前，我们先看下vue.mixin是如何实现的，因为生命周期用到了`Vue.mixin所用到的mergeOptions方法`，所以先讲`Vue.mixin`\n\n### 全局混入`Vue.mixin`\n这里先讲下全局混入，局部混入后面再讲。\n\n```js\n修改 index.html\n    Vue.mixin({\n      created: function a() {\n        console.log(\"全局混入created-1\");\n      },\n    });\n    Vue.mixin({\n      created: function b() {\n        console.log(\"全局混入created-2\");\n      },\n    });\n    const vm = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n        };\n      },\n      created: function e() {\n        console.log('组件created');\n      },\n    });\n    console.log(vm, \"vm\");\n```\n上面代码，在正常vue中，打印顺序为 **全局混入created-1、全局混入created-2、组件created**，现在我们来实现下\n\n```js\n1.新建global-api/index.js\nimport { mergeOptions } from \"../utils/index\";\n// 说明：全局api\nexport function initGlobalAPI(Vue) {\n  Vue.options = {}; // 1.Vue定义空options对象，为了在下面vue.mixin中通过this访问到\n  // 2.定义mixin方法\n  Vue.mixin = function (mixin) {    \n    this.options = mergeOptions(this.options, mixin); // 合并options赋值給this.options,下次再调用Vue.mixin时，this.options就是上次合并后的结果\n  };\n}\n2. 修改src/index.js\n...\nimport { initGlobalAPI } from \"./global-api/index\";\n...\ninitMixin(Vue)\nlifecycleMixin(Vue) // 添加生命周期\nrenderMixin(Vue) // 添加render\n// 3.引入上面创建的全局api\ninitGlobalAPI(Vue) // 添加全局api\nexport default Vue;\n\n3.新增src/utils/index.js\nlet strats = {};\nexport const Hooks = [\n  \"beforeCreate\",\n  \"created\",\n  \"beforeMount\",\n  \"mounted\",\n  \"beforeUpdate\",\n  \"updated\",\n  \"beforeDestroy\",\n  \"destroyed\",\n];\n// 遍历生命周期\nHooks.forEach((hook) => {\n  strats[hook] = mergeHook;\n});\nfunction mergeHook(parentVal, childVal) {\n  if (childVal) {\n    if (parentVal) {\n      return parentVal.concat(childVal); // 父子合并成一个数组 [parentVal,childVal]\n    } else {\n      return [childVal]; // 只有子，返回数组\n    }\n  } else {\n    return parentVal; // 只有父，返回父\n  }\n}\n// 4. 新增合并options方法\nexport function mergeOptions(parent, child) {\n  const options = {};\n  // parent有，但是child中没有的key\n  for (let key in parent) {\n    mergeField(key);\n  }\n  // child中有，但是parent中没有的key\n  for (let key in child) {\n    mergeField(key);\n  }\n  function mergeField(key) {\n    // 根据key不同，采用不同的合并策略（策略模式）\n    if (strats[key]) {\n      options[key] = strats[key](parent[key], child[key]);\n    } else {\n      options[key] = child[key] || parent[key];\n    }\n  }\n  console.log(options)\n  return options;\n}\n```\n我们执行下，如下图\n<img src=\"images/mixin1.jpg\" width=\"50%\"/>\n\n我们发现只打印了全局混入的，组件的还没有打印。我们接着修改：\n\n```js\n修改src/init.js\nimport { mergeOptions } from \"./utils/index\";\nexport function initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this;\n    // vm.$options = options;  // 5.去除\n    // 6.修改为将用户传入的options和全局的options做合并    \n    vm.$options=mergeOptions(vm.constructor.options,options)\n    // 初始化状态\n    initState(vm);\n    ...\n  };\n```\n我们执行下，如下图，可以看到合并的数组为3个\n<img src=\"images/mixin2.jpg\" width=\"50%\"/>\n我们也可以在html中打印`vm.options`也可以看到。\n现在我们options是合并到一起了，但是并未执行，接下来我们在讲解生命周期的时候来触发。\n\n## 生命周期\n我们先想下，触发上面的方法，相当于触发数组的三个函数。所以我们定义一个函数，里面循环执行不就可以了，现在我们试下：\n\n```js\n修改src/liftcycle.js\n...\n// 7.新增生命周期调用方法\nexport function callHook(vm, hook) {\n  const handlers = vm.$options[hook]; \n  if (handlers) {\n    handlers.forEach((handler) => {\n      handler.call(vm);\n    });\n  }\n}\n```\n上面代码很容易理解，定义callHook方法，里面取出上面已经合并的options进行执行即可。那我们在哪里执行呢？\n\n### 执行生命周期\n\n``` js\n1.修改src/init.js\n  ...\n  import { mountComponent,callHook } from \"./lifecycle\";\n  import { mergeOptions } from \"./utils/index\";\n  export function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      const vm = this;\n      vm.$options=mergeOptions(vm.constructor.options,options)\n      // 8.初始化生命周期-beforeCreate\n      callHook(vm, \"beforeCreate\");\n      // 初始化状态\n      initState(vm);\n      // 9.初始化生命周期-created\n      callHook(vm, \"created\");\n      // 挂载模版\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n    ...\n2.修改src/liftcycle.js\n...\n// 挂载组件\nexport function mountComponent(vm, el) {\n  // 10.初始化生命周期-beforeMount\n  callHook(vm, \"beforeMount\");\n  // render-->vnode-->真实dom\n  // 1.调用vm._render函数，生成虚拟dom 2.调用vm._update,将虚拟dom转换成真实dom\n  vm._update(vm._render());\n  // 11.初始化生命周期-mounted\n  callHook(vm, \"mounted\");\n}\n```\n至此上面我们已经完成了`beforeCreate-->created-->beforeMount-->mounted`。查看控制台，可以看到上面定义的三个created已经执行\n<img src=\"images/mixin3.jpg\" width=\"50%\"/>\n\n## 总结\n- vue的生命周期就是一个函数调用(`callHook`),调用vm.$options上对应的钩子函数**数组**\n- 这个数组是通过mergeOptions合并过来的（循环parent和child两个options，接受传过来的hook和已有的hook进行合并）\n- `vue.mixin`会优先执行，然后执行组件的。 因为实际使用中，我们是在main.js定义，会最先执行。如果在index.html使用，`也要放到new Vue前面，否则不会被合并到数组执行`。\n- 后面会讲：如果组件有mixin,也是混入的先执行，组件的后执行。还有data、methods、computed定义的组件会直接覆盖混入的。watch是混入先执行，组件后执行。","categories":["vue2源码"]},{"title":"4.模版编译","url":"/ypf-blog/2023/07/11/vue2源码/4.模版编译/","content":"\n我们前面讲了vue初始化的时候会进行数据劫持，下面我们开始讲vue的模版编译，在这之前我们先看下官网的生命周期\n\n## 生命周期\n\n<img src=\"images/lifecycle.png\" width=\"50%\"/>\n\n[vue2官网-生命周期](https://v2.cn.vuejs.org/v2/guide/instance.html)\n\n### vue大致渲染流程\nvue初次渲染（ new vue() ）->初始化数据(initState)->**模版编译**->将template变成render->生成虚拟dom->变成真实dom->放到页面\n\n### 本节要讲的模版编译的流程\n首先el必须要有\n        ->有render直接生成虚拟dom\n        ->没有render，判断option中有没有template选项，有的话将template->变成render->生成虚拟dom\n                       -> 没有template，直接将`el.outerHTML`作为模版->变成render->生成虚拟dom\n\n所以优先级是：el节点必须要有-render-template-el.outerHTML\n\n**注意：el.outerHTML()和el.innerHTML()的区别是， outerHTML包含本层，innerHTML只包含子节点**\n\n## 获取template\n\n现在我们根据上面模版编译的流程，开始通过代码获取模版\n\n```js\n修改src/init.js\n\nexport function initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this;\n    vm.$options = options;\n    initState(vm);\n    // 1. 从options中取出el进行挂载\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n  // 2. 原型上定义$mount方法\n  Vue.prototype.$mount = function (el) {\n    const vm = this;\n    const options = vm.$options;\n    el = document.querySelector(el);\n    // 默认先会查找有没有render方法，没有render会采用template，template也没有就用el中的内容\n    if (!options.render) {\n      // 对模版进行编译\n      let template = options.template;\n      if (!template && el) {\n        template = el.outerHTML;\n      }\n      // 我们可以自己测试下，在option传template会用options的，没有用el.outerHTML()\n      console.log(template);\n      //  <div id=\"app\">\n      //测试{{a}}\n    //</div>\n    }\n  };\n}\n\n```\n至此我们已经拿到了template，我们这里直接不传template，直接在body里面写,方便\n\n``` html\n修改index.html\n...\n  <body>\n    <div id=\"app\">\n      测试{{a}}\n    </div>\n  </body>\n  <script>\n    const aa = new Vue({\n      el: \"#app\",\n      data() {\n        return {\n          a: 1,\n        };\n      },\n      // template: \"<div>测试1{{a}}</div>\",\n    });\n    ...\n```\n运行如下：\n\n<img src=\"images/template-str.jpg\" width=\"50%\"/>\n\n## template变成render\n\n大致流程如下：template->ast语法树->render字符串->render函数\n\n### template变成ast\n\n上面我们已经获取到template字符串了， 那么如何转换成ast?\n\n#### vue-template-compiler包\n实际上，我们可以通过[vue-template-compiler](https://github.com/vuejs/vue/tree/main/packages/template-compiler)快速把template转换成ast。随便找个文件夹测试下：\n\n```js\nconst compiler = require('vue-template-compiler')\nconst ast=compiler.compile('<div id=\"app\">test{a}</div>')\nconsole.log(ast)\n```\n运行结果如下：\n\n<img src=\"images/compiler.jpg\" width=\"50%\"/>\n \n#### astexplorer\n\n我们也可以访问[astexplorer](https://astexplorer.net/)快速查看对应的ast\n\n<img src=\"images/ast.jpg\" width=\"50%\"/>\n\n\n#### 自己编写\n\n\n``` js\n1.修改src/init.js\n  Vue.prototype.$mount = function (el) {\n      ...\n      if (!template && el) {\n        template = el.outerHTML;\n      }\n      // 1.增加编译模版方法\n      compileToFunction(template)\n    }\n  };\n2.新建src/compiler/index.js\nimport { parseHTML } from \"./parseAst.js\";\nexport function compileToFunction(template) {\n  // 2.将模版转换成ast语法树\n  let ast = parseHTML(template);\n  console.log(ast, \"ast\");\n}\n3. 新建src/compiler/parseAst.js，定义转换ast的方法\n// Regular Expressions for parsing tags and attributes\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 匹配标签名 div、p、span等等\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`; // 匹配特殊标签名，比如：my:xx\nconst attribute =\n  /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性\nconst dynamicArgAttribute =\n  /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+?\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配动态参数\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则，捕获的内容是标签名\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 >\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配结尾标签 </div>\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // 匹配双括号\n// 构造ast语法树结构\nfunction createASTElement(tagName, attrs) {\n  return {\n    tag: tagName, // 标签名\n    type: 1, // 节点类型（js中的node.nodeType, 1 Element 2 Attribute 3 Text 4 CDATA Section 5 Entity Reference 6 Entity 7 Processing Instrucion 8 Comment 9 Document 10 Document Type 11 Document Fragment 12 Notation）\n    children: [], // 子节点\n    attrs, // 属性集合\n    parent: null, // 是否有父节点\n  };\n}\nexport function parseHTML(html) {\n  // <div id=\"app\">测试{{a}}</div>\n  // console.log(html);\n  let root = null; // 根节点\n  let stack = []; // 栈结构（先进后出），开始标签一个个入栈，结束标签一个个出栈\n  let currentParent; // 当前父节点\n  function start(tagName, attrs) {\n    console.log(tagName, attrs, \"开始标签\");\n    let element = createASTElement(tagName, attrs);\n    if (!root) {\n      root = element;\n    }\n    currentParent = element;\n    stack.push(element);\n  }\n  function end(tagName) {\n    console.log(tagName, \"结束标签\");\n    let element = stack.pop(); // 取出栈中最后一个，前一个就是当前的父节点\n    currentParent = stack[stack.length - 1]; // 当前父节点\n    if (currentParent) {\n      // 在闭合时可以知道这个标签的父亲是谁\n      element.parent = currentParent;\n      currentParent.children.push(element); // 实现一个树的父子关系\n    }\n  }\n  function chars(text) {\n    console.log(text, \"文本\");\n    text = text.replace(/\\s/g, \"\"); // 去除空格\n    if (text) {\n      currentParent.children.push({\n        // 文本没有标签，直接放到父节点的children中\n        type: 3,\n        text,\n      });\n    }\n  }\n  // html为空结束循环\n  while (html) {\n    let textEnd = html.indexOf(\"<\"); // 查找<的索引\n    // 如果当前索引为0，肯定是一个标签，开始标签<或结束标签</中的 <\n    if (textEnd == 0) {\n      // (1）开始标签\n      let startTagMatch = parseStartTag(); // 将开始标签转换成对应的ast语法树\n      console.log(startTagMatch, \"startTagMatch\");\n      //    {\n      //     \"tagName\": \"div\",\n      //     \"attrs\": [\n      //         {\n      //             \"name\": \"id\",\n      //             \"value\": \"app\"\n      //             }\n      //         ]\n      //    }\n      if (startTagMatch) {\n        start(startTagMatch.tagName, startTagMatch.attrs); // 解析开始标签\n        continue;\n      }\n      // (2）结束标签\n      let endTagMatch = html.match(endTag);\n      console.log(endTagMatch, \"endTagMatch\"); // ['</div>', 'div', index: 0, input: '</div>', groups: undefined]\n      if (endTagMatch) {\n        advance(endTagMatch[0].length); // 删除结束标签\n        end(endTagMatch[1]); //  处理结束标签\n        continue;\n      }\n    }\n    // 如果索引大于0，肯定是文本\n    let text;\n    if (textEnd > 0) {\n      text = html.substring(0, textEnd); // 获取文本\n    }\n    if (text) {\n      advance(text.length); // 删除文本\n      chars(text); // 处理文本\n    }\n  }\n  // 将开始标签转换成对应的ast语法树 {\"tagName\": \"div\",\"attrs\": [{\"name\": \"id\",\"value\": \"app\"}]}\n  function parseStartTag() {\n    let start = html.match(startTagOpen); // 匹配开始标签 结果：[\"<div\",\"div\",groups: undefined,index:0,input:\"<div id=\\\"app\\\">测试{{a}}</div>\",length:2] 或者false\n    if (start) {\n      const match = {\n        tagName: start[1], // 标签名\n        attrs: [], // 属性\n      };\n      advance(start[0].length); // 删除开始标签\n      //  匹配属性（注意：多个属性、>结束）\n      let end, attr;\n      // 如果没有遇到标签结尾就不停的解析\n      // console.log(html.match(startTagClose),1); // 匹配到了> 结果：[\">\",groups: undefined,index: 0,input: \"<div id=\\\"app\\\">测试{{a}}</div>\",length: 1]\n      // console.log(html.match(attribute),2); // 匹配到了属性 结果：[\"id=\\\"app\\\"\",\"id\",\"=\",\"app\",undefined,undefined,index: 0,input: \"<div id=\\\"app\\\">测试{{a}}</div>\",length: 2]\n      while (\n        // 没有遇到标签结尾\n        !(end = html.match(startTagClose)) &&\n        // 匹配到了动态参数属性或者匹配到了普通属性\n        (attr = html.match(dynamicArgAttribute) || html.match(attribute))\n      ) {\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5],\n        }); // 将属性放到match.attrs中\n        advance(attr[0].length); //  删除属性\n        attr.start = html.length; // 属性开始的索引\n        attr.end = html.length; // 属性结束的索引\n      }\n      if (end) {\n        advance(end[0].length); // 删除开始标签\n        return match;\n      }\n    }\n  }\n  // 删除匹配到的内容\n  function advance(n) {\n    html = html.substring(n); // 删除n个字符\n    console.log(html, \"html\");\n  }\n  return root;\n}\n\n```\n\n上面的代码在index.html用如下模版测试下\n``` html\n  <div id=\"app\">\n      测试{{a}}\n      <h1>1</h1>\n    </div>\n```\n我们打印下\n<img src=\"images/template-ast.jpg\" width=\"50%\"/>\n\n#### 梳理下流程\n\n以上面的模版为例，大致流程如下\n\nwhile循环模版字符串，匹配完一个标签或节点，删除掉，然后继续匹配，直到字符串为空结束\n1.从左至右，先判断< 开头，说明是开头标签或者结束标签，\n- 通过正则判断是开头标签，**删除掉开头标签**，解析开头标签的tagName和属性attr，变成对象结构 `{\"tagName\": \"div\",  \"attrs\": [{\"name\": \"id\",\"value\": \"app\"}]}`,继续从左至右循环，直到匹配到开头结束标签，然后删除\n  然后定义一个ast结构,并且当前节点element=`{tag: tagName, type: 1, children: [], attrs:[],parent: null}`对象格式，将当前节点element执行入栈操作，并且定义一个当前节点的父节点`currentParent=element`\n- 通过正则判断是结束标签，stack的最后一个肯定是当前节点即（element = stack.pop()），前一个是父节点，所以`currentParent=stack[stack.length - 1] , element.parent=currentParent，  currentParent.children.push(element)`，**删除结束标签**\n- 如果不是< 开头，肯定是文本，**删除掉文本**，然后解析文本：先把文本去除空格，然后 `currentParent.children.push({type: 3,text})`;\n\n### ast树转render字符串\n我们先看下render字符串长什么样子？\n用如下html举例\n```html\n    <div id=\"app\" style=\"font-size: 12px; color: red;\">\n      测试{{a}}\n      <h1>1</h1>\n    </div>\n```\n转换后的render字符串\n```js\n_c('div',{id:\"app\",style:{\"font-size\":\" 12px\",\" color\":\" red\"}},_v(\"测试\"+_s(a)),_c('h1',undefined,_v(\"1\")))\n```\n其中有三个函数，后面会定义，分别为`_c:元素 _v:文本 _s:插值表达式`,其中_c有是三个参数（tagName， 属性， children）\n\n下面我们来实现上面的render字符串：\n\n```js\n修改src/compiler/index.js\n...\nimport { generate } from \"./generate.js\";\nexport function compileToFunction(template) {\n  let ast = parseHTML(template);\n  console.log(ast, \"ast\");\n  // 1.通过ast语法树转换成render字符串\n  let code=generate(ast)\n  console.log(code,'code')\n}\n```\n```js\n新增src/compiler/generate.js\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // 匹配双括号\n\n// _c('div',{id:\"app\",style:{\"font-size\":\" 12px\",\" color\":\" red\"}},,_c('h1',undefined,_v(\"1\")))))\n// _c:元素 _v:文本 _s:插值表达式 \nexport function generate(ast) {\n  const children = genChildren(ast);  \n  let code = `_c('${ast.tag}',${\n    ast.attrs.length ? genProps(ast.attrs) : \"undefined\"\n  }${children ? `,${children}` : \"\"})`;\n  return code;\n}\n// 生成属性\nfunction genProps(attrs) {\n  let str = \"\";\n  for (let i = 0; i < attrs.length; i++) {\n    const attr = attrs[i];\n    let obj = {};\n    if (attr.name === \"style\") {\n      console.log(attr.value, \"attr.value\"); // color: red;font-size: 12px\n      attr.value.split(\";\").forEach((item) => {\n        let [key, value] = item.split(\":\");\n        obj[key] = value;\n      });\n      attr.value = obj; // {color: red,font-size: 12px}\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`;\n  }\n  console.log(str, \"str\"); // id:\"app\",style:{\"font-size\":\" 12px\",\" color\":\" red\"},\n  // 删除最后一位逗号且前面加上大括号\n  return `{${str.slice(0, -1)}}`; // {id:\"app\",style:{\"font-size\":\" 12px\",\" color\":\" red\"}}\n}\n// 生成子节点\nfunction genChildren(el) {\n  let children = el.children;\n  if (children && children.length > 0) {\n    const target= `${children.map((c) => gen(c)).join(\",\")}`;\n    return target\n  }\n  return false;\n}\nfunction gen(el) {\n    // 如果是元素节点，递归调用generate\n  if (el.type === 1) {\n    return generate(el);\n  } else {\n    let text = el.text;\n    // 如果不是双括号的话，直接返回_v(text)\n    if (!defaultTagRE.test(text)) {\n      return `_v(${JSON.stringify(text)})`;\n    }\n    // 如果是双括号的话，将双括号中的内容放入tokens\n    let tokens = []; // 存放每一段代码\n    let match, index; // 每次匹配的结果，和匹配的索引\n    let lastIndex = (defaultTagRE.lastIndex = 0); // 匹配的开始索引\n    // 每次匹配到的结果都放入tokens中\n    while ((match = defaultTagRE.exec(text))) {\n      index = match.index; // 匹配到的索引\n      if (index > lastIndex) { // 说明双括号前面有文本\n        tokens.push(JSON.stringify(text.slice(lastIndex, index))); //  双括号前面的文本\n      }\n      tokens.push(`_s(${match[1].trim()})`); // 双括号中的内容\n      lastIndex = index + match[0].length; // 匹配到的索引+匹配到的内容的长度\n    }\n    if (lastIndex < text.length) { // 说明双括号后面有文本\n      tokens.push(JSON.stringify(text.slice(lastIndex))); // 双括号后面的文本\n    }\n    return `_v(${tokens.join(\"+\")})`; // 将tokens中的内容用+拼接\n  }\n}\n\n```\n\n运行上面代码，即可打印出code。\n\n#### 梳理下流程\n先看下ast结构\n\n<img src=\"images/ast1.jpg\" width=\"50%\"/>,\n我们要转换成 `_c('div',{id:\"app\",style:{\"font-size\":\" 12px\",\" color\":\" red\"}},,_c('h1',undefined,_v(\"1\")))))`\n很明显ast是个对象，我们进行如下操作\n\n#### 第一层\n\n```js\nexport function generate(ast) {\n  const children = genChildren(ast); // 单独定义方法处理children\n  // 第一层\n  let code = `_c('${ast.tag}',${\n    ast.attrs.length ? genProps(ast.attrs) : \"undefined\" // 单独定义方法处理attrs\n  }${children ? `,${children}` : \"\"})`;\n  return code;\n}\n\n```\n\n#### 处理attrs\n```js\n将attrs数组转成json字符串{id:\"app\",style:{\"font-size\":\" 12px\",\" color\":\" red\"}}\nfunction genProps(attrs) {\n  let str = \"\";\n  for (let i = 0; i < attrs.length; i++) {\n    const attr = attrs[i];\n    let obj = {};\n    if (attr.name === \"style\") {\n      console.log(attr.value, \"attr.value\"); // color: red;font-size: 12px\n      attr.value.split(\";\").forEach((item) => {\n        let [key, value] = item.split(\":\");\n        obj[key] = value;\n      });\n      attr.value = obj; // {color: red,font-size: 12px}\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`;\n  }\n  console.log(str, \"str\"); // id:\"app\",style:{\"font-size\":\" 12px\",\" color\":\" red\"},\n  // 删除最后一位逗号且前面加上大括号\n  return `{${str.slice(0, -1)}}`; // {id:\"app\",style:{\"font-size\":\" 12px\",\" color\":\" red\"}}\n}\n```\n\n#### 处理children\n\nchildren的最终目的也是生成一个和第一步一样的结构 `_c(标签,属性,children)`。\n\n```js\n// 生成子节点\nfunction genChildren(el) {\n  let children = el.children;\n  if (children && children.length > 0) {\n    const target= `${children.map((c) => gen(c)).join(\",\")}`; // 循环children，对每一项判断是节点的话，重新调用第一步的generate方法，最后将数组用逗号拼接起来变成字符串\n    return target\n  }\n  return false;\n}\nfunction gen(el) {\n    // 如果是元素节点，递归调用generate\n  if (el.type === 1) {\n    return generate(el);\n  } else {\n    // 如果不是节点，那肯定是文本\n    let text = el.text;\n    // 如果不是双括号的话，直接返回_v(text)\n    if (!defaultTagRE.test(text)) {\n      return `_v(${JSON.stringify(text)})`;\n    }\n    // 如果是双括号的话，将双括号中的内容放入tokens\n    let tokens = []; // 存放每一段代码\n    let match, index; // 每次匹配的结果，和匹配的索引\n    let lastIndex = (defaultTagRE.lastIndex = 0); // 匹配的开始索引\n    // 每次匹配到的结果都放入tokens中\n    while ((match = defaultTagRE.exec(text))) {\n      index = match.index; // 匹配到的索引\n      if (index > lastIndex) { // 说明双括号前面有文本\n        tokens.push(JSON.stringify(text.slice(lastIndex, index))); //  双括号前面的文本\n      }\n      tokens.push(`_s(${match[1].trim()})`); // 双括号中的内容\n      lastIndex = index + match[0].length; // 匹配到的索引+匹配到的内容的长度\n    }\n    if (lastIndex < text.length) { // 说明双括号后面有文本\n      tokens.push(JSON.stringify(text.slice(lastIndex))); // 双括号后面的文本\n    }\n    return `_v(${tokens.join(\"+\")})`; // 将tokens中的内容用+拼接\n  }\n}\n```\n\n### render字符串转render函数\n\n转函数很简单，我们用函数包装起来即可\n\n```js \n修改src/compiler/index.js\n...\nimport { generate } from \"./generate.js\";\nexport function compileToFunction(template) {\n  ...\n  let code=generate(ast)\n  console.log(code,'code')\n  // 3.通过new Function + with来生成render函数\n  let render = new Function(`with(this){return ${code}}`);\n  console.log(render,'render');\n  console.log(new Function()); // 注意，没什么用，这里只是为了看下随便打印个函数是啥样子的\n  return render // render出去，调用compileToFunction的地方用\n}\n```\n\n<img src=\"images/render.jpg\" width=\"50%\"/>\n\n#### with\n我们发现上面除去定义一个函数，还使用了`with函数`，这个是干啥的？我们先了解下什么是with函数。\n```js\n  const obj={\n    a:1,\n    b:2\n  }\n  with(obj){\n    console.log(obj.a) // 1 \n    console.log(a) // 1\n  }\n```\n上面代码会自执行,执行上面代码直接会执行with函数中的代码打印\n**with函数是将代码的作用域设置到一个特定的作用域中\\(即with\\(作用域\\)\\)**，此时函数内我们可以省略`obj.`，直接拿到属性值，注意：\n- with函数已弃用，strict不能使用，会报错\n- with函数是早期的js函数，兼容所有浏览器，包括ie6\n- ES6模块（如定一个函数，使用了导入导出，或者es6的Class）自带严格模式，不管你有没有在模块头部加上\"use strict\"，所以不能使用with\n\n了解了with函数的作用，我们可以想下我们上面定义了` _c:元素 _v:文本 _s:插值表达式 `,这三个函数是直接使用的，但window上没有该方法啊，\n所以这三个方法肯定定义到vue的原型链上了，所以我们将this传入到with(this)中，就可以直接使用了。\n\n## render转vdom\n\n### vdom和ast区别\n我们先看下vdom是啥样子的？\n还是用如下html举例\n```html\n    <div id=\"app\" style=\"font-size: 12px; color: red;\">\n      测试{{a}}\n      <h1>1</h1>\n    </div>\n```\n\n```js\n// ast\n{\n  type:1,\n  parent:null,\n  tag: \"div\",\n  attrs:[\n    {\n        \"name\": \"id\",\n        \"value\": \"app\"\n    },\n    {\n        \"name\": \"style\",\n        \"value\": {\n            \"font-size\": \"12px\",\n            \"color\": \"red\"\n        }\n    }\n  ],\n  children:[\n    {type: 3, text: '测试{{a}}'},\n    {tag: 'h1', type: 1, children: [{type: 3, text: '1'}], attrs: [], parent:null}\n  ]\n}\n```\n```js\n// vdom\n{\n  tag: \"div\",\n  data:{\n    \"id\": \"app\",\n    \"style\": {\n        \"font-size\": \"12px\",\n        \"color\": \"red\"\n    }\n  },\n  children:[\n   {\"text\": \"测试1\",data:undefined,key:undefined,tag:undefined,children:undefined},\n   {\"text\": undefined,data:undefined,key:undefined,tag:\"h1\",children:[{\"text\": \"1\",data:undefined,key:undefined,tag:undefined,children:undefined}]}\n  ],\n  key:\"key\",\n  text:文本节点\n}\n\n```\n我们发现实际上ast和vdom很像，区别是：\n- 实际上ast很复杂，本例子中只是主流程，ast含有其他属性，如start、end等\n- vdom和ast都是树结构，只不过vdom相当于ast的格式化结构\n- 下面会讲到，vdom转化成真实dom，会调用createElm方法（此时vdom会多了一个el属性，其值是通过createElement或者createTextNode创建的真实dom节点）。\n- **vdom的模版变量值已经变成了真实的值，并不是ast的`测试{{a}}`,而是 `测试1`**\n\n下面我们来实现下：\n\n### render转vdom\n\n实际上我们的render执行的值就是vdom，只不过里面的`_c:元素 _v:文本 _s:插值表达式`三个方法尚未实现。render函数的作用：创建虚拟dom，\n\n```js\n1.修改src/init.js\n  import { mountComponent } from \"./lifecycle\";\n  Vue.prototype.$mount = function (el) {\n      ...\n      if (!options.render) {\n        ...\n      }\n      // 1.将render方法挂载到options上\n      const render = compileToFunction(template);\n      options.render = render;\n    }\n    // 2.挂载组件（主要用到_update和_render方法）\n    mountComponent(vm, el);\n  };\n\n2.新建src/lifecycle.js\n  import { patch } from \"./vdom/patch\";\n  // 3.创建挂载组件方法\n  export function mountComponent(vm, el) {\n    // 4.调用vm._render函数，生成虚拟dom \n    const vnode=vm._render()\n    console.log(vode,'vnode')\n    return vnode // return出去，后面转换真实dom用\n  }\n3.新建src/vdom/index.js\n  // 5.创建render混入函数\n  export function renderMixin(Vue) {\n    // vue原型增加_render函数生成虚拟dom\n    Vue.prototype._render = function () {\n      const vm = this;\n      // 取出之前放到options上的render方法\n      const { render } = vm.$options;\n      console.log(render, \"render\");\n      let vnode = render.call(vm); // 将vm指向当前实例，传给with函数,此时模版中的变量已经可以拿到值\n      return vnode;\n    };\n    // 标签转换成虚拟dom(_c('div',{},'hello','hello1'))\n    Vue.prototype._c = function () {\n      return createElement(...arguments);\n    };\n    // 变量(_s(变量))\n    Vue.prototype._s = function (val) {        \n      // 如果是对象，转换成字符串，如果是null或者undefined返回空,注意null==undefined为true，null===undefined为false，所以如果val为undefined也为''\n      return val == null ? \"\" : typeof val === \"object\" ? JSON.stringify(val) : val;\n    };\n    // 文本\n    Vue.prototype._v = function (text) {\n      return createTextVnode(text);\n    };\n  }\n  // 构造虚拟dom结构\n  function vnode(tag, data, key, children, text) {\n    return {\n      tag,\n      data,\n      key,\n      children,\n      text,\n    };\n  }\n  // 创建虚拟dom（之前_c的参数：tag,data,多个子节点）\n  function createElement(tag, data = {}, ...children) {\n    return vnode(tag, data, data.key, children);\n  }\n  // 创建文本虚拟dom\n  function createTextVnode(text) {\n    return vnode(undefined, undefined, undefined, undefined, text);\n  }\n4.修改src/index.js\nimport { initMixin } from \"./init\";\n// 6.将上面定义的vue原型方法混入\nimport { renderMixin } from \"./vdom/index\";\n...\ninitMixin(Vue)\nrenderMixin(Vue) // 添加render\nexport default Vue;\n\n```\n我们打印下，可以看到vnode\n<img src=\"images/vnode.jpg\" width=\"50%\"/>\n\n我们可以发现之前的模版都已经变成data上定义的值，但是我们前面讲的vdom上面最重要的属性还没有实现（图上的el属性有是因为用的包含转真实dom的代码运行的）。因为该属性和转\n真实dom是一起的，所以放到下面讲。\n\n### vdom转真实dom\n现在我们要把vdom更新到页面上\n```js\n1.修改src/init.js\n  import { mountComponent } from \"./lifecycle\";\n  Vue.prototype.$mount = function (el) {\n      ...\n      vm.$el = el; // 1.存储当前组件的根元素，用于后续的vdom转换真实dom操作\n      if (!options.render) {\n        ...\n      }\n      ...\n    }\n    ...\n  };\n2.修改src/lifecycle.js\n  import { patch } from \"./vdom/patch\";\n  // 挂载组件\n  export function mountComponent(vm, el) {\n    // render-->vnode-->真实dom\n    // 2.调用vm._render函数，生成虚拟dom 2.调用vm._update,将虚拟dom转换成真实dom\n    vm._update(vm._render());\n  }\n  // 3.新增生命周期方法混入\n  export function lifecycleMixin(Vue) {\n    // 4.增加更新方法\n    Vue.prototype._update = function (vnode) {\n      console.log(vnode, \"vnode\");\n      const vm = this;\n      // 5. 增加渲染真实dom方法patch\n      // 两个参数，第一个是老的dom节点，第二个是新的虚拟节点(用新的vnodes来生成新的dom，替换掉老的dom)，然后重新绑定到vm.$el上    \n      vm.$el = patch(vm.$el, vnode);\n    };\n  }\n3.修改src/index.js\n  import { initMixin } from \"./init\";\n  // 6.将上面定义的vue原型方法混入\n  import { lifecycleMixin } from \"./vdom/index\";\n  ...\n  initMixin(Vue)\n  renderMixin(Vue) // 添加render\n  lifecycleMixin(Vue) // 添加lifecycle\n  export default Vue;\n\n4.增加src/vdom/patch.js\n  // 7.定义patch方法\n  export function patch(oldnode, vnode) {\n    const oldElm = oldnode; // div id=\"app\"\n    const parentElm = oldElm.parentNode; // body\n    let el = createElm(vnode); // 创建真实dom\n    // insertBefore(a,b)表示将a插入到b前面， a.nextSibling表示a节点后面下一个兄弟节点\n    parentElm.insertBefore(el, oldElm.nextSibling); // 将创建的真实dom插入到body中（即app后面）\n    parentElm.removeChild(oldElm); // 删除原来的div即app\n    return el;\n  }\n  function createElm(vnode) {\n    let { tag, children, key, data, text } = vnode;\n    if (typeof tag === \"string\") {\n      // 元素\n      vnode.el = document.createElement(tag); // 创建元素\n      children.forEach((child) => {\n        vnode.el.appendChild(createElm(child)); // 递归渲染子节点\n      });\n    } else {\n      // 文本\n      vnode.el = document.createTextNode(text);\n    }  \n    return vnode.el;\n  }\n\n```\n至此，我们已经实现了初次渲染。但上面只是粗暴的删除app节点，插入新的节点，后面会讲到diff。我们可以看到页面，已经更新。\n\n<img src=\"images/rdom.jpg\" width=\"50%\"/>\n\n\n## 总结\n\nvue的大致渲染流程\n`数据初始化->模版编译->render->vdom->dom ->放到页面`\n\n\n\n\n\n\n","categories":["vue2源码"]},{"title":"3.数据劫持-数组","url":"/ypf-blog/2023/06/12/vue2源码/3.数据劫持-数组/","content":"## 劫持数组\n\n``` js\n// 1.修改src/observer/index.js\nclass Observer {\n  constructor(value) {\n    // 2.增加判断数组\n    if (Array.isArray(value)) {\n      this.walkArray(value);\n    } else {\n      this.walk(value);\n    }\n  }\n  walk(data) {\n    Object.keys(data).forEach((key) => {\n      defineReactive(data, key, data[key]);\n    });\n  }\n  // 3. 增加劫持数组方法\n  walkArray(data) {\n    const ArrayProto = Array.prototype;\n    const ArrayMethods = Object.create(ArrayProto); // 将数组原型的方法全部挂载到ArrayMethods的原型上\n    data.__proto__ = ArrayMethods; // 更改数组的原型指向新对象\n    // 数组中总共有7个方法可以改变自身\n    const methodsToPatch = [\n      \"push\",\n      \"pop\",\n      \"shift\",\n      \"unshift\",\n      \"reverse\",\n      \"sort\",\n      \"splice\",\n    ];\n    methodsToPatch.forEach((key) => {\n      ArrayMethods[key]=function(...args){\n        console.log(\"劫持数组\")\n        // 必须用ArrayProto[key],不能用ArrayMethods[key],因为使用ArrayMethods[key]相当于,自身调用自身,死循环\n        // this指向调用方,这里是[1, 2, 3]\n        const result=ArrayProto[key].apply(this,args) \n        return result\n      }\n    });\n  }\n}\n\n```\n我们修改index.html,增加`aa._data.b.push(4)`,此时会触发方法里打印的拦截数组\n\n## 注意\n\n### Object.defineProperty不能检测数组变动?\n\n我们测试下\n\n```js\n let test = [\"a\", \"b\", \"c\"];\n  Object.keys(test) // ['0', '1', '2']\n    .forEach((index) => {\n    let value = test[index];\n    Object.defineProperty(test, index, {\n      enumerable: true,\n      configurable: true,\n      get() {\n        console.log(\"获取值\");\n        return value;\n      },\n      set(newValue) {\n        console.log(\"更新值\")\n        value= newValue;\n      },\n    });\n  });\n  test[2]=4\n  console.log(test); \n```\n\n<img src=\"images/arr.jpg\" width=\"50%\"/>\n\n我们可以看到，Object.defineProperty可以检测数据遍历，只不过是通过数组下标劫持。\n\n那么，为什么原本通过索引实现监测的，Vue却选择了不支持呢？主要是考虑了性能问题，比如，我们平常用的数组往往数量量会很大：\n假如数组有1w个长度，为了实现数组索引劫持，需要对数组中每一项进行处理，但在实际开发很少会使用 arr[8888] = x修改某一项数据这种操作从而触发劫持，我们一般操作数组都是通过\npush、pop、splice等方法。所以，权衡性能和需求，Vue 源码中没有采用 defineProperty 对数组进行处理。\n\n### 数组本身含有对象\n\n前面我们定义的data中的数组都是基本类型，如果里面本身是对象，是不会被劫持的。\n```js\n   const aa= new Vue({\n      el: \"#app\",\n      data() {        \n        return {\n          d:[1,2,{a:1}]\n        };\n      },\n    });\n```\n上面代码，`{a:1}`是不会被劫持的，我们修改代码\n\n```js\nobserver/index\n...\nclass Observer {\n  constructor(value) {\n    if (Array.isArray(value)) {\n      this.walkArray(value);\n      // 4.新增数据对象劫持\n      this.walkArrayObj(value);\n    } else {\n      this.walk(value);\n    }\n  }\n  ...\n  // 数组本身含有对象，进行对象劫持\n  walkArrayObj(data) {\n    for(let i=0;i<data.length;i++){\n      observe(data[i])\n    }\n  }\n```\n\n### 数组push、unshift、splice对象,能劫持到吗?\n\n我们在index.html修改如下：\n`aa._data.b.push({a:1})` //往后追加\n`aa._data.b.unshift({a:1})` // 往前追加\n`aa._data.b.splice(0,1,{c:1})` // 将第一项替换为{c:1}\n\n上面三种很明显都不能劫持，我们修改代码\n\n```js\nobserver/index\n\n  walkArray(data) {\n    ...\n    // 数组中总共有7个方法可以改变自身\n    const methodsToPatch = [\n      \"push\",\n      \"pop\",\n      \"shift\",\n      \"unshift\",\n      \"reverse\",\n      \"sort\",\n      \"splice\",\n    ];\n    const that=this // 存储this,即Observer类，用于下面调用walkArrayObj方法，\n    methodsToPatch.forEach((key) => {\n      ArrayMethods[key]=function(...args){\n        console.log(\"劫持数组\")\n        // 5.打印调用push、unshift、splice方法传递过来的参数\n        console.log(args,'参数'); // push:[{a:1}] unshift:[{a:1}] splice:[0,1,{c:1}]\n        // 6.我们需要对参数进行劫持\n        let inserted;\n        switch (key) {\n          case 'push':\n          case 'unshift':\n            inserted=args\n            break;\n          case 'splice':\n            // slice(start,end)方法返回截取字符串的某个部分，包括start，不包括end，不改变原数组\n            // 此处等同于slice(2,0), 0可以省略，表示从第三个参数开始截取，即插入的数组\n            inserted=args.slice(2) \n          default:\n            break;\n        }\n        console.log(this,'this'); // aa._data.b\n        if (inserted) {\n          // 7.用上面存储的this，调用walkArrayObj方法，对插入的数组进行劫持， 因为这里面的this指向的是实例，即aa._data.b\n          that.walkArrayObj(inserted);\n        }\n        const result= ArrayProto[key].apply(this,args)\n        return result\n      }\n    });\n  }\n\n\n```\n\n至此，我们已经完成了数组的劫持。\n\n### 如何直接访问data上的属性？\n\n我们上面都是通过`aa._data`访问data上的数据，但实际vue，我们一般都是通过`aa.属性`直接访问data上的数据即在组件中是this.属性访问，很容易想到：\n**遍历vm._data进行绑定**\n下面我们来实现下，修改\n\n```js\nsrc/state.js\n\n\nfunction initData(vm) {\n  let data = vm.$options.data;\n  //   需要call, 否则 data(){ }中的this为window\n  data = vm._data = typeof data === \"function\" ? data.call(vm) : data;\n\n  // 8. 将data中的数据进行遍历,全部代理到vm实例上\n  for (let key in data) {\n    proxy(vm, \"_data\", key);\n  }\n\n  //   数据劫持\n  observe(data);\n}\n// 9. 增加proxy方法,用Object.defineProperty劫持， 必须的，如果直接vm[key]=data[key],只是在vm上加了属性，不会进行劫持\nfunction proxy(vm,source,key){\n  Object.defineProperty(vm,key,{\n    get(){\n      return vm[source][key]\n    },\n    set(newValue){\n      vm[source][key]=newValue\n    }\n  })\n}\n\n```\n\n我们然后打印下 **aa**,\n\n<img src=\"images/vm.jpg\" width=\"50%\"/>\n\n可以看到data的数据已经全部挂载到实例上，我们可以直接访问。\n\n但是如果我们使用`aa.msg='11'`或者 `aa._data.msg='aa'`新加一个属性msg，这种是不会劫持的，在vue中也不会，需要单独\n通过`$set`进行绑定。这个后面会讲\n\n\n\n\n","categories":["vue2源码"]},{"title":"Object.defineProperty","url":"/ypf-blog/2023/06/09/javascript/Object.defineProperty/","content":"\n在了解什么是`Object.defineProperty`前,我们先回忆下我们平常经常使用的 **对象**\n\n## 对象的赋值\n我们平常一般使用`obj.prop=value或者obj['prop']=value`对对象进行赋值或修改,如\n\n    let test={}\n    test.a=1\n    test[\"b\"]=2\n    console.log(test.a) //1\n    console.log(test.b) //2\n\n那么Object.defineProperty又和上面的对象赋值是什么关系呢?从字面(defineProperty)意思上就可以知道--定义属性,所以Object.defineProperty也是一种对对象属性修改或赋值的方式,只不过我们可以进行**更精确的控制**.\n\n## Object.defineProperty的定义\n`Object.defineProperty()`的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性,语法如下,有三个参数:\n\n    Object.defineProperty(obj, prop, descriptor)\n\n- obj:需要定义或修改属性的对象(必填)\n- prop:需要定义的属性名称(必填)\n- descriptor:要定义或修改的属性描述符,是一个对象.(必填)\n\n看到这,可能有的人不理解什么是属性描述符号?我们上面说的 **对对象属性进行更精确的控制,就是通过descriptor来操控的**.descriptor是一个对象,具有以下属性:\n\n<table>\n<thead>\n<tr>\n  <th width=\"120\">属性名</th>\n  <th>描述</th>\n  <th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>value</td> <td> 要定义的属性对应的值 </td><td> undefined</td></tr>\n<tr><td>writable</td><td>要定义的属性值是否可以被改变</td><td>false</td></tr>\n<tr><td>configurable</td><td>要定义的属性是否配置(配置指的是重新定义)，以及可否删除</td><td>false</td></tr>\n<tr><td>enumerable</td><td>要定义的属性是否会出现在对象的枚举属性中,如for in 或者 Object.keys()的遍历中</td><td>false</td></tr>\n<tr><td>get</td><td>要定义的属性的getter函数,当访问该属性时，会执行此函数</td><td>undefined</td></tr>\n<tr><td>set</td><td>要定义的属性的setter函数,当属性值被修改时，会调用此函数,此时该方法接受一个参数（也就是修改的新值）</td><td>undefined</td></tr>\n</tbody>\n</table>\n\n\n**注意:这里说的要定义的属性指的是通过Object.defineProperty传递prop参数进行定义的属性(才可以控制是否删除、改变、监听等),如果对象本来就存在一些属性,但没有经过Object.defineProperty进行重新定义,是不受控制的,和我们最开始讲到的我们平常使用对象的方式,可以随便改变、删除,不能监听**\n下面我们将分别对这些属性描述符进行举例说明:\n\n###  value\n我们要在对象上定义属性,obj、prop必填就不用说了,descriptor也是必填的,否则会报错\n\n    let test={}\n    Object.defineProperty(test, \"a\")\n    console.log(test);\n \n<img src=\"images/1894758-c497eb23fafb7e14.png\" width=\"50%\"/>\n\n从报错信息我们可知,属性描述符必须是个对象,所以我们修改下就可以了\n\n    Object.defineProperty(test, \"a\",{})\n    console.log(test); // {a:undefined}\n    test.a=1\n    console.log(`修改后${test}`) // {a:undefined}\n\n此时我们已经使用Object.defineProperty成功定义了一个属性,只不过没有值罢了.\n但我们修改,打印出来发现值仍为undefined.这个后面会说,接下来我们先进行使用 **value**进行赋值操作.\n\n      Object.defineProperty(test, \"a\",{\n          value:1\n      })\n      console.log(test); // {a:1}\n      test.a=2\n      console.log(`修改后${test}`) // {a:1}\n\n###  writable\n我们可以看见,test对象已经有一个属性a,并且值为1.但是和上面一样,我们仍没有修改成功.接下来,我们使用 **writable**进行修改\n\n      Object.defineProperty(test, \"a\",{\n          value:1,\n          writable:true\n      })\n      console.log(test); // {a:1}\n      test.a=2\n      console.log(`修改后${test}`) // {a:2}\n\n###  configurable\n\n我们可以看见,属性值已经被修改成功.接下来我们来看 **configurable**属性.\n\n    Object.defineProperty(test, \"a\",{\n          value:1,\n          writable:true\n    })\n    delete test.a\n    console.log(test) //{a:1}\n\n我们可以看见,此时我们无法删除掉属性a,我们修改代码,此时即可删除成功.\n\n    Object.defineProperty(test, \"a\",{\n          value:1,\n          writable:true,\n          configurable:true\n\n    })\n    delete test.a\n    console.log(test) //{}\n\n我们上面说了configurable除下控制是否可以删除,还可以用来控制是否可以重新定义.我们来修改代码\n\n    Object.defineProperty(test, \"a\",{\n          value:1,\n    })\n    //重新定义\n    Object.defineProperty(test, \"a\",{\n          value:2,\n    })\n\n发现报错,不能重新定义:\n\n<img src=\"images/1894758-aa17f88dc28b1e9e.png\" width=\"50%\"/>\n\n我们增加`writable=true`,即可重新定义\n\n    Object.defineProperty(test, \"a\",{\n          value:1,\n          writable:true,\n    })\n    //重新定义\n    Object.defineProperty(test, \"a\",{\n          value:2,\n    })\n    console.log(test) //{a:2}\n\n或者设置`configurable=true`\n\n     Object.defineProperty(test, \"a\",{\n          value:1,\n          writable:false, //也可以不写,默认false\n          configurable:true\n    })\n    //重新定义\n    Object.defineProperty(test, \"a\",{\n          value:2,\n    })\n    console.log(test) //{a:2}\n\n###  enumerable\n\n**1.Object.keys,返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).**\n\n    Object.defineProperty(test, \"a\",{\n          value:1,\n    })\n    console.log(Object.keys(test)); //[]\n**2.for...in循环遍历对象自身的和继承的可枚举属性(不含Symbol属性)**\n\n     for(let i in test){\n        console.log(i);\n    } //不会输出,因为无法遍历,此时test相当于{}对象\n\n**3.Object.values(),返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)的值**\n\n     console.log(Object.values(test)); //[]\n\n**4.Object.entries(),返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)以及对应值组成一个数组**\n\n     console.log(Object.entries(test)); //[]\n\n\n**5.Object.getOwnPropertyNames(),返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性).**\n\n    console.log(Object.getOwnPropertyNames(test)); //[\"a\"]\n\n**6.Reflect.ownKeys(),返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举.**\n\n    console.log(Reflect.ownKeys(test));[\"a\"]\n\n我们可以看见,前3种无法获取对象的属性,我们设置`enumerable=true`,即可获取,代码就不贴了.\n\n###  get\n\n    Object.defineProperty(test, \"a\",{\n        // value:1, //get和value不能同时使用\n        get(){            \n            return 1\n        }\n    })\n    console.log(test.a) //1\n    console.log(test) //{}\n\n我们从打印结果可以看出\n- 当我们打印test.a时候,get函数会执行,此时a的值就是return的值;但我们直接打印test是不会执行get函数的.\n- 如果我们把value注释打开,会发现报错\n- get、set函数和value不能同时使用,都会报如下错误\n- 对象会绑定get方法,如果用value定义,不用get, 对象不会绑定get方法.\n\n<img src=\"images/1894758-e66a28c54ef126dc.png\" width=\"50%\"/>\n<img src=\"images/1.jpg\" width=\"50%\"/>\n\n###  set\n\n    Object.defineProperty(test, \"a\",{\n        get(){            \n            return 1\n        },\n        set(newValue){\n            console.log(newValue) //2\n        }\n    })\n    console.log(test.a) //1\n    test.a=2\n    console.log(test.a) //1\n\n上面例子中,我们对属性a重新赋值为2,set函数可以接收到最新的值为2,但是get函数返回永远是1,所以test.a的值永远是1,我们更改下代码:\n\n    let num=1\n     Object.defineProperty(test, \"a\",{\n        get(){            \n            return num\n        },\n        set(newValue){\n            console.log(newValue) //2\n            num=newValue\n        }\n    })\n    console.log(test.a) //1\n    test.a=2\n    console.log(test.a) //2\n\n## 不同写法对比\n\n    let test={};\n    test.a=1\n    等价于\n    Object.defineProperty(test, \"a\",{\n        value:1,\n        configurable:true,\n        writable:true,\n        enumerable:true\n    })\n\n---\n\n    Object.defineProperty(test, \"a\",{\n        value:1,\n    })\n    等价于\n     Object.defineProperty(test, \"a\",{\n        value:1,\n        configurable:false,\n        writable:false,\n        enumerable:false\n    })\n\n## 拓展\n\n###  创建对象常量\n\n结合writable: false 和 configurable: false 就可以创建一个真正的常量属性（不可修改，不可重新定义或者删除）,**但可以添加新属性**\n\n    Object.defineProperty(test, \"a\",{\n        value:1,\n        configurable:false,\n        writable:false\n    })\n    delete test.a;\n    test.a=2\n    console.log(test);  //{a:1}\n    test.b=2\n    console.log(test); //{a:1,b:2}\n    Object.defineProperty(test, \"a\",{\n        value:2,\n    }) //报错 Cannot redefine property\n\n###  禁止扩展 `Object.preventExtensions`\n\n如果你想禁止一个对象添加新属性并且保留已有属性，就可以使用Object.preventExtensions()\n\n    let test={a:1}\n    Object.preventExtensions(test)\n    test.b=2\n    test.a=2\n    console.log(test); //{a:2}\n    Object.defineProperty(test, \"a\",{\n        value:3,\n    })\n    console.log(test);  //{a:3}\n    Object.defineProperty(test, \"b\",{\n        value:2,\n    }) //报错:Uncaught TypeError: Cannot define property b, object is not extensible\n\n我们可以发现,通过preventExtensions,我们无法再新增(拓展)属性,只能更改原来存在的属性.\n\n###  密封对象 `Object.seal`\n\nObject.seal()方法用于密封一个对象，这个方法实际上会在一个现有对象上调用object.preventExtensions()并把所有现有属性标记为configurable:false.即将对象设置为不可扩展，同时将对象的所有自有属性都设置为不可配置（包括Symbol值的属性）。也就是说，不能给对象添加新的属性和方法，也不能删除现有的属性和方法、不能修改现有属性和方法的配置。但如果对象的属性和方法是可写的，那该属性和方法仍然可以修改。\n\n        let test={a:1}\n        Object.seal(test)\n        test.a=2\n        test.b=3\n        console.log(test); //{a:2}\n        delete test.a\n        console.log(test); //{a:2}\n        Object.defineProperty(test, \"a\",{\n                value:3,\n        })\n        console.log(test); //{a:3}\n        Object.defineProperty(test, \"b\",{\n                value:3,\n        }) //报错:Uncaught TypeError: Cannot define property b, object is not extensible\n\n###  冻结对象 `Object.freeze`\n\nObject.freeze()会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(),并把所有现有属性标记为writable: false,这样就无法修改它们的值。\n\n    let test={a:1}\n    Object.freeze(test)\n    test.a=2\n    test.b=3\n    console.log(test); //{a:1}\n    delete test.a\n    console.log(test); //{a:1}\n    Object.defineProperty(test, \"b\",{\n            value:3,\n    })\n    console.log(test); //报错:Uncaught TypeError: Cannot define property b, object is not extensible\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["javascript"]},{"title":"1.rollup搭建环境","url":"/ypf-blog/2023/06/09/vue2源码/1.rollup搭建环境/","content":"## 搭建目录结构\n\n1. 新建vue2源码文件夹, 然后`pnpm init`, 增加`type:module`,因为第三步使用esmodule导出\n2. `pnpm install rollup -D`\n3. 根目录新建src文件夹,并在该文件夹创建index.js\n\n```js\nfunction Vue() {\n    console.log(213)\n}\nexport default Vue;\n```\n4. 根目录新建dist空文件夹\n5. 根目录增加rollup.config.js配置文件\n  \n```js\nexport default {\n  input: \"src/index.js\",\n  output: {\n    file: \"dist/vue.js\",\n    format: \"umd\",\n    name: \"Vue\", // window会绑定Vue属性\n    sourcemap: true,\n  },\n};\n```\n\n6. 修改package.json启动命令\n\n``` js\n  \"scripts\": {\n    \"dev\": \"rollup --config -w\"\n  },\n```\n\n其中 :\n`--config表示使用配置文件,默认为rollup.config.js`\n`-w 表示监听配置文件input指向路径的变动`,加上这个配置, 我们修改src/index.js,dist/vue.js会热更新.\n\n至此我们的目录结构已经搭建完毕.\n<img src=\"images/1.jpg\" width=\"50%\"/>\n\n## 测试\n\n1. 我们上面已经搭建好目录结构,通过`npm run dev`,可以看到dist/vue.js生成了,现在我们在根目录新建index.html,引用vue.js\n   \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <script src=\"./dist/vue.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n  </body>\n  <script>\n    console.log(Vue);\n    new Vue({\n      el: \"#app\",\n      data() {\n        return {};\n      },\n    });\n  </script>\n</html>\n```\n\n2. 我们直接打开index.html,可以看到效果.\n\n<img src=\"images/2.jpg\" width=\"50%\"/>\n\n## 插件\n\n### rollup-plugin-serve\n\n我们上面是直接打开的index.html, 一般我们开发都是服务下运行,我们安装[rollup-plugin-serve](https://github.com/thgh/rollup-plugin-serve)开服务.\n\n` pnpm install rollup-plugin-serve -D`\n\n修改 rollup.config.js文件\n\n```js\nimport serve from \"rollup-plugin-serve\";\nexport default {\n  input: \"src/index.js\",\n  output: {\n    file: \"dist/vue.js\",\n    format: \"umd\",\n    name: \"Vue\",\n    sourcemap: true,\n  },\n  plugins: [\n    serve({\n      openPage: \"index.html\",\n      contentBase: \"\", // 为空表示根目录\n    }),\n  ],\n};\n\n```\n然后`npm run dev`就会通过服务运行.\n\n或者不用插件,用vscode的server插件运行页面也可以.\n","categories":["vue2源码"]},{"title":"数据类型和包装对象","url":"/ypf-blog/2023/05/30/javascript/数据类型和包装对象/","content":"# 数据类型分类\n\nECMAScript标准定义了7种数据类型，主要分为两大类`基本类型`和`引用类型`。其中：\n\n## 基本类型\n\n基本类型又称 **值类型 或者 原始类型**，共有`六`种 。包括：\n\n- 字符串类型（String）\n- 数字类型（Number）\n- 布尔类型（Boolean）\n- 对空类型（Null）\n- 未定义类型（Undefined）\n- 符号类型（Symbol）\n\n引用类型，只有**一**种。包括：\n\n## 引用类型\n\n- 对象类型（Object）\n\n## 对象拓展子类型\n\n另外，基于Object类型，JS还实现了其他常用的对象子类型（即不同类型的对象）。我们常见的如：\n\n- Object\n- Array\n- Function\n- String（注：这里是构造函数，和上面的基本类型不是一种）\n- Boolean（注：这里是构造函数，和上面的基本类型不是一种）\n- Number（注：这里是构造函数，和上面的基本类型不是一种）\n- Date\n- RegExp\n- Error\n- ...\n\n所以我们可以说，Object类是所有子类的父类.\n\n# 基本包装类型\n\n上面我们已经介绍了基本数据类型和引用类型，那`基本包装类型`又是什么？\n\n举个栗子先：\n``` js\n    var str = 'hello'; //String 基本类型\n    var s2 = str.charAt(0); //调用charAt方法（用于返回指定位置的字符）。\n    console.log(s2); // h\n```\n\n上面的str是一个基本类型，又不是对象，但是它却能调用出一个 charAt() 的方法？\n\n原因是：在基本类型中，有三个比较特殊的存在就是：String Number Boolean，在我们对这个三个类型执行访问属性和方法的操作时候，JS引擎会执行下面操作：\n\n1. 创建一个对应类型的实例；\n2. 在实例上调用指定的方法；\n3. 销毁这个实例。\n\n所以上面的代码实际在执行过程中，是这样执行的：\n\n``` js\n    var str = 'hello'; //String 基本类型\n    var s2 = str.charAt(0); //在执行到这一句的时候，发现基本类型要调用方法，此时后台会自动完成以下括号中的三个动作 ：\n    （ \n        var strObject = new String('hello'); // 1.因为str是String类型，所以创建一个String类型的实例，这个生成的实例strObject就是我们所说的`基本包装类型`\n        var s2 = strObject.chaAt(0); // 2. 然后通过实例来调用方法，并且返回结果给s2 \n        strObject = null;  //    3. 销毁这个实例 \n     ） \n    console.log(s2); // h\n``` \n\n注意，上述代码是JS引擎自动执行的，你无法访问strObject对象，它只存在于代码的执行瞬间，然后立即销毁，所以我们无法再运行时给基本类型添加属性和方法，除非直接通过new显示调用基本包装类型创建对象。\n\n由此我们可以知道，引用类型和基本包装对象的区别在于：**生存期**\n引用类型所创建的对象，在执行的期间一直在内存中，而基本包装对象只是存在了**一瞬间**。\n\n**举个栗子**\n\n``` js\n    var str = 'hello'; //String 基本类型\n    str.number=0\n    （ \n        var strObject = new String('hello'); // 1. 创建实例\n        strObject.number=0 // 2. 赋值\n        strObject = null;  //    3. 销毁\n     ） \n    console.log(str.number); // number类型存在于strObject上，str并没有number属性，所以为undefined\n\n```\n那么我们怎么才能给基本类型添加方法或者属性呢？**答案是在构造函数的原型下面添加**\n``` js\n    var str = 'hello';\n    String.prototype.number= 0\n    console.log(str.number) //0\n```\n\n## 创建一个包装类型\n\n``` js\n console.log(new Object(1))\n // 或者\n console.log(new Number(1))\n\n```\n<img src=\"images/1.jpg\" width=\"50%\"/>\n\n","categories":["javascript"]},{"title":"傻傻分不清楚-call、apply、bind","url":"/ypf-blog/2023/05/26/javascript/傻傻分不清楚-call、apply、bind/","content":"\n# call、apply、bind作用\n在JavaScript中，call、apply和bind是Function对象自带的三个方法。这三个函数的存在意义是什么？答案就是**改变函数运行时的this指向**。下面我们通过实际例子来介绍这三个方法的使用和区别。\n\n# call\n\n>语法：fn.call(thisArg,arg1,arg2,...)\n\nthisArg:函数fn运行时，该函数中的this绑定到thisArg上。\narg1,arg2,...：函数fn所需的参数,是个list\n\n**我们直接看例子：**\n\n    var a ={\n        name : \"test\",\n        fn : function (a,b) {\n            console.log(this.name, a + b)\n        }\n    }\n    var b={name:'test1'}\n    a.fn(1,2) //test 3\n    a.fn.call(b,1,2) //test1 3\n\n执行 `a.fn(1,2)`，fn中的this指向a，所以输出 `test 3`\n执行 `a.fn.call(b,1,2)`，通过call改变了fn中的this指向为b，所以输出 `test1 3`\n\n**注意事项：**\n1. thisArg不传，或者传null，undefined， 函数中的this指向window对象\n2. thisArg为原始值（数字，字符串，布尔值），函数中this指向该原始值的自动包装对象（如 String、Number、Boolean）\n3. thisArg为一个对象，函数中的this指向这个对象\n4. thisArg为一个函数名，函数中的this指向该函数\n5. 前四点是默认在非严格模式下，如果在严格模式下，会略有不同。\n\n\n**我们直接看例子：**\n\n    function a(params) {\n        console.log(this);\n    }\n    function b() {}\n    var obj = {\n        name: '这是一个屌丝'\n    };\n\n    //                  正常模式下              严格模式下\n    a.call();           //window               undefined\n    a.call(null);       //window               null\n    a.call(undefined);  //window               undefined\n    a.call(1);          //Number{1}            1\n    a.call('1');         //String{'1'}           '1'\n    a.call(true);       //Boolean{true}        true\n    a.call(b);          //function b(){}       function b(){}\n    a.call(obj);        //Object               Object\n\n# apply\n\n>语法：fn.apply(thisArg,[arg1,arg2,...])或者  fn.apply(thisArg,{0:arg1,1:arg2,...,lenght:总个数})\n\nthisArg:函数fn运行时，该函数中的this绑定到thisArg上。\n[arg1,arg2,...]或者形如{0:arg1,1:arg2,...,lenght:总个数}：函数fn所需的参数,是个数组或者类数组,call函数会自动将数组或类数组的每个值分开成列表然后给函函数fn\n\n例子和上面一样，只需要把`call`换成`apply`即可。其他都一样，包括上面call的几点注意事项即不传或者传null等。\n\n# bind\n\n>语法：fn.bind(thisArg,arg1,arg2,...)()\n\nthisArg:函数fn运行时，该函数中的this绑定到thisArg上。\narg1,arg2,...：函数fn所需的参数,是个list\n\n**bind其实和call类似,包括上面call的几点注意事项即不传或者传null等，只不过后面多个`（）`。我们直接看例子**\n\n     var a = {\n        name: \"test\",\n        fn: function (a, b) {\n            console.log(this.name, a + b)\n        }\n    }\n    var b = {\n        name: 'test1'\n    }\n    a.fn.bind(b, 1, 2)\n\n运行上面代码，我们发现控制台并没有输出，所以我们可以看出bind 是创建一个新的函数，我们**必须要手动去调用**。我们更改代码：\n\n    var a = {\n        name: \"test\",\n        fn: function (a, b) {\n            console.log(this.name, a + b)\n        }\n    }\n    var b = {\n        name: 'test1'\n    }\n    a.fn.bind(b, 1, 2) //test1 3\n\n上面我们手动调用，发现正确输出结果。\n\n# call apply bind三者区别总结\n\n1.call和apply用法一样，唯一的区别是call的参数为列表，apply参数为数组\n2.bind和call用法一样，唯一的区别是call会自执行函数，bind需要手动调用函数\n\n# 应用\n\n## 继承\n\n    var Person = function (name, age) {\n        this.name = name;\n        this.age = age;\n    };\n    var Girl = function (name) {\n        Person.call(this, name);\n    };\n    var Boy = function (name, age) {\n        Person.apply(this, arguments);\n    }\n    var Boy1 = function (name, age) {\n        Person.bind(this, name)();\n    }\n    var g = new Girl('xiaohong');\n    var b = new Boy('xiaoming', 100);\n    var b1 = new Boy1('xiaowang', 100);\n    console.log(g); //{name: \"xiaohong\", age: undefined}\n    console.log(b); //{name: \"xiaoming\", age: 100}\n    console.log(b1); //{name: \"xiaowang\", age: undefined}\n\n上面例子，我们定义了四个构造函数，通过new实例化调用Girl、Boy、Boy1这三个构造函数，在这三个构造函数中分别使用call、apply、bind继承Person的属性。\n我们来看下它到底是怎么继承的?\n\n     var Person = function (name, age) {\n          this.name = name;\n          this.age = age;\n    };\n    var Girl = function (name) {\n        Person.call(this, name);\n    };  \n    var g = new Girl('xiaohong');\n\n1.先执行`g=new Girl('xiaohong');` 此时执行Girl函数,并执行函数里面的代码` Person.call(this, name);`\n2.` Person.call(this, name);`中的this指向调用方,即实例g. 通过call方法后,会调用person函数,本来person的this指向被调用方,此时person函数的this被改变成实例g\n3.所以就变成`g.name=name; g.age=age`\n4.所以通过girl实例化出的g相当于继承了person里面的属性\n\n\n## 求数组中的最大和最小值\n\n    var ary = [0, 1, 1, 3, 4, 5, 6, 7];\n    console.log(Math.max(0, 1, 1, 3, 4, 5, 6, 7)); //7\n    console.log(Math.min(0, 1, 1, 3, 4, 5, 6, 7)); //0\n    var max = Math.max.apply(null, ary);\n    var min = Math.min.apply(null, ary);\n    console.log(max,min); //7 0\n\n上面例子可以看出，正常情况下，`Math.max和Math.min`的参数为必须为列表，上面只用`0-7`八个数字还好，但如果数据很多，都放到参数会比较麻烦。\n\n所以我们借助apply可以将数组转换成列表的功能，这样我们就可以直接传递一个变量了。第一个参数这里使用`null`，实际换成其他都可以（如随便一个字符串、数字、对象等），这里主要使用的是call函数的 数组转列表功能。\n\n## 类数组转数组\n\n    Array.prototype.slice.call(arrayLike) 或者 Array.prototype.slice.apply(arrayLike)\n\n具体可以戳这[javascript中的伪（类）数组和数组]()\n\n## 数组追加\n\n在js中我们往数组追加元素，一般使用push方法。\n\n      var arr1 = [1,2,3];\n      var arr2 = [4,5,6];\n      arr1.push(4,5,6)\n      console.log(arr1) //[1,2,3,4,5,6]\n\n我们也可以使用apply方法：\n\n    var arr1 = [1,2,3];\n    var arr2 = [4,5,6];\n    [].push.apply(arr1,arr2)\n    console.log(arr1) //[1,2,3,4,5,6]\n\n上面代码意思表示：[]调用push方法，然后通过call将push方法中的this指向arr1，并将arr2转变成参数列表。这样就达到合并的目的。\n \n## 判断变量类型\n\n    Object.prototype.toString.call/apply(object);\n\n具体详见另一篇文章[toString()和Object.prototype.toString.call()](https://www.jianshu.com/p/1009ee38e5f1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["javascript","傻傻分不清楚"]},{"title":"傻傻分不清楚-Object()、{}、new Object()、Object.create()","url":"/ypf-blog/2023/05/26/javascript/傻傻分不清楚-Object()、{}、new Object()、Object.create()/","content":"\n## {}、Object()、new Object()\n我们平常工作中一般用`let obj={}`对象字面量的方法来创建对象.但其实创建对象还有一些其它方式,如:`Object()` `new Object()` `Object.create()`.下面我们就来具体介绍这些方法的区别.\n\n    let test={a:1}\n    let test1=Object({a:1}) //不传就是空对象{}\n    let test2=new Object({a:1}) //不传就是空对象{}\n\n我们打印三个结果\n<img src=\"images/1894758-ae340c8057bbb518.png\" width=\"50%\" height=\"50%\" />\n\n 从图中我们可以看出,三个结果一模一样,并且原型都继承了`Object.prototype`,我们总结下\n\n1. 通过字面量的方式和函数的方式都可以用来创建对象\n2. 当以非构造函数形式被调用时(也就是当成函数执行时)，Object 的行为等同于 new Object()。参考mdn官网[Object](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)一节. 简单来说, new Object()和Object()是一样的,**new可以省略**\n\n\n注意,上面我们调用Object时候传递的参数是个对象,现在我们传递其它类型的参数看看\n\n    let test3=new Object(1)\n    let test4=new Object(\"1\")\n    let test5=new Object([1])\n    let test6=new Object(true)\n\n打印4个结果\n\n<img src=\"images/1894758-a36b9ce1972ccaac.png\" width=\"50%\" height=\"50%\" />\n\n<img src=\"images/1894758-7d4e3c879299a48f.png\" width=\"50%\" height=\"50%\" />\n\n我们发现,Object构造函数会根据传入的值的类型返回相应的基本包装类型的实例(对象包装器),我们也可以给其进行操作\n\n    let test3=new Object(1)\n    test3.a=2\n    console.log(test3 instanceof Number);//true\n    console.log(test3); //实例,引用类型\n    let a = Number(1);//这是转型函数，其它的还有String()、 Boolean()、 Array()\n    a.number=2 //不能操作,属于基本数据类型\n    console.log(a); //所以结果为1\n\n打印出的test3结果如下\n\n<img src=\"images/1894758-dc3c8c310cec59fc.png\" width=\"50%\" height=\"50%\" />\n\n注意:\n上面我们说了对象字面量、构造函数创建对象,下面我们单独来说下`Object.create()`,因为它比较特别.\n\n## Object.create()\n\n[mdn定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)   : Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n\n语法:\n\n    Object.create(proto，propertiesObject)\n\n- proto:新创建对象的原型对象,必填\n- propertiesObject:可选.参数和 [Object.defineProperties()](https://www.jianshu.com/p/2aa5a4ce0883) 的descriptor属性描述符一样.\n\n返回结果:是一个新对象，带着指定的原型对象和属性\n\n### 参数proto\n如果不理解,我们直接看例子\n\n    var test1 = Object.create();\n    console.log(test1);\n\n报错:\n\n<img src=\"images/1894758-7fb44ede963b212a.png\" width=\"50%\" height=\"50%\" />\n\n提示参数必须只能为object或者null,大家可以试下,传递unedfined、数字啥的都会报同样的错\n继续更改代码,\n\n    let test1 = Object.create(null);\n    let test2={}\n    console.log(1,test1); //{} //无原型\n    console.log(2,test2); //{} 注意:虽然都为空对象,但是test2有原型\n    test1.a=1\n    console.log(3,test1); //{a:1}\n    console.log(4,test1.a); //1\n    console.log(test1 instanceof Object); //false\n    console.log(test2 instanceof Object); //true\n\n打印结果\n\n<img src=\"images/1894758-f08032029418d36c.png\" width=\"50%\" height=\"50%\" />\n\n我们发现,如果传递null,生成的对象,原型是空的,在该对象上没有继承 Object.prototype 原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法\n\n我们现在更改传递参数,\n\n    let test1 = Object.create({a:1});\n    let test2={a:1}\n    console.log(1,test1); //{} \n    console.log(2,test2); //{a:1}\n    console.log(test1 instanceof Object); //true\n    console.log(test1.a); //1\n    console.log(test2 instanceof Object); //true\n    console.log(test2.a); //1\n\n打印结果如下:\n\n<img src=\"images/1894758-a33cf49a4f5bceb5.png\" width=\"50%\" height=\"50%\" />\n\n我们发现,我们**传递的对象被赋予到新生成对象的原型上**.现在在回过头来看定义,大家应该就能理解了.所以\n\n    let test = {};\n    // 以字面量方式创建的空对象就相当于:\n    let test = Object.create(Object.prototype);\n    console.log(test instanceof Object); //true\n\n\n接下来,我们看第二个参数\n\n### propertiesObject\n\n我们上面讲了,propertiesObject和Object.defineProperties的属性描述符一致,现在举个例子:\n\n    let test1 = Object.create({a:1},{\n        // a会成为所创建对象test1的属性\n        b:{\n            value:1,\n        }\n    });\n    console.log(test1);\n\n<img src=\"images/1894758-cd9697002b7c11a3.png\" width=\"50%\" height=\"50%\" />\n\n我们更改代码\n\n     let test1 = Object.create({a:1},{\n        // a会成为所创建对象test1的属性\n        b:{\n            value:1,\n        }\n    });\n    test1.a=2\n    test1.b=2\n    console.log(test1)\n\n<img src=\"images/1894758-681577e3a241e14a.png\" width=\"50%\" height=\"50%\" />\n\n我们发现,\n- 我们无法更改b的值,因为默认writable为false,改为true即可\n- 我们更改a的值,但是test1对象上面没有a属性,实际a属性在原型上,所以相当于新增,所以我们如果更改,`test1.__proto__.a=2`即可\n- propertiesObject中定义的对象属性才会适用于属性描述符如writable等,原型上的属性(即第一个参数里的属性)不适用,所以我们可以进行读写操作\n\n        let test1 = Object.create({a:1},{\n            // a会成为所创建对象test1的属性\n            b:{\n                value:1,\n                writable:true\n                //其它参数和Object.defineProperties一样,就不一一介绍了\n            }\n        });\n        test1.b=2\n        console.log(test1)\n\n<img src=\"images/1894758-eed22f0dd71543a5.png\" width=\"50%\" height=\"50%\" />\n\n  ","categories":["javascript","傻傻分不清楚"]},{"title":"如何区分函数是否被当构造函数调用","url":"/ypf-blog/2023/04/12/每日一练/如何区分函数是否被当构造函数调用/","content":"\n我们知道定义一个函数，其调用有两种方式\n``` js\ntest() // 当成函数\nnew test() // 当成构造函数\n```\n\n那么我们在定义函数的时候，如何区分出函数和构造函数呢？\n- 一般我们用函数名大些就表示构造函数，小写表示函数。但这仅仅是规范，我们在开发过程中仍有可能把大些当成函数用。\n- 实际中，一般用es6的Class来创建构造函数\n\n如果我们不用es6，如何限制呢？\n\n## new.target\n\n```js\nfunction fn(){\n  if (new.target) {\n    throw \"not called with new\";\n  }\n  console.log(1); \n}\nfn(); // 1\nnew fn(); // not called with new 并阻断下面代码打印1\n```\n\n所以，如果使用`new fn()`调用，函数中是可以访问到`new.target`的。\n我们打印下new.target看是什么？\n\n```js\nfunction fn(){\n  console.log(new.target); \n}\nfn(); \nnew fn(); \n```\n<img src=\"images/target.jpg\" width=\"50%\" height=\"50%\" />\n\n\n## constructor\n\n```js\nfunction fn(){\n  if (this.constructor === fn) {\n    throw \"not called with new\";\n  }\n  console.log(1); \n}\n```\n所以我们也可以通过`this.constructor`来进行判断。\n我们打印下this.constructor 看是什么？\n\n```js\nfunction fn(){\n  console.log(this.constructor); \n}\nfn(); \nnew fn(); \n```\n\n<img src=\"images/constructor.jpg\" width=\"50%\" height=\"50%\" />\n\n## 注意箭头函数不能new\n\n```js\nconst fn=()=>{\n}\nnew fn() \n```\n\n运行直接报错\n<img src=\"images/arrow-fn.jpg\" width=\"50%\" height=\"50%\" />\n\n\n\n\n\n\n\n","categories":["每日一练"]},{"title":"判断对象是否含有某个属性","url":"/ypf-blog/2023/04/12/每日一练/判断对象是否含有某个属性/","content":"\n举个🌰:\n\n``` js\n   const test = {\n      a: 1,\n      b: 2,\n      c: undefined,\n  };\n  Object.defineProperty(test, \"d\", {\n    value: 4,\n    enumerable: false, // 是否可以通过遍历循环访问属性\n  });\n  console.log(test);\n```\n上面我们先打印test看下，\n\n<img src=\"images/test.jpg\" width=\"50%\" height=\"50%\" />\n\n可能有些人在工作中直接用 `test[key]!==undefined`来判断，这样的问题显而易见，如果本身存在值为undefined的key就不行了。\n\n## 原型链的hasOwnProperty\n\n``` js\n    console.log(test.hasOwnProperty(\"c\")); // true\n    console.log(test.hasOwnProperty(\"d\")); // true\n    console.log(test.hasOwnProperty(\"toString\")); // false\n```\n**总结**\n- `hasOwnProperty`只能判断自身属性以及不能遍历的属性，不包含原型链上的属性\n- 如果test本身就有个同名的hasOwnProperty属性，那么就不能用这种方法了。具体介绍看下面\n\n## Object.prototype.hasOwnProperty.call\n\n上面我们通过对象的hasOwnProperty属性来判断test，但是如果test本身就有个同名的hasOwnProperty属性，那么就不能用这种方法了。所有我们直接访问原型链的方法来判断就可也避免这个问题。\n\n``` js\n  console.log(Object.prototype.hasOwnProperty.call(test, 'c')); // true\n  console.log(Object.prototype.hasOwnProperty.call(test, 'd')); // true\n  console.log(Object.prototype.hasOwnProperty.call(test, 'toString')); // false\n```\n\n## Object.keys().includes()\n\n``` js\n  console.log(Object.keys(test).includes(\"c\")); // true\n  console.log(Object.keys(test).includes(\"d\")); // false\n  console.log(Object.keys(test).includes(\"toString\")); // false\n```\n**总结**\n- 只能判断自身属性, 不包含不能遍历的属性，不包含原型链上的属性\n\n## key in obj\n\n``` js\n  console.log('c' in test) // true\n  console.log('d' in test) // true\n  console.log('toString' in test) // true\n```\n**总结**\n- 可以判断所有属性\n\n\n## Reflect.has(obj,key)\n``` js\n    console.log(Reflect.has(test,'c')) // true\n    console.log(Reflect.has(test,'d')) // true\n    console.log(Reflect.has(test,'toString')) // true\n```\n\n**总结**\n- 可以判断所有属性\n- Reflect对象与Proxy对象一样，是 ES6 为了操作对象而提供的新 API。Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。\n\n\n## 总结\n\n综合上面几种方法，所以我们在判断的时候，根据实际情况而定。如需不需要可枚举、只需要自身、需要所有。","categories":["每日一练"]},{"title":"傻傻分不清楚-preload、prefetch、dns-prefetch、defer和async","url":"/ypf-blog/2023/03/01/javascript/傻傻分不清楚-preload、prefetch、dns-prefetch、defer和async/","content":"\n## 前言\n我们工作中会经常用到 `<link rel=\"stylesheet\" href=\"https://xxx/ooo.css\" type=\"text/css\">` 这样的代码，我们都知道这个用来加载css，后面我们发现vue/react打包后的代码，出现类似下面这种代码：\n``` html\n  <link href=static/js/chunk-ece2389c.3afe4d18.js rel=prefetch>\n  <link href=static/css/app.0a1cd694.css rel=preload as=style>\n  <link href=static/js/runtime.63bac84c.js rel=preload as=script>\n```\n\n我们看上面，发现原来link还可以加载js，并且rel值可以为`prefetch、preload`，这是什么意思呢？\n\n> preload和prefetch是现代浏览器对<link>标签新增的rel值，用来加快页面资源（通常是css和js）的加载速度，改善用户体验。\n\n- 无论preload还是prefetch，都是**只下载资源，不执行资源**.\n- <link>在常用用法里无法加载js，只能加载css，但是如果使用prefetch和preload，就可以加载js。\n\n兼容性：\n\n<img src=\"images/prefetch.jpg\" width=\"50%\"/>\n<img src=\"images/preload.jpg\" width=\"50%\"/>\n\n我们上面已经对preload和prefetch有了大致了解，现在我们详细解释下\n\n## preload和prefetch\n\n我们直接上代码实操下：\n\n**1.css**\n```css\ndiv {\n    height: 200px;\n    width:200px;\n    background: red;\n}\n```\n**1.js**\n```js\nalert(1)\n```\n**html**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Document</title>\n    <link href=\"1.css\" rel=\"preload\" as=\"style\" />\n    <link href=\"1.js\" rel=\"preload\" as=\"script\" />\n    <link href=\"1.css\" rel=\"prefetch\"/>\n    <link href=\"1.js\" rel=\"prefetch\" />\n  </head>\n  <body>\n    <div></div>\n  </body>\n</html>\n```\n预览index.html，我们会发现，静态资源都加载了，但是不会执行,如下图,div的样式没有出来，js也没执行。\n\n<img src=\"images/index.jpg\" width=\"50%\"/>\n\n### 定义\n现在我们总结下：\n- preload和prefetch都用来提前加载资源，preload用来加载当前页面的资源，prefetch用来提前加载好后续页面的资源，这样后续进去其他页面就能省去加载时间\n- 无论preload还是prefetch，浏览器都是**只下载资源，不执行资源**\n- preload必须配合as，否则资源连下载都不会下载。实测chrome控制台会警告，资源也没加载了。as的值可以取style、script、image、font、fetch、document、audio、video等。prefetch则可以省略as\n<img src=\"images/as.jpg\" width=\"50%\"/>\n\n### 加载顺序\n\n我们现在现在看下加载顺序，举个🌰\n```html\n<link rel=\"stylesheet\" href=\"1.css\">\n<link href=\"3.css\" rel=\"prefetch\"/>\n<link href=\"3.js\" rel=\"prefetch\" />\n<link href=\"2.css\" rel=\"preload\" as=\"style\" />\n<link href=\"2.js\" rel=\"preload\" as=\"script\" />\n```\n加载结果如下图：\n1.css>2.css>2.js>3.css>3.js\n\n<img src=\"images/load1.jpg\" width=\"50%\"/>\n\n\n```html\n<link href=\"3.css\" rel=\"prefetch\"/>\n<link href=\"3.js\" rel=\"prefetch\" />\n<link href=\"2.css\" rel=\"preload\" as=\"style\" />\n<link href=\"2.js\" rel=\"preload\" as=\"script\" />\n<link rel=\"stylesheet\" href=\"1.css\">\n```\n加载结果如下图：\n2.css>2.js>1.css>3.css>3.js\n\n<img src=\"images/load2.jpg\" width=\"50%\"/>\n\n总结下：\n\n- preload不管在什么位置，都会最先加载，prefetch不管在什么位置优先级最低（独立的请求排到队列之中，然后浏览器空闲时将对这些请求加载），都会在最后加载，所以我们现在只需要知道，想让资源不按照书写顺序加载，想让某些资源插队加载，就可以用preload。\n\n继续🌰：\n\n```html\n <link href=\"3.css\" rel=\"prefetch\"/>\n <link href=\"3.css\" rel=\"preload\" as=\"style\"/>\n```\n加载结果如下图,prefetch和preload混用同一个资源，会重复加载\n<img src=\"images/load3.jpg\" width=\"50%\"/>\n\n```html\n <link href=\"3.css\"/>\n <link href=\"3.css\" rel=\"preload\" as=\"style\"/>\n 或者\n <link href=\"3.css\"/>\n <link href=\"3.css\" rel=\"prefetch\"/>\n```\n图我就不截了，都只会加载一次（浏览器遇到加载同一个资源，会直接把预加载的资源直接掉，不会再重复加载）\n\n总结下：\n\n- prefetch和preload混用同一个资源，会重复加载（一般也不会这样搞）\n- prefetch和preload如果和正常link一起加载资源，只会加载一次\n\n### vue打包实践应用\n\n我们细心观察下，会发现如下图\n<img src=\"images/vue.jpg\" width=\"50%\"/>\n\n我们发现，同一个资源，先在`<head></head>`中进行preload预加载，然后在`</body>`底部进行加载，这样做的好处，提前加载，dom尾部可以立即执行，提高页面加载效率。\n\n**注意：**\n**1. 即便网页被关闭，浏览器对该prefetch资源的下载也不会中止，所以，浏览器是一定会加载该资源的。**\n**2. prefetch和preload不影响window.onload事件(dom渲染完毕，此时可以获取所有dom)，也就是说，window.onload可能已经执行了，prefetch和preload还在单独加载**\n\n\n\n## dns-prefetch\n\ndns-prefetch又是什么？它跟上面两个做的事情不太一样，实际上是强迫浏览器对其他域名（通常就是DNS域名）进行提前解析，以便加快DNS域名的解析速度。\n比如你的网站域名叫www.a.com，你用的很多资源域名不是a.com,而是放到cdn上，来自于cdn.jsdelivr.net，那么你应该在index.html里最顶部位置写上：\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Document</title>\n    <link rel=\"dns-prefetch\" href=\"//cdn.jsdelivr.net\">\n  </head>\n  <body>\n    <div></div>\n  </body>\n</html>\n```\n\n这样可以提前解析进行dns域名解析。\n\n\n## async和defer\n```js\n// 立即加载并执行，阻塞dom渲染\n<script src=\"script.js\"></script>\n\n// 异步加载，不影响后面js加载以及再后面dom渲染，但该资源加载完毕后，会立马执行，假如dom还没渲染完，会阻塞dom渲染\n<script src=\"script.js\" async></script>\n\n// 异步加载，不影响后面js加载以及再后面dom渲染，dom渲染完（即DOMContentLoaded触发）在进行执行。\n<script src=\"script.js\" defer></script>\n```\n\n但是，实际工作过程中，我们一般直接把脚本放到`</body>之前`，此办法就可以保证dom渲染完毕后可以获取在执行脚本获取dom，还兼容所有浏览器。\n\n- defer和async都是用来异步加载js的。\n- defer的初衷是让你可以把js写在`<head>`里，而无需担心无法操作DOM。但是，一贯的最佳实践都是把js写在`</body>`之前，所以不存在这个问题。\n- async虽然下载时不阻塞HTML解析，但是下完完就会立刻执行，引来了很大的问题就是无法掌握执行时机，async在早年前端开发足够简单的时候是有用的，如今开发是各种依赖包，必须掌握执行时机，所以async根本无法考虑。除非无任何依赖dom、js等，比如百度统计等，不过我们一般放到最后一位，不也可以嘛。😁\n- defer 属性仅适用于外部脚本，如果 script 脚本没有 src，则会忽略 defer 特性。\n\n所以，如今开发中，这两个属性应用场景并不多。\n\n\n> [弄清preload、prefetch、dns-prefetch、defer和async](https://www.jianshu.com/p/02ec29ff9842)\n> [defer和async的区别](https://blog.csdn.net/qq_27674439/article/details/101316754)\n\n\n\n\n\n\n\n\n\n\n\n","categories":["javascript","傻傻分不清楚"]},{"title":"git删除仓库大文件历史-BFG","url":"/ypf-blog/2023/02/21/git/git删除仓库大文件历史-BFG/","content":"\n## git删除仓库大文件历史-BFG?\n\n> 我们在平常工作中，可能会不小心commit大文件，后面发现，又删除掉重新commit， 但历史记录仍会存在.git仓库中，导致新clone仓库时，仓库很大，clone很慢,那么如何操纵git历史，将仓库中的大文件记录删除呢？\n\n我们实际操作下：\n我们随便弄个git，然后放个大文件，这里以bfg.jar为例子，十几M，然后我们commit后，如下图，我们可以看到git仓库中存在该文件的历史记录\n\n<img src=\"images/img1.jpg\" width=\"50%\" height=\"50%\" />\n\n然后我们删除bfg.jar，再次commit， 如下图，仍会存在历史记录（肯定得存在，要不git可以恢复任意版本怎么实现）\n<img src=\"images/img2.jpg\" width=\"50%\" height=\"50%\" />\n\n直接删除？试试！\n\n我们直接找到图中的68文件夹删除，我们会发现git暂存区不会检测到，然后我们git push，会报错\n\n`error: refs/heads/master does not point to a valid object!`\n\n坏了，把仓库搞坏了， 赶紧撤销， 又可以正常push了。\n\n那么又该怎么删除大文件呢？我们介绍下[BFG Repo-Cleaner](https://rtyley.github.io/bfg-repo-cleaner/)\n\n\n## BFG Repo-Cleaner\n\n**BFG Repo-Cleaner** 最新版需要确保本地的java为Jdk8+,它为我们提供了一个工具，来快捷的清理仓库。使用步骤如下\n\n1. 本机安装java\n2. 下载bfg-1.14.0.jar包，改名为bfg.jar\n3. 在电脑上随便找个位置，使用 `--mirror`重新clone仓库，（ 假如仓库地址为 http://github.com/test.git ），命令如下\n```bash\n# 使用--mirror克隆项目\ngit clone --mirror http://github.com/test.git\n```\n\nclone后会出现一个文件夹，名字就叫test.git，里面只含有.git，(我们平常clone仓库，文件夹名不含.git，并且包含有代码),类似下图\n\n<img src=\"images/clone.jpg\" width=\"50%\" height=\"50%\" />\n\n4. 将第二步的bfg.jar包放到和git仓库的同级目录，执行下面任意一条命令\n```bash\n# 删除大于100M的文件\njava -jar bfg.jar --strip-blobs-bigger-than 100M test.git\n# 删除所有的名为'id_dsa'或'id_rsa'的文件\njava -jar bfg.jar --delete-files id_{dsa,rsa}  test.git\n# 删除doc文件夹下所有的文件\njava -jar bfg.jar --delete-folders doc test.git\n#  删除指定文件\njava -jar bfg.jar --delete-files name-of-file  test.git\n```\n\n此时，BFG将更新您的提交以及所有分支和标记，此时还没有物理删除。\n\n5. 进入test.git文件夹\n```bash\n#进入项目\ncd test.git\n```\n6.  在当前目录执行，进行删除大文件，此时已经物理删除\n```bash\n# 删除文件\ngit reflog expire --expire=now --all && git gc --prune=now --aggressive\n```\n7. 推送到远程即可\n```\n# 推送\ngit push\n```\n\n\n\n**注意：**\n\n如果之前已经有人clone过带大文件的项目， 你执行上面操作删除后，其他人本地仍会存在，实践让其他人`git fetch`不管用，\n所以需要让其他人提交代码后（大文件又会提交），删除项掉目，你重新执行上面操作删除掉大文件， 此时其他人再clone项目即可。\n\n\n\n","categories":["git"]},{"title":"git标签-tag","url":"/ypf-blog/2023/02/01/git/git标签-tag/","content":"\n## tag是什么?\ntag相当于commitId的别名，不依赖分支，和commit绑定，一般我们用来：\n- 上线后打个tag推上去，如20230201版本号， 或者在开发中某个功能打个tag。 这样可以快速切换到该tag下（如果通过commitId切换就得要查找那么长的commitId，麻烦）\n\n直接看代码:\n\n``` bash\n# 1.打tag\n\n# 当前最新/指定commit打tag\n$ git tag 标签名 [commitId]\n# 打带备注信息的tag\n$ git tag -a 标签名 -m [commitId] \"备注信息\"  \n\n# 2.查看tag\n\n# 查看所有tag\n  git tag\n# 筛选出tag1，tag2\n  git tag -l 标签名称1 标签名2\n# 查看tag具体信息\n  git show 标签名称\n\n# 3.删除tag\n\n# 删除本地tag\n  git tag -d 标签名称\n# 删除远程tag\n  git push origin --delete tag 1.0.0\n  或者\n  git push origin :refs/tags/1.0.0\n\n\n# 4. 上传tag\n\n#上传所有tag\n  git push origin --tags\n#上传指定tag\n  git push origin tag名\n\n\n# 5. 切换tag\n与分支管理一样，我们也是可以直接切换到某个 tag 上去的，切换完会提示你当前处于一个 \"detached HEAD\" 状态，\n此时我们不在任何分支上，处于游离状态（tag 相当于是一个快照，我们是不能直接更改它的代码），但可以基于这个 tag 创建一个分支\n#先切换到指定tag\n$ git checkout tag名\n#在此tag上创建分支\n$ git checkout -b [newbranchname] [tagname]\n\n```\n\n切换tag的截图\n\n<img src=\"images/tag.jpg\"/>\n\n\n>[Git打标签与版本控制规范](https://cloud.tencent.com/developer/article/1494508)\n>[git tag的使用](https://juejin.cn/post/7074777378714550303)","categories":["git"]},{"title":"mac配置nginx以及常用命令","url":"/ypf-blog/2023/01/17/nginx/mac配置nginx以及常用命令/","content":"\n此篇文章比较简单，并不全，只是用于记录常用命令，用到啥添加啥\n\n## mac安装nginx\n\n### 通过Homebrew安装\n\nhomebrew是什么？它是Mac中的一款软件包管理工具，通过brew可以很方便的在Mac中安装软件或者是卸载软件。可参考其官网[Homebrew](https://brew.sh/index_zh-cn.html)\n\n**Homebrew 怎么安装?**\n\n#### 方法一：通过brew官网安装脚本\n\n``` bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n但是可能存在网络问题，要么下载极其龟速，要么直接出现如下提示`curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused`\n\n#### 方法二：通过中科大镜像仓库源加速访问安装\n\n``` bash\n/usr/bin/ruby -e \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)\"\n```\n\n\n### 安装nginx\n\n``` bash\nbrew install nginx\n```\n### brew 常用命令\n\n``` bash\n# 更新Homebrew\nbrew update \n# 查看nginx的配置信息\nbrew info nginx\n```\n\n### 版本问题\n\n#### 1.执行任何brew命令都会报错\n提示`/usr/local/Homebrew/Library/Homebrew/version.rb:368:in ‘initialize’: Version value must be a string; got a NilClass () (TypeError)`\n\n我们只需要执行 `brew update-reset`更新到最新版本即可\n\n\n\n## nginx配置目录\n\n- nginx默认安装到 `/usr/local/Cellar/nginx`  目录下\n- nginx配置目录：`/usr/local/etc/nginx/nginx.conf`\n- 文件部署目录：`/usr/local/var/www` ，我们也可以访问 `/usr/local/Cellar/nginx/1.17.9/html`, 实际指向的就是`/usr/local/var/www`\n- log目录：`/usr/local/var/log/nginx/*.log` （其中，access.log  每次正常访问的日志，error.log    每次报错的日志）\n\n## nginx常用命令\n\n``` js\n\n1、启动nginx命令\nsudo nginx\n\n2、重启nginx命令\nsudo nginx -s reload\n\n3、优雅的停止nginx（具体区别没测试）\nsudo nginx -s quit\n\n4、快速停止nginx\nsudo nginx -s stop\n\n5、打开nginx命令\nsudo vim /usr/local/etc/nginx/nginx.conf\n\n6、编辑nginx命令\n⬆️+ i（先要退出编辑状态）\n\n7、保存nginx命令\n⬆️+ w（先要退出编辑状态）\n\n8、保存退出nginx命令\n⬆️+ wq（先要退出编辑状态）\n\n9、退出nginx命令\n⬆️+ q（先要退出编辑状态）\n\n10、退出nginx编辑命令\nesc\n\n``` \n\n## nginx部署静态文件（此处以vue项目为例）\n\n1. 打开nginx的根目录\n\n```bash\nopen /usr/local/var/www\n```\n2. 打包vue项目\n**注意**：如果部署在网站根目录，正常打包，默认vue打包index.html引用路径类似如下：\n`<link href=\"/static/js/chunk-vendors.846027a5.js\"`\n\n如果部署在二级/任意级域名下，要修改 `publicPath:''`,打包后，引用路径如下：\n`<link href=\"static/js/chunk-vendors.846027a5.js\"`\n\n我们下面以适用性广的配置为例， 即二级域名，我们将打包后的dist文件夹修改为名字为test复制第一步的目录中\n\n\n3. 配置nginx\n```bash\nopen /usr/local/etc/nginx/nginx.conf\n```\n\n增加server代码块\n\n``` bash\n  server {\n\t    listen 80;\n\t    location /test {\n\t        root  html;\n\t        index  index.html index.htm;\n\t    }\n }\n 或者\n server {\n    listen 80;\n    location /test {\n        alias  html/test;\n        index  index.html index.htm;\n    }\n}\n\n```\n\n4. 启动nginx， 访问 `http://localhost/test` 即可\n\n## nginx中 root 和location 区别\n\nnginx 指定文件的路径有两种方式 root 和 alias，两种方法的作用域不一样：\n- root 与 alias 主要区别在于 nginx 如何拼接 location 后面的 url 去访问文件\n- root 的处理结果是：nginx访问`root + location路径` ; alias 的处理结果是：nginx直接访问`alias路径`,如上面的配置例子\n  \n\n","categories":["nginx"]},{"title":"patch-package","url":"/ypf-blog/2022/10/08/npm/patch-package/","content":"\n> 我们在开发中,经常用到第三方依赖,假如我们现在用到了`element-ui`的button组件,但是发现有时候需要拓展,或者改组件bug, 起初我们想到的方案是:\n- 找到node_modules源码,复制到本地修改,然后引用本地,但是这种一是不太优雅,二是如果人家更新,自己项目还要重新复制过来修改,非常麻烦.\n\n有没有其他方案呢?\n\n## 什么是patch-package?\n\n官方这样描述: [patch-package](https://github.com/ds300/patch-package) lets app authors instantly make and keep fixes to npm dependencies. It's a vital band-aid for those of us living on the bleeding edge.\n\n简单来说就是打补丁、创可贴\n\n## 用法\n\n 1. `npm install patch-package --save-dev` ,先安装包\n 2. 直接在`node_modules`中修改包文件,然后运行 `npx patch-package 包名`,\n   此时patch-package会在项目根目录生成一个patches文件夹,并生成补丁文件,文件名格式为 `包名+包版本号码 如element-ui+2.15.10`\n   (注意如果node_modules中包文件没有改动,运行命令,会提示没有改动).\n   \n    <img src=\"images/noPackage.jpg\"/>\n    <img src=\"images/nochange.jpg\"/>\n    <img src=\"images/change.jpg\"/>\n\n 3. 在`package.json`文件中的 scripts 中加入git钩子 `\"postinstall\": \"patch-package\"`。这样我们每次npm install后, patch-package会去找patche文件并将依赖进行更新,如果同伴不想删除依赖重装,可以让其直接 执行 `patch-package`即可\n\n总结下:\n\n    生成补丁: `npx patch-package 包名`\n    执行补丁: `npx patch-package`\n\n## 注意\n\n1. `npx patch-package 包名`生成补丁原理是先去package.json并且必须要有package-lock.json(或者yarn.lock也可以)中找对应的包名,然后再去 node_modules文件中找,所以如果package.json或者package-lock.json文件没有,就会报错找不到\n2. 生成的补丁文件实际上是一个diff文件，使用`npx patch-package`执行补丁时, \n   其会自动根据patch文件的名字(包名+版本号)直接去node_modules文件中找,如果找不到也会报错, 版本号不对也会报错.\n   不会依赖package.json和package-lock.json文件.\n   所以假如生成patch的版本是 2.5.10版本,假如第三方更新为2.5.11时, 执行补丁会提示找不到.问是否是2.5.10,此时再手动执行`npx patch-package element-ui`, 此时patch文件名会自动变更为为2.5.11版本, **但是注意很有可能即使补丁成功应用，也会出现破损,所以自己要核对下**\n\n这里手动把patch包名字改成 2.5.10测试下,如图\n\n<img src=\"images/update.jpg\" />\n\n3. 不要去人为修改patch文件, 如果修改了,`执行补丁也会报错 ` maybe there was an accidental change made to the patch file?`\n\n\n\n","categories":["npm"]},{"title":"HTTP headers 之 host, referer, origin","url":"/ypf-blog/2022/09/27/http/HTTP headers 之 host, referer, origin/","content":"\n<img src=\"images/1.png\" width=\"50%\" height=\"50%\"/>\n\n我们在工作过程中,是不是经常在header头看到过这三个字段,那么这三个字段具体是什么区别呢?\n\n## host\n\n### 定义\n\nhost:当前请求资源的服务器域名/ip地址+端口号。(不包含协议)\n组成：域名+端口号\n\n假如我们这里有index.html,本地服务启动,`http://localhost:5500/index.html`\n\n```html\n<!DOCTYPE html>\n<!--html的Host: localhost:5500 -->\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <!-- 没有host,有 :authority: cdn.bootcdn.net -->\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\n    <!-- Host: localhost:5500 -->\n    <script src=\"./test.js\"></script>\n</head>\n<body>\n    <!-- Host: www.baidu.com  -->\n    <img src=\"https://www.baidu.com/img/flexible/logo/pc/result@2.png\" alt=\"\">\n    <script>\n      // Host: developers.douban.com\n        axios('https://developers.douban.com/wiki/?title=api_v2')\n    </script>\n</body>\n</html>\n```\n\n<img src=\"images/host.gif\" />\n \n总结下:\n- Host 在request Header头里面,表示当前请求资源的域名\n- HTTP/1.1 的所有请求报文中必须包含一个 Host 头字段。如果一个 HTTP/1.1 请求缺少 Host 头字段或者设置了超过一个的 Host 头字段，一个400（Bad Request）状态码会被返回。\n- HTTP/2 引入了` :authority `标头来替换 Host 标头\n  \n我们可以在控制台看到加载资源的http版本\n\n<img src=\"images/http-version.jpg\" />\n\n### 用途\n\nhost主要应用在虚拟主机技术上.\n比如说有一台 ip 地址为 11.11.11.11 的服务器，在这台服务器上部署着淘宝、京东、拼多多的网站，并且配置了三个虚拟主机：a.com, b.com, c.com, 这三个域名都指向 11.11.11.11。 当我们访问 c.com 的网站时，看到的是拼多多的页面而不是淘宝和京东的页面，原因就是 Host 请求头决定着访问哪个虚拟主机。\n\n<img src=\"images/host-virtual.awebp\" />\n\n\n\n## referer\n\n### 定义\nreferer:表示当前请求的资源是从哪里来的\n组成：协议+域名+端口号+路径+查询参数（注意，不包含 hash值）\n\n场景1: 还是假设index.html,本地服务启动,我们直接在浏览器url上打开该网址`http://localhost:5500/index.html?a=1&b=2#aa`\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\"> \n<!-- html 没有referer-->\n  <head>\n    <meta charset=\"UTF-8\" />\n    <!-- referer: http://localhost:5500/ -->\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\n    <!-- Referer: http://localhost:5500/index.html?a=1&b=2 -->\n    <script src=\"./test.js\"></script>\n    <!-- Referer: http://localhost:5500/index.html?a=1&b=2 -->\n    <link rel=\"stylesheet\" href=\"./test.css\">\n  </head>\n  <body>\n    <!-- Referer: http://localhost:5500/ -->\n    <img src=\"https://www.baidu.com/img/flexible/logo/pc/result@2.png\" alt=\"\" />\n    <!-- Referer: http://localhost:5500/index.html?a=1&b=2 -->\n    <img src=\"./test1.png\" alt=\"\" />\n    <script>\n      // referer: http://localhost:5500/\n      axios(\"https://developers.douban.com/wiki/?title=api_v2\");\n    </script>\n  </body>\n</html>\n```\n\n<img src=\"images/referer.gif\" />\n\n我们总结下:\n1. 直接在浏览器输入地址打开页面, 页面没有referer, 但是页面加载的资源是有referer的\n2. 页面加载的资源如果和页面域名同源的话,referer=协议+域名+端口号+路径+查询参数,如果不同源,referer=协议+域名+端口号\n\n\n\n场景2: 假设有a.html, b.html, 我们测试下从a跳转b以及b跳转a \n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>a页面</title>\n  </head>\n  <body>\n    <img src=\"https://www.baidu.com/img/flexible/logo/pc/result@2.png\" alt=\"\" />\n    <h1>a页面</h1>\n    <a href=\"http://localhost:8082/b.html\"> a标签跳转b页面 </a>\n    <br/>\n    <a href=\"http://localhost:8082/b.html\" target=blank> a标签跳转b页面(target=blank) </a>\n    <br/>\n    <a onclick=\"window.location.href='http://localhost:8082/b.html'\" href=\"javascript:;\"> 跳转b页面(window.location.href) </a>\n    <br/>\n    <a onclick=\"window.open('http://localhost:8082/b.html')\" href=\"javascript:;\"> 跳转b页面(window.open) </a>\n  </body>\n</html>\n\n<!DOCTYPE html>\n<!-- html -->\n<!-- 从a标签过来: Referer: http://localhost:8080/ -->\n<!-- 从a标签target=blank过来: Referer: http://localhost:8080/ -->\n<!-- 从window.location.href: Referer: http://localhost:8080/ -->\n<!-- 从window.open: Referer: http://localhost:8080/ -->\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>b页面</title>\n</head>\n<body>\n    <!-- 从a标签过来: Referer: http://localhost:8082/ -->\n    <!-- 从a标签target=blank过来: Referer: http://localhost:8082/ -->\n    <!-- 从window.location.href: Referer: http://localhost:8082/ -->\n    <!-- 从window.open: Referer: http://localhost:8082/ -->\n    <img src=\"https://www.baidu.com/img/flexible/logo/pc/result@2.png\" alt=\"\" />\n    <a href=\"http://localhost:8080/a.html\"> a标签返回a页面 </a>\n    <a onclick=\"window.history.go(-1)\" href=\"javascript:;\"> window.history.go(-1)返回a页面 </a>\n</body>\n</html>\n```\n---\n>[HTTP headers 之 host, referer, origin](https://juejin.cn/post/6844903954455724045)\n","categories":["http"]},{"title":"git简写-alias","url":"/ypf-blog/2022/09/16/git/git简写-alias/","content":"\n## git简写?\n\n> 我们每天都要码字进行git操作,长时间就会感觉一直输入重复的命令,那么有没有简写方式?\n\n直接看代码:\n\n``` bash\n# 1.方式一\n\n# cm (commit -m)\ngit config --global alias.ad add .\n# cm (commit -m)\ngit config --global alias.cm commit -m\n# ph(push)\ngit config --global alias.ph push\n\n添加完后会自动在.gitconfig文件添加如下命令\n\n[alias]\n\tad = add\n\tcm = commit\n\tph = push\n\n注意,通过第一种方式,只会添加空格前面的内容,所以commit -m只能生成commit, add . 只能生成add, 所以我们一般直接手动改.gitconfig文件\n\n# 2.方式二(电脑中找到.gitconfig文件添加如下代码,我们可以输入git config --list --show-origin快速查找该文件位置)\n\n[alias]\n\tad = add .\n\tcm = commit -m\n\tph = push\n\n```\n\n此时我们就可以用下面方式提交\n\n``` bash\ngit ad\ngit cm '备注'\ngit ph\n\n```\n写到这里,有没有更简单的方式,既然都简写了,我肯定连git都不想输入,当然有\n\n## 配置bash别名或zsh别名等\n\n如果使用的命令行编辑器是bash,编辑.bash_profile文件,\n如果是zsh,编辑.zshrc文件, 像mac，目录一般存在于文稿-用户名-隐藏文件（`cmd+shift+.`切换显示隐藏文件）\n都增加下面的代码\n``` bash\nalias gac=\"git add . && git commit -m\"\nalias gh=\"git push\"\n#  一键提交  \n# 获取当前分支名 \nfunction gach() {\n    git add .\n    git commit -m \"$1\"\n    # 获取当前分支名\n    branch_name=$(git symbolic-ref --short -q HEAD)\n    git push origin $branch_name\n}\nalias gacp=gacp\n```\n\n这样,我们直接这样即可\n``` bash\ngac '备注'\ngh\ngach '备注'\n```\n\n\n\n\n\n\n","categories":["git"]},{"title":"git回滚-reset","url":"/ypf-blog/2022/09/16/git/git回滚-reset/","content":"\n## 硬回滚(reset --hard)?\n\n直接看代码:\n\n``` bash\n# 回退到上个版本\ngit reset --hard HEAD^\n# 回退到上上个版本\ngit reset --hard HEAD^^\n# 通过commit_id(注意,这个id可以是简写,如通过git reflog获取的简写id)回退/前进到指定版本\ngit reset --hard commit_id  \n```\n我们在开发过程中, reset --hard使用比较多,实际还有一种选项 --soft来回滚代码\n\n## 软回滚(reset --soft)?\n\n直接看代码:\n\n``` bash\n# 回退到上个版本\ngit reset --soft HEAD^\n# 回退到上上个版本\ngit reset --soft HEAD^^\n# 通过commit_id(注意,这个id可以是简写,如通过git reflog获取的简写id)回退/前进到指定版本\ngit reset --soft commit_id  \n```\n\n## soft和hard区别?\n那么 --hard和--soft的区别是什么?我们这里还是有3次commit记录,我们分别用这两种命令回退版本\n\n--soft HEAD^\n<img src=\"images/soft1.gif\" />\n--soft HEAD^^\n<img src=\"images/soft2.gif\" />\n\n--hard HEAD^\n<img src=\"images/hard1.jpg\" />\n--hard HEAD^^\n<img src=\"images/hard2.jpg\" />\n\n\n我们看上图可以知道其中的区别:\n\n比如回退到上个版本,\nhard是直接回退到上个版本,当前工作区就是上个版本\nsoft当前工作区仍是最新的代码,只不过没有commit,代码在暂存区\n\n## reset回退后如何push?\n\n我们通过上面操作回退后,如果代码之前没push过,直接push即可,如果之前已经push过,那回退后的代码和远程的代码不一致, 此时push会提示不一致,我们只需要强制提交即可\n\n``` bash\n# 强制提交\ngit push --force 或 git push -f\n```","categories":["git"]},{"title":"git log与git reflog区别","url":"/ypf-blog/2022/09/16/git/git log与git reflog区别/","content":"\n## git如何查看历史版本?\n\n> 你可能在开发中,需要切换到历史版本,那么我们都有什么命令呢?\n\n\n直接看代码:\n\n``` bash\n  git log\n  # 每条日志都只显示一行 \n  git log --pretty=oneline\n  git log -g\n  git reflog\n```\n\n我们发现查看git历史,有很多命令,那么这些命令都有什么区别吗?现在我们假如我们有3次commit记录,我们分别运行上面命令看下效果\n\n<img src=\"images/log.jpg\" />\n\n从上面截图,我们可以看出\n- git log 展示信息比较详细,但看着比较乱\n- 使用 --pretty=oneline可以将信息展示一行(只有commitId和备注)\n- git log -g 从上图看上去和git log一样(**真一样吗?**)\n- git reflog 展示的只含有前缀的commitId和备注\n\n现在,我们使用git reset —hard HEAD^ 回退上一个版本,再次打印log\n  \n<img src=\"images/log2.jpg\" />\n从上面截图,以及对比第一的截图,我们总结下\n\n**1. git log只展示当前版本以及之前的日志,不包含回退的过程, -g可以展示**\n**2. git reflog包含回退的过程**\n**3. git log 加上--pretty=oneline可以将信息展示一行(只有commitId和备注)**\n**4. 准确的说,git log展示的是commit的list, reflog或-g展示的是git所有操作日志**\n\n\n\n\n\n\n\n\n","categories":["git"]},{"title":"git修改commit信息-amend","url":"/ypf-blog/2022/09/16/git/git修改commit信息-amend/","content":"\n## git修改commit信息(未push,只commit了)?\n\n> 某一天,你正在飞速敲代码,结果一不小心 git commit -ma,将备注搞成a了, 不要说不可能,开发不规范,一切皆有可能, 不过此时还没push,那么如果修改这个信息呢?\n\n### 最近一次\n\n直接看代码:\n\n``` bash\n\n# 修改最近一次commit信息,此时会跳出vim窗口,修改完:wq保存即可\n$ git commit —amend \n# 直接修改最近一次commit信息,不用vim窗口\n$ git commit --amend --message=\"XXX\"\n# 又想修改commit信息,又想修改author信息\n$ git commit --amend --message=\"XXX\" --author=\"XXX <XXX@XX.com>\"\n\n```\n**注意⚠️: 这个只适用于修改最新的一次commit信息**\n\n### 指定某次\n要修改指定某次commit的信息,我们可以使用**变基git rebase**操作.\n这里我们假设有2次提交记录,我们要修改第一次的commit信息:\n\n1. `git log --oneline` 查看commit信息\n因为我们要修改的第一次,但是`git rebase -i [startpoint]  [endpoint]` 左开右闭,所以不包含第一次, 我们使用 `--root到根`. **注意git rebase -i 的记录是正序的, 和git log倒序相反,比较特殊**\n<img src=\"images/1.jpg\" width=\"50%\" height=\"50%\" />\n\n2. `git rebase -i --root`\n<img src=\"images/2.jpg\" width=\"50%\" height=\"50%\" />\n\n3. `i`进入编辑模式,修改pick为s, `esc`推出编辑模式,  `:wq`保存退出. \n4. 此时会跳出一个窗口,`i`进入编辑修改commit信息,输入完 `esc`,然后`:wq`保存退出即可\n<img src=\"images/3.jpg\" width=\"50%\" height=\"50%\" />\n   \n## git修改commit信息(已经push了)?\n\n执行完上面命令,要 `git push -f `强制提交就会覆盖的提交信息了. 适用任意次,比如如果上面修改的是最近一次就会更新最后一次,如果是指定的某次,就会更新指定某次.\n\n<img src=\"images/4.jpg\" width=\"50%\" height=\"50%\" />\n\n\n\n\n\n\n\n\n","categories":["git"]},{"title":"git暂存-stash","url":"/ypf-blog/2022/09/16/git/git暂存-stash/","content":"\n## 暂存(stash)是什么?\n\n> 某一天你正在 feature 分支开发新需求，突然产品经理跑过来说线上有bug，必须马上修复。而此时你的功能开发到一半，于是你急忙想切到 master 分支，你可能会commit -m \"暂存代码\",然后切到hotfix分支去修复bug,这样搞虽然没什么问题,但是不太优雅, 那么怎么才能不commit,直接去切到hotfix分支?stash命令就可以满足你的需求\n\n直接看代码:\n\n``` bash\n# 1.暂存\n\n# 暂存当前代码\n$ git stash\n# 暂存当前代码并带备注\n$ git stash save ‘备注的内容’\n\n# 2.恢复暂存 stash pop\n\n# 查看暂存list\n  git stash list\n# 恢复最近一次的stash\n  git stash apply\n# 恢复最近一次的stash，随后删除该记录\n  git stash pop\n# 恢复指定stash,如恢复第一条是0,第二条是1\n  git stash pop stash@{0}\n# 删除最近的一次stash\n  git stash drop\n# 清空stash\n  git stash clear\n\n```\n\n\n> [Git不要只会pull和push，试试这5条提高效率的命令](https://juejin.cn/post/7071780876501123085#heading-29)","categories":["git"]},{"title":"AST抽象语法树","url":"/ypf-blog/2022/06/22/ast/AST抽象语法树/","content":"\n## 什么是抽象语法树?\n\n- 抽象语法树 (Abstract Syntax Tree)，简称 AST，它是源代码语法结构的一种抽象表示。它是以树状的形式表现各种计算机编程语言(比如java、c、javascript等)的语法结构。 \n- 我们可以通过诸如网站[astexplorer](https://astexplorer.net/)很清晰的看到各种语言的 AST 结构。\n\n## estree规范\n- 既然不同编程语言都有对应的AST,那么相对应的肯定需要规范来统一。[estree规范](https://github.com/estree/estree/blob/master/es2015.md)就是成为操纵JavaScript源代码的工具的通用语言。它定义了JavaScript中所有涉及到的语法的表达形式\n- estree这个项目的初衷通过社区的力量，保证和es规范的一致性，通过自定义的语法结构来表述JavaScript的AST，后来随着知名度越来越高，多位知名工程师的参与，使得变成了事实意义上的规范，目前这个库是Mozilla和社区一起维护的。\n\n    \n## js解析器\n\n**正因为有了estree规范,社区产生了各种js解析器(用于将js代码转换成符合estree规范的AST结构).**\n1. [Esprima](https://github.com/jquery/esprima), 这是第一个用JavaScript编写的符合EsTree规范的解析器, 其也有[可视化网站](https://esprima.org/demo/parse.html#),类似astexplorer,用于快速清晰的看到js的AST结构\n  \n举个🌰\n`\n const a=1\n`\n通过Esprima转化成ast结构就是\n\n<img src=\"images/ast.jpg\" width=\"50%\" height=\"50%\" />\n\n2.[acorn](https://github.com/acornjs/acorn),和Esprima类似,输出的ast都是符合EsTree规范的，目前webpack的AST解析器用的就是acorn\n\n3.[@babel/parser](https://github.com/babel/babel/tree/master/packages/babel-parser),babel官方的解析器，最初fork于acorn叫Babylon，后来完全走向了自己的道路改名为@babel-parser(基于 ESTree 并修改过的 AST,但是符合estree规范的)，babel就是通过@babel/parser将js代码转换为 AST 抽象语法树的,其输出的ast都是符合EsTree规范的\n\n4.[espree](https://github.com/eslint/espree),eslint的官方解析器,最早fock于Esprima,现在基于acorn开发.其输出的ast都是符合EsTree规范的\n\n5.[uglify-js](https://link.zhihu.com/?target=https%3A//github.com/mishoo/UglifyJS),用于混淆和压缩代码，因为一些原因，uglify-js自己[实现了一套AST规范](https://lisperator.net/blog/uglifyjs-why-not-switching-to-spidermonkey-ast/),其使用SpiderMonkey解释器,所生成的ast也可以叫做SpiderMonkey 树,也正是因为它的AST是自创的，不是标准的ESTree，es6以后新语法的AST，都不支持，所以没有办法压缩最新的es6的代码.如果需要压缩，可以用类似babel这样的工具先转换成ES5。注意:由于uglify-js其内部所使用的spiderMonkey解释器效率慢,官方支持 `-p --acorn`选项来使用Acorn解释所有代码。如果你传入这个选项，UglifyJS会`require(\"acorn\")`,Acorn确实非常快（650k代码原来要380ms，现在只需250ms），但转换Acorn产生的SpiderMonkey树会额外花费150ms。所以总共比UglifyJS自己的解释器还要多花一点时间。\n\n## js解析器如何生存AST\n\n词法分析-->语法分析-->AST树\n\n我们来解释下:\n\n### 词法分析:即分词\n   1.一个一个字母的来读取字符, 然后与定义好的 JavaScript 关键字符做比较，生成对应的Token即单词;\n>例如 var 这三个字符，它只能作为一个整体，语义上不能再被分解，因此它是一个 Token。\n   2.词法分析器里，每个关键字是一个 Token(单元) ，每个标识符是一个 Token，每个操作符是一个 Token，每个标点符号也都是一个 Token。除此之外，还会过滤掉源程序中的注释和空白字符、换行符、空格、制表符等。\n   3.最终，整个代码将被分割进一个tokens列表（或者说一维数组）。\n\n我们可以通过[esprima可视化网站](https://esprima.org/demo/parse.html#)快速查看token形态\n\n<img src=\"images/token.png\" width=\"50%\" height=\"50%\" />\n\n### 语法分析:在上面词法分析出来的 Token 转化成有语法含义的抽象语法树结构。同时，验证语法，语法如果有错的话，抛出语法错误。\n\n**上面我们介绍了各种js解析器以及解析器如何生成AST,下面我们介绍下AST的应用**\n\n## AST应用\n\n1. 编辑器的错误提示、代码格式化、代码高亮、代码自动补全；\n2. elint、prettier 对代码错误或风格的检查；\n3. babel的es6转es5\n4. vue模板编译、react模板编译\n5. 组件库按需引入如babel-plugin-import\n6. TypeScript、JSX等转化为原生Javascript等等\n\n\n下面我们以babel的es转换举例来加深对AST的理解:\n- <font color=\"red\">@babel/parser</font>:将js代码转换成AST树\n- <font color=\"red\">@babel/traverse</font>:对AST进行递归遍历(需要配合visitor操作ast树,下面会讲)\n- <font color=\"red\">@babel/generator</font>:AST树转换成新的js代码\n\n下面我们实操下:\n**目的:将`const a=1;  `转换成`let a=1;`**\n直接看代码:\n``` js\n      // 1. 引入3个依赖\n      const parser = require(\"@babel/parser\");\n      const traverse = require(\"@babel/traverse\");\n      const generator = require(\"@babel/generator\");\n      // 或者我们只需要安装@babel/core和@babel/generator,因为@babel/core已经内部自己require了@babel/parser和@babel/traverse\n      const core=require(\"@babel/core\") // 我们使用core.parse, core.traverse即可\n      const generator=require(\"@babel/generator\")\n      // 2. 这里我们用下面代码举例\n      const code = `const a=1;  `;\n      // 3.parser将代码解析为抽象语法树（AST）\n      const ast = parser.parse(code);\n      // 4.traverse 对AST进行递归遍历\n      traverse.default(ast);\n      // 5. generator 将 AST 转回成代码\n      const result = generator.default(ast).code;\n      console.log(result); // 打印结果 const a = 1;\n```\n我们在node中执行上面代码, 打印结果发现除下代码后面空格没了,结果一样,没什么变化,并没有转换. 还记得我们上面介绍@babel/traverse时候,说它需要配合visitor.那么什么是visitor?\n\n**Visitor(访问者)**\n> 访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了获取所有ast树节点的方法。这么说有些抽象所以让我们来看一个例子。\n\n我们上面说traverse.default(ast)是对AST进行递归遍历,那么我们要操作ast,肯定需要获取遍历的每个树节点吧,所以visitor就是一个包含各种树节点方法的对象\n```js\n      const visitor={\n         VariableDeclaration:{\n            enter() {\n               console.log(\"Entered, 进入type===VariableDeclaration节点!\");\n            },\n            exit() {\n               console.log(\"Exited,离开type===VariableDeclaration节点!\");\n            }\n         }\n      }\n```\n上面代码表示:\n- VariableDeclaration: 对应的是ast树上的type值,即树节点类型,这里是变量声明\n- enter:进入节点时触发, 一层层进入直到没有子节点,然后再层一层的离开,直到根节点\n- exit:离开节点时触发\n\n一般exit用的少,所以如果我们只用enter,我们可以简写\n```js\n      const visitor={\n         VariableDeclaration(){\n         \n         }\n      }\n```\n<img src=\"images/babel.png\" />\n\n\n一般我们就用上面这种,直接key=具体节点类型,直接通过[astexplorer](https://astexplorer.net/)快速查看type值, value为enter函数, 来操作ast, 实际最原始的是\n```js  \n      const visitor={\n         enter() {\n               console.log(\"Entered, 进入所有节点都会触发\");\n         },\n         exit() {\n               console.log(\"Exited,离开所有节点都会从触发\");\n         }\n      }\n```\n这个知道就行了.\n现在我们重新修改上面的🌰\n```js\n      const visitor={\n         VariableDeclaration(path){\n            console.log(path.node.kind) // const\n            path.node.kind=\"let\"\n         }\n      }\n      traverse.default(ast,visitor);\n```\n执行,会发现我们已经输出 `let a=1;`\n\n注意: visitor的enter函数有个path参数;可以简单地认为path是对当前访问的node的一层包装。例如使用path.node可以访问到当前的节点，使用path.parent可以访问到父节点.\n\n\n我们也可以这样写\n```js\n     const types = require(\"@babel/types\"); \n     const visitor={\n         enter(path) {\n            if (types.isVariableDeclaration(path.node)) {\n                console.log(path.node.kind) // const\n                path.node.kind=\"let\"\n            }\n         },\n      }\n      traverse.default(ast,visitor);\n```\n      \n上面引用了常用的依赖 `@babel/types`的isVariableDeclaration方法,用于判断是否是变量声明节点\n\n- <font color=\"red\">@babel/types</font>:一个封装了各种操作AST 节点方法的类似Lodash式工具库,我们可以通过它对具体的 AST 节点进行判断添加、更新、修改及移除等操作非常方便；\n\n### 打印enter、exit\n```js\nconst { parse, traverse } = require(\"@babel/core\");\nconst generator = require(\"@babel/generator\");\nconst code = `function ast(){}`;\nconst ast = parse(code);\nlet indent = 0; // 缩进空格数\nfunction padding() {\n  return \" \".repeat(indent);\n}\ntraverse(ast, {\n  enter(node) {\n    console.log(padding() + \"enter\" + node.type);\n    indent += 2;\n  },\n  exit(node) {\n      indent -= 2;\n      console.log(padding() + \"exit\" + node.type);\n  },\n});\nconst result = generator.default(ast).code;\nconsole.log(result); \n```\n<img src=\"images/1.jpg\" width=\"50%\" height=\"50%\" />\n上图我们能看出enter、exit的执行顺序:`一层层进入,一层一层离开`\n介绍了这么多, 我们应该了解了ast是啥、ast怎么用了吧?趁热打铁, 我们看下如何编写babel插件(把上面的🌰封装成babel插件引用)?\n\n## 如何编写babel插件?\n\n### babel的编译流程?\n\n上面我们讲了babel的es转换举例来加深对AST的理解的例子, 其实这个正是babel的编译流程,我们总结下:\n1. 解析阶段：通过`@babel/parser`将代码解析ast.解析一般分为两个阶段：词法分析和语法分析。\n2. 转换阶段：通过`@babel/traverse`依赖visitor(也就是babel的plugin/preset),进行ast修改\n3. 生成阶段: 通过` @babel/generator`将上一步处理完的ast转换成代码字符串\n\n### babel的插件系统?\nBabel 的核心模块 @babel/core，@babel/parser，@babel/traverse 和 @babel/generator 只是提供了完整的编译流程。而具体的转换逻辑需要插件来完成。上面我们说`@babel/traverse`配合visitor,本质上,plugin就是visitor\n\n> 原始代码 --> [Babel Plugin] --> 转换后的代码\n\n我们在使用babel时候,一般都是通过配置文件来设置,如 `babel.config.js`, 其中,里面有两个配置选项  plugins 和 preset 就是来配置插件的.\n- plugin不用解释,就是包装的visitor,Babel插件一般尽可能拆成小的力度，开发者可以单独安装。比如对ES6转ES5的功能，Babel官方拆成了20+个插件。开发单独引入,而不是直接引入全家桶\n- preset(预设) 由于plugin颗粒度较细, 开发中逐个引入插件就变得麻烦、效率低下了,我们把常用的plugin放到一起,就是preset\n\n最常见的如@babel/preset-env 预设，它整合了很多常用的plugin,其包含了目前以及未来最新的ES语法特性，并且可以通过配置目标运行环境范围，自动按需引入插件。\n\n<img src=\"images/@babel:preset-env.jpg\" width=\"50%\" height=\"50%\" />\n\n所以我们可以这样写\n```js\n   module.exports = {\n      presets: ['@vue/cli-plugin-babel/preset'],\n   }\n   或者单独一个一个引用\n   module.exports = {\n      plugins:[\"@babel/plugin-syntax-jsx\",\"@babel/plugin-syntax-async-generators\",\"@babel/plugin-syntax-dynamic-import\",...]\n   }\n```\n#### Plugin/Preset 执行顺序\n\n我们在配置文件里面配置了Plugin/Preset,那么babel执行的时候是按什么顺序呢?\n\n- Plugin 会从第一个由上往下开始顺序执行。\n- Preset 顺序则刚好相反(从最后一个逆序执行)\n- 如果Plugin和Preset同时存在,先执行 plugins 的配置，再执行 presets 的配置\n\n举个🌰\n```js\n   {\n      \"plugins\": [\n         \"transform-decorators-legacy\",\n         \"transform-class-properties\"\n      ]\n   }\n   执行顺序为:transform-decorators-legacy、transform-class-properties\n```\n\n``` js\n   {\n      \"preset\": [\n       \"es2015\",\n       \"react\",\n       \"vue\"\n      ]\n   }\n   执行顺序为:vue， react， 最后 es2015。\n```\n\n``` js\n   {\n      \"presets\": [\n            [\n               \"@babel/preset-env\",\n               \"@babel/preset-dep\"\n            ]\n      ],\n      \"plugins\": [\n         [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }],\n         [\"@babel/plugin-proposal-class-properties\", { \"loose\": true }],\n         \"@babel/plugin-transform-runtime\",\n      ]\n   }\n   执行顺序为:@babel/plugin-proposal-decorato、@babel/plugin-proposal-class-properties、\n            @babel/plugin-transform-runtime、@babel/preset-dep、@babel/preset-env\n```\n下面我们实操下自己写plugin以及preset,\n\n1. npm init -y 初始化package.json, script增加指令\n```js\n   \"scripts\": {\n    \"build\": \"babel test.js\"\n  },\n```\n2. npm install --save-dev  @babel/cli   \n3. 新建test.js\n```js\n   const a=1  ;\n```\n4. 新建plugin.js\n```js\nmodule.exports = function (babel) {\n  const { types: t, template } = babel; // babel会自动注入\n  const visitor = {\n    VariableDeclaration(path,state) {\n      console.log(state.opts.a) //1  通过state.opts可以获取传给插件参数\n      path.node.kind = \"let\";\n    },\n  };\n  return {\n    name: \"my-plugin\",\n    visitor,\n  };\n};\n\n```\n5. 新建babel.config.js\n```js\nmodule.exports={\n    plugins:[\n        [\"./plugin.js\",{\n            a:1  // 参数\n        }]\n    ]\n}\n```\n6. 执行npm run build 即可看到 let a=1;  注意空格也会去除\n\n上面我们就完成了一个plugin,现在我们用presets\n\n7. 我们新建立preset.js\n\n```js\nmodule.exports = {\n  presets: [], // 这里可以引入其他preset\n  plugins: [\"./plugin\"],\n};\n```\n8. 修改babel.config.js为\n```js\nmodule.exports={\n    presets:[require(\"./preset\")]\n}\n```\n9. 执行npm run build即可\n\n### 命名\n上面我们讲了plugin和preset, 并开发了插件, 但是我们的名字是随便定义的, plugin.js和preset.js, 而我们想要发到npm上,我们该怎么命名呢?\n\n1. 如果配置文件中这样写: plugins: [\"./plugin\"], 相当于是./ 开头相对路径,babel默认不会处理,需要自己上面那种引入\n2. 如果配置文件中这样写: plugins: [\"aa\"],babel会解析成 babel-plugin-aa,所以node_module名字应该叫babel-plugin-aa\n3. 如果配置文件中这样写: plugins: [\"@scope/aa\"],babel会解析成 @scope/babel-plugin-aa,所以node_module名字应该叫@scope/babel-plugin-aa\n4. 如果配置文件中这样写: plugins: [\"@babel/aa\"],babel会解析成 @babel/plugin-aa,所以node_module名字应该叫@babel/plugin-aa\n\n\n\n---\n\n\n\n> [简单介绍下各种 JavaScript 解析器](https://www.h5w3.com/85419.html)\n> [手把手带你入门 AST 抽象语法树](https://juejin.cn/post/6844904035271573511)\n> [babel](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md)\n> [Babel的工作原理及实现一个插件](https://blog.csdn.net/Pentoncos/article/details/114627658)\n> [Babel的原理](https://www.jianshu.com/p/eb3428512eb2)","categories":["ast"]}]