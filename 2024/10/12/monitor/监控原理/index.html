<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>监控原理 | ypf的博客</title><meta name="author" content="ypf"><meta name="copyright" content="ypf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="搭建上报框架我们定义一个基本上报框架结构: 12345678910111213141516171819202122232425262728293031323334&amp;#x2F;&amp;#x2F; https:&amp;#x2F;&amp;#x2F;www.npmjs.com&amp;#x2F;package&amp;#x2F;user-agentconst userAgent &amp;#x3D; require("><link rel="shortcut icon" href="/ypf-blog/img/favicon.png"><link rel="canonical" href="https://mystylemylife.github.io/ypf-blog/2024/10/12/monitor/%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mystylemylife/ypf-blog/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.staticfile.net/font-awesome/6.7.1/css/all.min.css"><script>const GLOBAL_CONFIG = {
  root: '/ypf-blog/',
  algolia: undefined,
  localSearch: {"path":"/ypf-blog/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"监控原理",isPost:!0,isHome:!1,isHighlightShrink:void 0,isToc:!0,postUpdate:"2024-12-02 10:52:40"}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mystylemylife/ypf-blog/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mystylemylife/ypf-blog/assets/css/atom-one-dark.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAABhdJREFUeF7tnW9MlmUUxg+ELHGtTEWCRmt+sD9SCYrYIGtJpmkuR0NMIh2mgIEaBEaJaAhCooOAbBQGtgHhWolbm9CXam0xy3IUNSotczkSRHOrJtBulnPo8/g+HN4X33O47i984Dn3fa7r957z3Hvu94/PrIXPDhCGWgd8AFgt20FhAKybLwAr5wvAAKzdAeX6cA8GYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoGYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoGYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoGYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoGYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoG4OvngK+vL5VvzyR//3GWSXxx5Bi9U/+RRxNMevoJio58wHKNjs4TtGvvfo+uP9LJvbqC/cf50eH6CgoYf6OlzoGBAUrK2Erfdx4fqQ+W8dOn3UF1Zfnk4+Nj+f8j33bQupxCj6ztrkm9GrAROTcijMq2Z9rq7T7bSwtWpLvLjyHzfPxeGU2aeLPl3H//8y/FLk8j89ebh9cDNuaV5m2gmDkzbX1sPNhCJVV1bvU5c91Kin8y1nbODXml9HnbN25d0xOTiQDspFXHp+TSL7/+7haP7gwNoYaqAtvW3PpZG+XseMMta3l6EhGAjQlREWGDGy67cbqrmxYnbXSLX4fq9lDgpImWc507f4FiE9ZTf3+/W9by9CRiABsjXt+SQfOiwm092dfYTBX73h+RZ+mr4ykxbpHtpm7Vpm3U/sPPI1pjNINFAXbVqvv7B+ip5Cw69UcXy8PQkCBqeqvItjV74l7PSnQYQaIAD7bq8BlU/lqWrcTfTp2mZckvDcOCy5d+WLOLgqdOtox15y2AlRwzSBxgo7Pk1XR6eG6ErWTTpk27Hs5Ym7iMkhOWWoaYzhD3fDaZF4+0IRKwn98N1NpQafsApK+vj5Y89yJ1nelxxCM4aAp9UF1Cvr7WDzQq322imoaDjubytotEAnbSqjuPn6SE1FxHfh+oLqbQ4KmW1w5nHkeLjfJFYgEbn4pfSadHHrRv1ebhh9kYXWusil9CqUlxlpdcvNhHixIzqKf3/Chjcd9yogG7atUG0IIVL9C5vy5YOjb51lvoUO0e29acv7uamg9/6j63r8NMogEbvyJn3ksVBfa75i+/bqe03GJLa/eXbyNzoGA1vjrWQWuzvfsgwcnrRTxgI7Lo5fX0aPRsW71rsgroaPuPQ/6/eH405W1aYxkj5SBhzAA2rbqlvoImBIy31Hymp5cef+byiZM5fjTHkObBidWQcpAwZgAbobPvv4cqC7NtNb9Ze4De/v/NAaVbN1KMzSG+pIOEMQXYiC3cnEbzYyJtd8RmwxUSNIVqy/Itr5F2kDDmALtq1W1Hv6PbgwPptsCrH0ead4dIO0gYc4CN4Fn33U1VRTlOtA+5pqm5lXZW1g47ztsDVOyirzR5R04qxT40x7H3Ug8SnAhUCdi8G7OloYJumhDg0gPJBwkuxWn+5bPwsLto787NLj2QfJDgUpxmwEZ8QXYKPTYvytaHn06cpOUpzg4knJjpjdeobNGXjDat+pPGSssHIOZIceFK2QcJTl5QqgEbA2p2b6EZ06dd5cWf3WcHAWsfAKycMAADsGwH0KKV/8Q7AAOw7BblInvcg1XjJf2/AI4WjRatuobRolXjRYtWjheAAVi6A9hkYZMl/TV8zfyxyVKNF/dg5XgBGIClO2A+7WA+9XDlMN/jsXS1/bf2SNd9KX/192AtoLg6AJjrnJA4ABYCipsmAHOdExIHwEJAcdMEYK5zQuIAWAgobpoAzHVOSBwACwHFTROAuc4JiQNgIaC4aQIw1zkhcQAsBBQ3TQDmOickDoCFgOKmCcBc54TEAbAQUNw0AZjrnJA4ABYCipsmAHOdExIHwEJAcdMEYK5zQuIAWAgobpoAzHVOSBwACwHFTROAuc4JiQNgIaC4aQIw1zkhcQAsBBQ3TQDmOickDoCFgOKmCcBc54TEAbAQUNw0AZjrnJA4ABYCipsmAHOdExIHwEJAcdMEYK5zQuIAWAgobpr/AdetiMf12lDxAAAAAElFTkSuQmCC" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/ypf-blog/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/ypf-blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/ypf-blog/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ypf-blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> gwy</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/ypf-blog/categories/gwy/LFTT/"><span>LFTT</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/ypf-blog/" title="ypf的博客"><span class="site-name">ypf的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ypf-blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> gwy</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/ypf-blog/categories/gwy/LFTT/"><span>LFTT</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">监控原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-12T09:15:47.798Z" title="发表于 2024-10-12 17:15:47">2024-10-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-02T02:52:40.162Z" title="更新于 2024-12-02 10:52:40">2024-12-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/ypf-blog/categories/monitor/">monitor</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="搭建上报框架"><a href="#搭建上报框架" class="headerlink" title="搭建上报框架"></a>搭建上报框架</h1><p>我们定义一个基本上报框架结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// https://www.npmjs.com/package/user-agent</span><br><span class="hljs-keyword">const</span> userAgent = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;user-agent&quot;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExtraData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">userAgent</span>: userAgent.<span class="hljs-title function_">parse</span>(navigator.<span class="hljs-property">userAgent</span>), <span class="hljs-comment">// 浏览器信息</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>, <span class="hljs-comment">// 当前页面url</span><br>    <span class="hljs-attr">title</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>, <span class="hljs-comment">// 页面标题</span><br>    <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(), <span class="hljs-comment">// 时间戳</span><br>  &#125;;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SendTracker</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 上报接口地址</span><br>  &#125;<br>  <span class="hljs-title function_">send</span>(<span class="hljs-params">log = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = &#123;<br>      ...<span class="hljs-title function_">getExtraData</span>(),<br>      ...log,<br>    &#125;;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data, <span class="hljs-string">&quot;上报&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendImg</span>(data)<br>  &#125;<br>  <span class="hljs-title function_">sendImg</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>    img.<span class="hljs-property">src</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> + <span class="hljs-string">&quot;?d=&quot;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data);<br>    img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// console.log(&quot;img onload&quot;);</span><br>    &#125;;<br>    img.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;img onerror&quot;</span>);<br>    &#125;;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendTracker</span>();<br></code></pre></td></tr></table></figure><h1 id="监控错误"><a href="#监控错误" class="headerlink" title="监控错误"></a>监控错误</h1><h2 id="js执行错误-资源加载错误"><a href="#js执行错误-资源加载错误" class="headerlink" title="js执行错误+资源加载错误"></a>js执行错误+资源加载错误</h2><h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰:"></a>举个🌰:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;showError(&#x27;js&#x27;)&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>js<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> // js执行错误<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/a.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  // 资源加载错误 <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showError</span>(<span class="hljs-params">type</span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">test</span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;</span><br><span class="language-javascript">  <span class="hljs-comment">// 或者主动抛出错误</span></span><br><span class="language-javascript">  <span class="hljs-comment">// throw new Error(&#x27;js error&#x27;)</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js执行错误<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/2.jpg" width="100%"><br>资源加载错误<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/3.jpg" width="100%"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听全局未捕获的错误</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastEvent = <span class="hljs-title function_">getLastEvent</span>(); <span class="hljs-comment">// 最后一个交互事件</span><br>  <span class="hljs-keyword">let</span> errorType=<span class="hljs-string">&#x27;jsError&#x27;</span><br>  <span class="hljs-keyword">if</span>(e.<span class="hljs-property">target</span> &amp;&amp; (e.<span class="hljs-property">target</span>.<span class="hljs-property">src</span> || e.<span class="hljs-property">target</span>.<span class="hljs-property">href</span>))&#123; <span class="hljs-comment">// 说明是资源加载错误</span><br>    lastEvent=e<br>    errorType=<span class="hljs-string">&#x27;resourceError&#x27;</span><br>  &#125; <br>  <span class="hljs-keyword">let</span> log = &#123;<br>    <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;stability&quot;</span>, <span class="hljs-comment">// 监控指标大类</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-comment">// 监控指标小类</span><br>    errorType, <span class="hljs-comment">// 错误类型-全局未捕获的错误</span><br>    <span class="hljs-attr">message</span>: e.<span class="hljs-property">message</span>, <span class="hljs-comment">// 报错信息</span><br>    <span class="hljs-attr">filename</span>: e.<span class="hljs-property">filename</span>, <span class="hljs-comment">// 错误文件</span><br>    <span class="hljs-attr">position</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;e.lineno&#125;</span>:<span class="hljs-subst">$&#123;e.colno&#125;</span>`</span>, <span class="hljs-comment">// 错误行列</span><br>    <span class="hljs-comment">// 处理前: &quot;TypeError: Cannot set properties of undefined (setting &#x27;a&#x27;)\n    at showError (http://localhost:9000/:15:30)\n    at HTMLButtonElement.onclick (http://localhost:9000/:9:39)&quot;</span><br>    <span class="hljs-attr">stack</span>: e.<span class="hljs-property">error</span>&amp;&amp;e.<span class="hljs-property">error</span>.<span class="hljs-property">stack</span>?<span class="hljs-title function_">formatStack</span>(e.<span class="hljs-property">error</span>.<span class="hljs-property">stack</span>):<span class="hljs-literal">null</span>, <span class="hljs-comment">// 错误堆栈</span><br>    <span class="hljs-attr">selector</span>: lastEvent ? <span class="hljs-title function_">getSelector</span>(lastEvent) : <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">//  最后一个交互事件对应的元素</span><br>  &#125;;<br>  tracker.<span class="hljs-title function_">send</span>(log)<br>&#125;,<span class="hljs-literal">true</span>); <span class="hljs-comment">// true代表在捕获阶段调用,false代表在冒泡阶段捕获,使用true或false都可以</span><br></code></pre></td></tr></table></figure><p>主要核心点:</p><ul><li>格式化堆栈信息,<strong>formatStack</strong></li><li>获取用户操作哪个dom节点报的错,<strong>getSelector(lastEvent)</strong></li></ul><h3 id="formatStack"><a href="#formatStack" class="headerlink" title="formatStack"></a>formatStack</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 格式化堆栈信息</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatStack</span>(<span class="hljs-params">stack</span>) &#123;<br>  <span class="hljs-keyword">return</span> stack<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>    .<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 删除message,已经有e.message属性了</span><br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s+at\s+/g</span>, <span class="hljs-string">&quot;&quot;</span>))<br>    .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;^&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lastEvent"><a href="#lastEvent" class="headerlink" title="lastEvent"></a>lastEvent</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> lastEvent;<br>[<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;touchstart&quot;</span>, <span class="hljs-string">&quot;keydown&quot;</span>, <span class="hljs-string">&quot;mousedown&quot;</span>, <span class="hljs-string">&quot;mouseover&quot;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">  eventType</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<br>    eventType,<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      lastEvent = e;<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//捕获阶段获取</span><br>      <span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//true: 不阻止默认事件</span><br>      <span class="hljs-comment">//   once: false, //事件是否只执行一次</span><br>    &#125;<br>  );<br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> lastEvent;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要原理就是监听常见用户操作,获取event</p><h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// https://segmentfault.com/a/1190000043414306</span><br><span class="hljs-comment">// 获取真实dom数组</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">composedPath</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 当前有直接return</span><br>  <span class="hljs-keyword">let</span> pathArr = e.<span class="hljs-property">path</span> || (e.<span class="hljs-property">composedPath</span> &amp;&amp; e.<span class="hljs-title function_">composedPath</span>()); <span class="hljs-comment">// 优先判断 Event.composedPath() 方法是否为空数组</span><br>  <span class="hljs-keyword">if</span> ((pathArr || []).<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">return</span> pathArr;<br>  &#125;<br>  <span class="hljs-comment">// 不存在则遍历target节点</span><br>  <span class="hljs-keyword">let</span> target = e.<span class="hljs-property">target</span>;<br>  e.<span class="hljs-property">path</span> = [];<br>  <span class="hljs-keyword">while</span> (target.<span class="hljs-property">parentNode</span> !== <span class="hljs-literal">null</span>) &#123;<br>    e.<span class="hljs-property">path</span>.<span class="hljs-title function_">push</span>(target);<br>    target = target.<span class="hljs-property">parentNode</span>;<br>  &#125;<br>  <span class="hljs-comment">// 最后在add进去 document 与 window对象</span><br>  e.<span class="hljs-property">path</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">document</span>, <span class="hljs-variable language_">window</span>);<br>  <span class="hljs-keyword">return</span> e.<span class="hljs-property">path</span>;<br>&#125;;<br><span class="hljs-comment">// 格式化成字符串</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSelector</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">const</span> path = <span class="hljs-title function_">composedPath</span>(event);<br>  <span class="hljs-keyword">return</span> path<br>    .<span class="hljs-title function_">reverse</span>()<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> el !== <span class="hljs-variable language_">document</span> &amp;&amp; el !== <span class="hljs-variable language_">window</span>; <span class="hljs-comment">// 去除document 和 window</span><br>    &#125;)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> selector = <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">id</span>) &#123;<br>        selector = <span class="hljs-string">`#<span class="hljs-subst">$&#123;el.id&#125;</span>`</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.<span class="hljs-property">className</span>) &#123;<br>        selector = el.<span class="hljs-property">className</span><br>          .<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)<br>          .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> <span class="hljs-string">`.<span class="hljs-subst">$&#123;c&#125;</span>`</span>)<br>          .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        selector = el.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> selector;<br>    &#125;)<br>    .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>e.path谷歌已经移除, e.composedPath()有的浏览器没有该属性,不是标准方法</li><li>我们通过e.target一层层网上找parentNode存数组里面</li><li>最后将el数组通过<code>getSelector</code>格式化成字符串</li></ul><p>e.composedPath()以及自己实现composedPath函数的打印结果如下图:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/1.jpg" width="50%"></p><h2 id="promise错误"><a href="#promise错误" class="headerlink" title="promise错误"></a>promise错误</h2><h3 id="举个🌰-1"><a href="#举个🌰-1" class="headerlink" title="举个🌰:"></a>举个🌰:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;showError(&#x27;promise&#x27;)&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;promise a&quot;</span>&gt;</span>promise<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">showError</span>(<span class="hljs-params">type</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">         <span class="hljs-variable language_">window</span>.<span class="hljs-property">test</span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;</span><br><span class="language-javascript">          <span class="hljs-comment">// 或者主动抛出错误</span></span><br><span class="language-javascript">          <span class="hljs-comment">// reject(&quot;error&quot;); </span></span><br><span class="language-javascript">          <span class="hljs-comment">// reject(&#123;</span></span><br><span class="language-javascript">          <span class="hljs-comment">//     a:1</span></span><br><span class="language-javascript">          <span class="hljs-comment">// &#125;) // 注意, reject对象,e.message是undefined,其他信息都有, 所以reject最后抛出字符串</span></span><br><span class="language-javascript">      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">      <span class="hljs-comment">// 注意,如果加上catch,上面不会被捕获,因为已经catch了</span></span><br><span class="language-javascript">      <span class="hljs-comment">// .catch(()=&gt;&#123;&#125;)</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/4.jpg" width="100%"><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听promise错误(如果有catch不会触发下面函数, 没有catch才会触发)</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;unhandledrejection&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastEvent = <span class="hljs-title function_">getLastEvent</span>(); <span class="hljs-comment">// 最后一个交互事件</span><br>  <span class="hljs-keyword">let</span> message;<br>  <span class="hljs-keyword">let</span> lineno;<br>  <span class="hljs-keyword">let</span> colno;<br>  <span class="hljs-keyword">let</span> filename;<br>  <span class="hljs-keyword">let</span> stack;<br>  <span class="hljs-keyword">const</span> reason = e.<span class="hljs-property">reason</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reason === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    message = reason;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reason === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    message = reason.<span class="hljs-property">message</span>;<br>    <span class="hljs-comment">// &quot;TypeError: Cannot set properties of undefined (setting &#x27;a&#x27;)\n    at http://localhost:9000/:18:34\n    at new Promise (&lt;anonymous&gt;)\n    at showError (http://localhost:9000/:17:18)\n    at HTMLButtonElement.onclick (http://localhost:9000/:10:44)&quot;</span><br>    <span class="hljs-keyword">if</span> (reason.<span class="hljs-property">stack</span>) &#123;<br>      <span class="hljs-keyword">const</span> matchResult= reason.<span class="hljs-property">stack</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/at\s+(.+):(\d+):(\d+)/</span>);<br>      filename = matchResult[<span class="hljs-number">1</span>];<br>      lineno = matchResult[<span class="hljs-number">2</span>];<br>      colno = matchResult[<span class="hljs-number">3</span>];<br>      stack = <span class="hljs-title function_">formatStack</span>(reason.<span class="hljs-property">stack</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> log=&#123;<br>    <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;stability&quot;</span>, <span class="hljs-comment">// 监控指标大类</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-comment">// 监控指标小类</span><br>    <span class="hljs-attr">errorType</span>: <span class="hljs-string">&quot;promiseError&quot;</span>, <span class="hljs-comment">// 错误类型-全局未捕获的错误</span><br>    message, <span class="hljs-comment">// 报错信息</span><br>    filename, <span class="hljs-comment">// 错误文件</span><br>    <span class="hljs-attr">position</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;lineno&#125;</span>:<span class="hljs-subst">$&#123;colno&#125;</span>`</span>, <span class="hljs-comment">// 错误行列</span><br>    <span class="hljs-comment">// &quot;TypeError: Cannot set properties of undefined (setting &#x27;a&#x27;)\n    at showError (http://localhost:9000/:15:30)\n    at HTMLButtonElement.onclick (http://localhost:9000/:9:39)&quot;</span><br>    stack, <span class="hljs-comment">// 错误堆栈</span><br>    <span class="hljs-attr">selector</span>: lastEvent ? <span class="hljs-title function_">getSelector</span>(lastEvent) : <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">//  最后一个交互事件对应的元素</span><br>  &#125;<br>  tracker.<span class="hljs-title function_">send</span>(log)<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>只要加catch就不会触发unhandledrejection</li><li>reject最好传字符串, 传其他e.meesage是undefined</li></ul><h2 id="XHR请求"><a href="#XHR请求" class="headerlink" title="XHR请求"></a>XHR请求</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectXhr</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-title class_">XMLHttpRequest</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">XMLHttpRequest</span>;<br>  <span class="hljs-keyword">let</span> oldOpen = <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">open</span>;<br>  <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">open</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">method, url, <span class="hljs-keyword">async</span></span>) &#123;<br>    <span class="hljs-comment">// 过滤掉上报日志的接口, 要不就死循环了</span><br>    <span class="hljs-keyword">if</span> (!url.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/dig.gif/</span>)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logData</span> = &#123;<br>        method,<br>        url,<br>        <span class="hljs-keyword">async</span>,<br>      &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> oldOpen.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>  &#125;;<br>  <span class="hljs-keyword">let</span> oldSend = <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">send</span>;<br>  <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">send</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">body</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">logData</span>) &#123;<br>      <span class="hljs-keyword">let</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 开始请求时间</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">type</span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> duration = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime; <span class="hljs-comment">// 请求耗时</span><br>          <span class="hljs-keyword">let</span> status = <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span>; <span class="hljs-comment">// 状态码 如 200 404 500</span><br>          <span class="hljs-keyword">let</span> statusText = <span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>; <span class="hljs-comment">// 状态码对应的文本 如 &quot;OK&quot; &quot;Not Found&quot; &quot;Internal Server Error&quot;</span><br>          <span class="hljs-keyword">const</span> log = &#123;<br>            <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;stability&quot;</span>, <span class="hljs-comment">// 监控指标大类</span><br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;xhr&quot;</span>, <span class="hljs-comment">// 小类</span><br>            <span class="hljs-attr">xhrType</span>: type, <span class="hljs-comment">// 请求类型 如 load error abort</span><br>            <span class="hljs-attr">apiUrl</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">logData</span>.<span class="hljs-property">url</span>, <span class="hljs-comment">// 请求路径</span><br>            <span class="hljs-attr">status</span>: status + <span class="hljs-string">&quot;-&quot;</span> + statusText, <span class="hljs-comment">// 状态码 - 状态码文本</span><br>            duration, <span class="hljs-comment">// 请求耗时</span><br>            <span class="hljs-attr">reqData</span>: body || <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 请求参数</span><br>            <span class="hljs-attr">resData</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span> ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>) : <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 响应数据</span><br>          &#125;;<br>          tracker.<span class="hljs-title function_">send</span>(log);<br>        &#125;;<br>      &#125;;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-title function_">handler</span>(<span class="hljs-string">&quot;load&quot;</span>), <span class="hljs-literal">false</span>); <span class="hljs-comment">// 监听请求完成(包含成功、失败),比如失败500</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-title function_">handler</span>(<span class="hljs-string">&quot;error&quot;</span>), <span class="hljs-literal">false</span>); <span class="hljs-comment">// 监听请求失败</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;abort&quot;</span>, <span class="hljs-title function_">handler</span>(<span class="hljs-string">&quot;abort&quot;</span>), <span class="hljs-literal">false</span>); <span class="hljs-comment">// 监听请求中断</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> oldSend.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重写xhr的open、send方法, 复制旧的, XMLHttpRequest.prototype.open=自己的, 里面加逻辑后,调用旧的执行,通过apply传入所有参数</li><li>监听load、error、abort事件计算请求耗时</li><li>请求耗时计算: 在send中记录开始时间, 在请求结束(上面3个事件)用当时时间-开始时间即可.</li></ul><p><strong>fetch拦截类似,也是重写fetch方法</strong></p><h2 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h2><p>所谓白屏,就是页面啥都没有,相当于只有body(注意:骨架屏不算白屏, 算有内容)</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">blankScreen</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> wrapperElArr = [<span class="hljs-string">&quot;html&quot;</span>, <span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-string">&quot;#app&quot;</span>]; <span class="hljs-comment">// 容器元素</span><br>  <span class="hljs-keyword">let</span> emptyPoint = <span class="hljs-number">0</span>; <span class="hljs-comment">// 空白点个数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSelector</span>(<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">let</span> selector = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (el.<span class="hljs-property">id</span>) &#123;<br>      selector = <span class="hljs-string">`#<span class="hljs-subst">$&#123;el.id&#125;</span>`</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.<span class="hljs-property">className</span>) &#123;<br>      selector = el.<span class="hljs-property">className</span><br>        .<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> <span class="hljs-string">`.<span class="hljs-subst">$&#123;c&#125;</span>`</span>)<br>        .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      selector = el.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> selector;<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isWrapper</span>(<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">let</span> selecter = <span class="hljs-title function_">getSelector</span>(el);<br>    <span class="hljs-keyword">if</span> (wrapperElArr.<span class="hljs-title function_">indexOf</span>(selecter) &gt; -<span class="hljs-number">1</span>) &#123;<br>      emptyPoint++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 执行blankScreen问题, 因为js放到head执行,dom肯定没有,所以需要onload执行</span><br>  <span class="hljs-title function_">onload</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; total; i++) &#123;<br>      <span class="hljs-keyword">const</span> total=<span class="hljs-number">20</span> <span class="hljs-comment">// 每条轴采样点个数</span><br>      <span class="hljs-keyword">const</span> xElements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">elementsFromPoint</span>(<br>        (<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / total) * i,<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> / <span class="hljs-number">2</span><br>      );<br>      <span class="hljs-keyword">const</span> yElements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">elementsFromPoint</span>(<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-number">2</span>,<br>        (<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> / total) * i<br>      );<br>      <span class="hljs-comment">//   左45度 (因为只有x、y)有时候不是白屏,仍会当成白屏. 比如就屏幕前1/3高度有元素, x检测不到, y轴的9个点都刚好在行内元素行上,就当成body了</span><br>      <span class="hljs-keyword">const</span> xElements45 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">elementsFromPoint</span>(<br>        (<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / total) * i,<br>        (<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> / total) * i<br>      );<br>      <span class="hljs-title function_">isWrapper</span>(xElements[<span class="hljs-number">0</span>]);<br>      <span class="hljs-title function_">isWrapper</span>(yElements[<span class="hljs-number">0</span>]);<br>      <span class="hljs-title function_">isWrapper</span>(xElements45[<span class="hljs-number">0</span>]);<br>    &#125;<br>   <span class="hljs-keyword">if</span> (emptyPoint &gt;= (total-<span class="hljs-number">1</span>)*<span class="hljs-number">3</span>) &#123; <span class="hljs-comment">// 所以上面3条轴,采样点总共57个点</span><br>      <span class="hljs-keyword">let</span> centerEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">elementsFromPoint</span>(<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-number">2</span>,<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> / <span class="hljs-number">2</span><br>      );<br>      tracker.<span class="hljs-title function_">send</span>(&#123;<br>        <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;stability&quot;</span>, <span class="hljs-comment">// 监控指标大类</span><br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;blank&quot;</span>, <span class="hljs-comment">// 小类</span><br>        emptyPoint, <span class="hljs-comment">// 空白点个数</span><br>        <span class="hljs-attr">screen</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;*&quot;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">height</span>,<br>        <span class="hljs-attr">viewpoint</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> + <span class="hljs-string">&quot;*&quot;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>,<br>        <span class="hljs-attr">selector</span>: <span class="hljs-title function_">getSelector</span>(centerEl[<span class="hljs-number">0</span>]), <span class="hljs-comment">// 中心点</span><br>      &#125;);<br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">onload</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">readyState</span> === <span class="hljs-string">&quot;complete&quot;</span>) &#123;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">callback</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>document.elementsFromPoint(x,y)</code>用来获取执行位置的元素</li><li>我们通过取样屏幕中心x、y轴,各取9个点,判断这18个点,如果是容器元素,说明是白屏.</li><li>因为js放到head执行,获取dom采样点肯定没有,所以需要onload执行</li><li>上面采样用的横竖2条中心轴,但是存在(比如就屏幕前1/3高度有元素是行内元素, x检测不到, y轴检测不到,就当成body了),所以上面加了个左45度</li><li>白屏的指标也统计了屏幕分辨率<code>window.screen.width + &quot;*&quot; + window.screen.height</code></li><li>白屏的指标也统计了文档即视口分辨率 <code>window.innerWidth + &quot;*&quot; + window.innerHeight</code></li></ul><p>我们把html的dom注释掉看看效果<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/5.jpg" width="100%"></p><h1 id="监控性能指标-耗时"><a href="#监控性能指标-耗时" class="headerlink" title="监控性能指标(耗时)"></a>监控性能指标(耗时)</h1><p>做性能分析，不管是在本地，还是通过工具，最重要的是要有数据支撑。目前，w3c 对性能相关数据,已经有了详尽的分类标准. 下图就来自于 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/navigation-timing/">w3c</a><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/performance-0.png" width="100%"><br>这个加载过程模型，是<a target="_blank" rel="noopener" href="https://www.w3.org/webperf/">web 性能工作组</a> 早在 2012 年就针对页面加载过程制定的，定义了从上一个页面结束，到下一个页面从开始加载到完成加载的整个过程。基于这个模型，我们可以获取到页面加载过程中各个阶段的耗时情况，然后分析出页面加载性能。</p><h2 id="加载阶段描述"><a href="#加载阶段描述" class="headerlink" title="加载阶段描述"></a>加载阶段描述</h2><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>navigationStart</td><td>用户完成卸载前一个文档的时间点。</td></tr><tr><td>redirectStart</td><td>重定向开始时间。如果页面没有重定向，该值为0。</td></tr><tr><td>redirectEnd</td><td>重定向结束时间(表示<strong>最后一次</strong>重定向)。如果页面没有重定向，该值为0。</td></tr></tbody></table><h3 id="请求阶段"><a href="#请求阶段" class="headerlink" title="请求阶段"></a>请求阶段</h3><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>fetchStart</td><td>浏览器开始请求页面的时刻。</td></tr><tr><td>domainLookupStart</td><td>查询DNS的开始时刻。如果请求没有发起DNS请求，如keep-alive、缓存等，则返回fetchStart的时间点。</td></tr><tr><td>domainLookupEnd</td><td>查询DNS的结束时刻。如果没有发起DNS请求，如keep-alive、缓存等，则返回fetchStart的时间点。</td></tr><tr><td>connectStart</td><td>当浏览器开始与服务器连接时的时刻。如果没有建立连接，如请求是keep-alive、缓存等，那么它的值等同于domainLookupEnd。</td></tr><tr><td>secureConnectionStart</td><td>如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0。</td></tr><tr><td>connectEnd</td><td>当浏览器端完成与服务器端建立连接的时刻。如果没有建立连接，如请求是keep-alive、缓存等，那么它的值等同于domainLookupEnd。</td></tr><tr><td>requestStart</td><td>浏览器开始向服务器发送 HTTP 请求数据包时刻。</td></tr><tr><td>responseStart</td><td>指浏览器收到从服务器（或缓存、本地资源）响应回的第一个字节的数据的时刻。</td></tr><tr><td>responseEnd</td><td>指浏览器收到从服务器端（或缓存、本地资源）响应回的最后一个字节的数据的时刻。</td></tr></tbody></table><h3 id="解析渲染阶段"><a href="#解析渲染阶段" class="headerlink" title="解析渲染阶段"></a>解析渲染阶段</h3><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>domLoading</td><td>浏览器即将开始解析第一批收到的 HTML 文档字节(即 Document.readyState 属性变为 loading，相应的 readystatechange 事件触发时)。</td></tr><tr><td>domInteractive</td><td>浏览器完成DOM解析的时间点,准备开始加载内嵌资源(比如外链css、js等)的时间点。(即 Document.readyState 的属性为 interactive，相应的 readystatechange 事件触发时.时间上和 DOMContentLoaded 同时发生，不过顺序在它之前.)</td></tr><tr><td>domContentLoaded</td><td>在 html 文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都执行完毕后触发，也就是jQuery中的 $(document).ready事件. 但图片、video、audio、flash、iframe资源尚未加载</td></tr><tr><td>domComplete</td><td>所有处理完成，并且网页上的所有资源（图像等）都已下载完毕，也就是说，加载转环已停止旋转, 表示网页及其所有子资源都准备就绪的时间点。即 Document.readyState 变为 complete 且相应的 readystatechange 事件被触发时</td></tr><tr><td>loadEventStart</td><td>作为每个网页加载的最后一步，浏览器会触发 onload 事件，以便触发额外的应用逻辑。</td></tr><tr><td>loadEventEnd</td><td>onload 事件 执行完成。 许多 JavaScript 框架都会等待onload事件发生后，才开始执行它们自己的逻辑。因此，浏览器会捕获 loadEventStart 和 loadEventEnd 时间戳来追踪执行所花费的时间。</td></tr></tbody></table><h4 id="document-readyState"><a href="#document-readyState" class="headerlink" title="document.readyState"></a>document.readyState</h4><p>该属性描述了文档的加载状态，发生变化时，会在 document 对象上触发 readystatechange 事件。有3种状态：</p><ul><li>loading 正在加载</li><li>interactive 文档已被解析，loading 状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载，会在 document 和 window 对象上触发 DOMContentLoaded 事件。</li><li>complete 所有资源完成加载，会在 window 对象上触发 load 事件。<h4 id="浏览器页面渲染过程"><a href="#浏览器页面渲染过程" class="headerlink" title="浏览器页面渲染过程"></a>浏览器页面渲染过程</h4></li></ul><ol><li>浏览器与服务器建立 TCP 连接发送 HTTP 请求，获取 HTML 文档并开始从上到下解析，构建 DOM。</li><li>在构建 DOM 过程中：</li></ol><ul><li><p>如果遇到外联的 css 文件，下载文件并执行构建 CSSOM，此过程不影响 DOM 构建，但在完成之前会阻止页面渲染。</p></li><li><p>如果遇到外联的 js 文件，则暂停构建 DOM，</p></li><li><p>若在这之前的 css 文件已加载完毕且 CSSOM 构建完成，则合并已经构建好的 DOM 与 CSSOM 并渲染到页面上</p></li><li><p>之后等 js 文件下载并执行后，然后继续构建后边的 DOM。</p></li></ul><ol start="3"><li>完成文档解析后，将 DOM 和 CSSOM 进行关联和映射，生成 Render Tree 渲染页面。</li><li>当所有同步的 js 代码执行完毕后，会在 document 和 window 对象上触发 DOMContentLoaded 事件，此时对应 document.readyState === ‘interactive’。</li><li>当所有资源完成加载后，会在 window 对象上触发 load 事件，此时对应 document.readyState === ‘complete’。</li></ol><h2 id="各阶段计算公式"><a href="#各阶段计算公式" class="headerlink" title="各阶段计算公式"></a>各阶段计算公式</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/performance-1.png" width="100%"><p>经过上面各个字段的说明，可以清晰得出以下公式。</p><table><thead><tr><th>事件</th><th>计算公式</th><th>描述</th></tr></thead><tbody><tr><td>Redirect</td><td>redirectEnd - redirectStart</td><td>重定向耗时</td></tr><tr><td>AppCache</td><td>domainLookupStart - fetchStart</td><td>浏览器缓存耗时(比如静态资源缓存)</td></tr><tr><td>DNS</td><td>domainLookupEnd - domainLookupStart</td><td>DNS解析耗时</td></tr><tr><td>TCP</td><td>connectEnd - connectStart</td><td>TCP连接耗时</td></tr><tr><td>SSL</td><td>connectEnd - secureConnectionStart</td><td>SSL耗时 (TCP包含SSL)</td></tr><tr><td><strong>TTFB</strong></td><td>responseStart - navigationStart</td><td>首字节到达时间(time to first byte,浏览器从服务器接收到第一个字节的时间,起点选择navigationStart 是为了和web-vitals规范保持一致,也可以用fetchStart)</td></tr><tr><td>Response</td><td>responseEnd - responseStart</td><td>响应完成耗时</td></tr><tr><td>DomParse</td><td>domInteractive - domLoading</td><td>Dom解析完成耗时(即 DOM 树构建完成的时长)</td></tr><tr><td>DomReady</td><td>domContentLoaded - domLoading</td><td>Dom挂载完成总耗时,即domContentLoaded</td></tr><tr><td>resourceLoad</td><td>loadEventStart - domContentLoaded</td><td>资源加载耗时,<strong>可观察资源流是否过大</strong></td></tr><tr><td>DomProcessing</td><td>domComplete - domLoading</td><td>整个dom进程的总耗时</td></tr><tr><td>onLoad</td><td>loadEventEnd - loadEventStart</td><td>onload 事件执行耗时</td></tr><tr><td>Load</td><td>loadEventEnd - navigationStart</td><td>页面完全加载总时间</td></tr></tbody></table><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/performance-2.png" width="80%"> 通过下面代码可以计算上面指标<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> timing =<br>     (performance.<span class="hljs-property">getEntriesByType</span> &amp;&amp;<br>       performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">&quot;navigation&quot;</span>)[<span class="hljs-number">0</span>]) ||<br>     performance.<span class="hljs-property">timing</span>; <span class="hljs-comment">// 官方显示performance.timing属性已经弃用，但是实测最新浏览器仍支持</span><br></code></pre></td></tr></table></figure><h2 id="用户体验指标-耗时"><a href="#用户体验指标-耗时" class="headerlink" title="用户体验指标(耗时)"></a>用户体验指标(耗时)</h2><h3 id="页面何时开始渲染-FP"><a href="#页面何时开始渲染-FP" class="headerlink" title="页面何时开始渲染(FP)"></a>页面何时开始渲染(FP)</h3><ul><li>FP, first paint, 表示页面第一个像素点绘制时刻,一般认为该指标是白屏时间. 比如body背景色. FCP是有第一个dom渲染.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">performance.<span class="hljs-title function_">getEntries</span>().<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;first-paint&#x27;</span>)[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 获取 FP 时间</span><br><span class="hljs-comment">// 也可以通过 performanceObserver 的方式获取</span><br><span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">list, obj</span>) &#123;<br>    <span class="hljs-keyword">var</span> entries = list.<span class="hljs-title function_">getEntries</span>();<br>    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (item.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;first-paint&#x27;</span>) &#123;<br>            ...<br>        &#125;<br>        <span class="hljs-keyword">if</span> (item.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;first-contentful-paint&#x27;</span>) &#123;<br>            ...<br>        &#125;<br>    &#125;)<br>&#125;);<br>observer.<span class="hljs-title function_">observe</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;paint&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="页面何时渲染内容-FCP、LCP、FMP、SI"><a href="#页面何时渲染内容-FCP、LCP、FMP、SI" class="headerlink" title="页面何时渲染内容(FCP、LCP、FMP、SI)"></a>页面何时渲染内容(FCP、LCP、FMP、SI)</h3></li><li>FCP, first contentful paint, 首次内容绘制时间，表示第一个dom渲染到浏览器的时间,比如文本、图片、视频等。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">performance.<span class="hljs-title function_">getEntries</span>().<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;first-contentful-paint&#x27;</span>)[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 获取 FCP 时间</span><br></code></pre></td></tr></table></figure></li><li>LCP, largest contentful paint, 最大内容绘制时间，表示浏览器将最大的内容渲染到屏幕的时间，和 FMP 类似，但只聚焦页面首次加载时最大元素的绘制时间点<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">entryList</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entryList.<span class="hljs-title function_">getEntries</span>()) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LCP candidate:&#x27;</span>, entry.<span class="hljs-property">startTime</span>, entry);<br>    &#125;<br>&#125;).<span class="hljs-title function_">observe</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;largest-contentful-paint&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure></li><li>FMP, first meaningful paint, 首次有意义内容绘制时间. (已经<strong>废弃</strong>的性能指标,因为该指标的定义依赖于特定于浏览器的实现细节，这意味着它不能标准化,所以官方并没有提供有效的获取 FMP 的接口,无法计算)</li><li>SI, speed index, 速度指标, lighthouse 面板中的六大指标之一，用于衡量页面加载期间内容的绘制速度，值越小约好.SI 和 FMP 一样，官方也没有提供有效的获取接口，只能通过 lighthouse 面板来查看，不作为 Sentry 等工具做性能分析的指标。<h3 id="页面何时可以交互-TTI、TBT"><a href="#页面何时可以交互-TTI、TBT" class="headerlink" title="页面何时可以交互(TTI、TBT)"></a>页面何时可以交互(TTI、TBT)</h3></li><li>TTI, time to ineractive, 可交互时间， lighthouse 面板中的六大指标之一, 用于测量页面从开始加载到主要资源完成渲染，并能够快速、可靠地响应用户输入所需的时间, 值越小约好.<br>和 FMP、SI 一样，官方并没有提供获取 TTI 的有效接口，只能通过 lighthouse 面板来查看，不会作为日志平台来进行性能分析的指标。</li><li>TBT, total blocking time，总的阻塞时间， lighthouse 面板中的六大指标之一，用于测量 FCP 到 TTI 之间的总的阻塞时间，值越小约好。官方资料: <a target="_blank" rel="noopener" href="https://web.dev/lighthouse-total-blocking-time/">TBT</a>。<br>和 TTI 一样，官方也没有提供获取 TBT 的有效接口，只能通过 lighthouse 面板来查看，不会作为 Sentry 做性能分析的指标。<h3 id="交互是否有延迟-FID"><a href="#交互是否有延迟-FID" class="headerlink" title="交互是否有延迟(FID)"></a>交互是否有延迟(FID)</h3></li><li>FID，first input delay, 首次输入延迟，测量从用户第一次与页面交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对交互作出响应所经过的时间.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">entryList</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entryList.<span class="hljs-title function_">getEntries</span>()) &#123;<br>    <span class="hljs-keyword">const</span> delay = entry.<span class="hljs-property">processingStart</span> - entry.<span class="hljs-property">startTime</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;FID candidate:&#x27;</span>, delay, entry);<br>  &#125;<br>&#125;).<span class="hljs-title function_">observe</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;first-input&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="页面视觉是否流畅-CLS"><a href="#页面视觉是否流畅-CLS" class="headerlink" title="页面视觉是否流畅(CLS)"></a>页面视觉是否流畅(CLS)</h3></li><li>CLS, cumulative layout shift, 累计布局偏移(视觉不稳定/流畅性)，测量页面在加载过程中，元素位置在屏幕上的移动程度，值越大，页面视觉不流畅。<br>解释下:我们在浏览网页时可能会遇到这样的情况：当我们正聚精会神地阅读网页内容时，突然发现内容在没有任何预警的情况下被挤到了另一个位置。更糟糕的是，当您准备点击一个链接或按钮时，正巧在手指按下的瞬间，链接突然移位，导致您误点到其他内容。通常情况下，这样的网站会给用户带来极差的体验，甚至瞬间的位移错误交互可能造成一定程度的破坏。<br>通常，页面元素发生意外偏移的原因包括异步资源加载以及在 DOM 元素上方动态插入新的元素等。具体而言，这些偏移可能源于图片或视频元素尺寸未设置、不受控的第三方广告引入或者小组件自身大小的动态调整。<br>因此，我们需要一个指标来度量意外偏移对用户“视觉稳定性”产生的影响。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>) &#123;<br>    <span class="hljs-keyword">var</span> perfEntries = list.<span class="hljs-title function_">getEntries</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; perfEntries.<span class="hljs-property">length</span>; i++) &#123;<br>        ...<br>    &#125;<br>&#125;)<span class="hljs-title function_">observe</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;layout-shift&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure>所以:</li><li>不要在现有内容之上插入内容，除非是为了响应用户交互。</li><li>多用 transform animations，而不是触发布局变化的animations properties。</li><li>在图片和视频元素中包含大小属性，或者用 CSS 长宽比框之类的东西保留所需的空间。<br>具体实现可以参考 <a target="_blank" rel="noopener" href="https://wukongdoc.tingyun.com/browser/metric/CLS.html">https://wukongdoc.tingyun.com/browser/metric/CLS.html</a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li><li>如果是本地通过 lighthouse 进行性能分析，会使用 6 大指标: FCP、LCP、SI、TTI、TBT、CLS。这些指标涵盖了页面渲染、交互和视觉稳定性情况。</li><li>如果是通过 Sentry 等工具进行性能分析，会使用 4 大指标: FCP、LCP、FID、CLS。这些指标也涵盖了页面渲染、交互、视觉稳定性情况。之所以选这四个指标，原因想必大家也知道，就是这四个指标的数据可以通过 performanceObserver 获取。</li></ul><h1 id="监控业务business"><a href="#监控业务business" class="headerlink" title="监控业务business"></a>监控业务business</h1><h2 id="pv、uv"><a href="#pv、uv" class="headerlink" title="pv、uv"></a>pv、uv</h2><ul><li>pv: 展示统计周期内页面访问量，即用户访问页面的总次数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pv</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> connection = navigator.<span class="hljs-property">connection</span>;<br>  tracker.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;business&quot;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;pv&quot;</span>,<br>    <span class="hljs-attr">effectiveType</span>: connection.<span class="hljs-property">effectiveType</span>, <span class="hljs-comment">//网络环境</span><br>    <span class="hljs-attr">rtt</span>: connection.<span class="hljs-property">rtt</span>, <span class="hljs-comment">//往返时间</span><br>    <span class="hljs-attr">screen</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">window</span>.screen.width&#125;</span>x<span class="hljs-subst">$&#123;<span class="hljs-variable language_">window</span>.screen.height&#125;</span>`</span>, <span class="hljs-comment">//设备分辨率</span><br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意,如果是vue的hash变化,需要监听<code>window.addeventlistener(“hashchange”,()=&gt;()</code>事件,再次调用pv统计</strong><br>uv: 展示统计周期内指定页面用户访问次数。<br>一般通过服务器端来统计.如某一天,某个页面用户访问量(一般根据token来判断)</p><h2 id="页面停留时间"><a href="#页面停留时间" class="headerlink" title="页面停留时间"></a>页面停留时间</h2><ul><li><p>页面停留时间，即用户在页面停留的时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">stay</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-comment">// 在页面卸载时发送页面停留事件</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<br>    <span class="hljs-string">&quot;beforeunload&quot;</span>,<br>    <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// event.returnValue = &#x27;你确定要离开这个页面吗？&#x27;; // 设置returnValue属性以显示提示信息</span><br>      <span class="hljs-keyword">let</span> stayTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime;<br>      tracker.<span class="hljs-title function_">send</span>(&#123;<br>        <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;business&quot;</span>,<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;stayTime&quot;</span>,<br>        stayTime,<br>      &#125;);<br>    &#125;,<br>    <span class="hljs-literal">false</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="长任务-页面卡顿"><a href="#长任务-页面卡顿" class="headerlink" title="长任务(页面卡顿)"></a>长任务(页面卡顿)</h2><p>如果一个任务在主线程上运行超过 50 毫秒，那么它就是 Long task。我们根据该指标可以观测某段js运行的时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可以理解为异步执行</span><br><span class="hljs-comment"> * requestIdleCallback 是浏览器空闲时会自动执行内部函数</span><br><span class="hljs-comment"> * requestAnimationFrame 是浏览器必须执行的</span><br><span class="hljs-comment"> * 关于 requestIdleCallback 和  requestAnimationFrame 可以参考 https://www.cnblogs.com/cangqinglang/p/13877078.html</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">longTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> &#123;<br>    list.<span class="hljs-title function_">getEntries</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">duration</span> &gt; <span class="hljs-number">100</span>) &#123;<br>        <span class="hljs-keyword">let</span> lastEvent = <span class="hljs-title function_">getLastEvent</span>();<br>        <span class="hljs-title function_">requestIdleCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          tracker.<span class="hljs-title function_">send</span>(&#123;<br>            <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;experience&quot;</span>,<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;longTask&quot;</span>,<br>            <span class="hljs-attr">eventType</span>: lastEvent.<span class="hljs-property">type</span>,<br>            <span class="hljs-attr">startTime</span>: <span class="hljs-title function_">formatTime</span>(entry.<span class="hljs-property">startTime</span>), <span class="hljs-comment">// 开始时间</span><br>            <span class="hljs-attr">duration</span>: <span class="hljs-title function_">formatTime</span>(entry.<span class="hljs-property">duration</span>), <span class="hljs-comment">// 持续时间</span><br>            <span class="hljs-attr">selector</span>: lastEvent<br>              ? <span class="hljs-title function_">getSelector</span>(lastEvent)<br>              : <span class="hljs-string">&quot;&quot;</span>,<br>          &#125;);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;).<span class="hljs-title function_">observe</span>(&#123; <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">&quot;longtask&quot;</span>] &#125;);<br></code></pre></td></tr></table></figure><h1 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h1><p>由于报错是<strong>压缩代码的行列</strong>,所以我们需要映射文件解析源代码.<br>一般来讲，线上产物中会把 SourceMap 去除，除了为了加速构建过程，更重要的是避免有开发经验的人直接在浏览器中「阅读源码」。现在需要sourceMap来定位到源代码:</p></li><li><p>webpack配置<code>source-map</code>, 打包后将sourceMap传到某个私有的地址（如 CDN 或 OSS）,此时日志平台可以获取私有地址上传的sourceMap做映射.但是谷歌控制台能否看到源码错误,有以下几种方案:</p><ul><li>不删除map文件, 不安全,谷歌控制台直接可以看到源码.</li><li>打包完使用<code>rimraf包</code>删除掉map文件.谷歌控制台不可以看到源码.因为sourceMappingURL指向的是和js同级路径,找不到了. 此时可以使用charles转发sourceMappingURL到私有云即可.</li><li>不删除map文件, 但打包的时候将<code>sourceMappingURL</code>改为上传的地址.服务端控制外部不能访问到sourcemap,内部才能访问. 这样连接内网,谷歌控制台才可以直接看到源代码,外网不可见.<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/6.png" width="50%"></li><li>不删除map文件,也不修改<code>sourceMappingURL</code>,服务端控制外部不能访问到map后缀文件,内部才能访问. 这样连接内网,谷歌控制台才可以直接看到源代码,外网不可见.</li></ul></li><li><p>webpack配置<code>hidden-source-map</code>, 因为没有<code>sourceMappingURL</code>，所以不用删除.谷歌控制台不可以看到源码.</p><ul><li>我们可以通过时间谷歌插件添加<code>Http Header：sourcemap</code>来实现. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/674981525">如何在线上使用 SourceMap</a></li><li>也可以在控制台一个一个添加sourcemap来看源代码, 但是不推荐, 因为每次都得手动添加.并且刷新一下就得重新添加.</li></ul></li></ul><h2 id="实现sourceMap转换源代码"><a href="#实现sourceMap转换源代码" class="headerlink" title="实现sourceMap转换源代码"></a>实现sourceMap转换源代码</h2><p>原理: 调用<code>source-map包</code>通过 map文件代码+压缩文件代码的报错<code>行、列转化为</code>源代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sourceMap = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;source-map&quot;</span>);<br><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getSource</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">sourcemap, line, column</span>) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> consumer = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> sourceMap.<span class="hljs-title class_">SourceMapConsumer</span>(<br>      <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(sourcemap)<br>    );<br>    <span class="hljs-keyword">const</span> originalInfo = consumer.<span class="hljs-title function_">originalPositionFor</span>(&#123; line, column &#125;); <span class="hljs-comment">// 获取源代码信息(注意行列需要为number类型, 字符串类型会报错)</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalInfo);<br>    <span class="hljs-keyword">const</span> originFileContent = consumer.<span class="hljs-title function_">sourceContentFor</span>(originalInfo.<span class="hljs-property">source</span>); <span class="hljs-comment">// 获取源代码整个文件内容</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      originFileContent,<br>      <span class="hljs-attr">line</span>: originalInfo.<span class="hljs-property">line</span>,<br>      <span class="hljs-attr">column</span>: originalInfo.<span class="hljs-property">column</span>,<br>      <span class="hljs-attr">originFileName</span>: originalInfo.<span class="hljs-property">source</span>,<br>    &#125;;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    <span class="hljs-comment">// ElMessage.error(&quot;sourcemap解析失败&quot;);</span><br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> sourceFileUrl = <span class="hljs-string">&quot;../dist/js/app.72b4fccd.js.map&quot;</span>;<br><span class="hljs-keyword">const</span> sourceFileContentStr = fs.<span class="hljs-title function_">readFileSync</span>(sourceFileUrl, <span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-title function_">getSource</span>(sourceFileContentStr, <span class="hljs-number">1</span>, <span class="hljs-number">6040</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">origin</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(origin) <span class="hljs-comment">// 源代码,这里包含整个报错文件的源代码</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="只展示6行报错"><a href="#只展示6行报错" class="headerlink" title="只展示6行报错"></a>只展示6行报错</h2><p>一般我们展示, 只展示6行报错(前2行、报错行高亮、后2行),所以我们对上面的代码进行格式化</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;preLine(origin)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">preLine</span>(<span class="hljs-params">origin</span>) &#123;<br>  <span class="hljs-keyword">const</span> line = origin.<span class="hljs-property">line</span>;  <span class="hljs-comment">// 错误的行号</span><br>  <span class="hljs-comment">// 先获取源码有多少行</span><br>  <span class="hljs-keyword">const</span> originCodeLine = origin?.<span class="hljs-property">originFileContent</span>?.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  <span class="hljs-keyword">const</span> len = originCodeLine.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> start = line - <span class="hljs-number">3</span> &gt;= <span class="hljs-number">0</span> ? line - <span class="hljs-number">3</span> : <span class="hljs-number">0</span>; <br>  <span class="hljs-keyword">const</span> end = start + <span class="hljs-number">5</span> &gt;= len ? len : start + <span class="hljs-number">5</span>; <span class="hljs-comment">// 最多展示6行</span><br>  <span class="hljs-keyword">let</span> newLines = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start; i &lt;= end; i++) &#123;<br>    <span class="hljs-keyword">const</span> content = i + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;.    &quot;</span> + <span class="hljs-title function_">encodeHTML</span>(originCodeLine[i]);<br>    newLines.<span class="hljs-title function_">push</span>(<br>      <span class="hljs-string">`&lt;div class=&#x27;code-line <span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">        i + <span class="hljs-number">1</span> == line ? <span class="hljs-string">&quot;hightlight&quot;</span> : <span class="hljs-string">&quot;&quot;</span> // 高亮错误行</span></span><br><span class="hljs-subst"><span class="hljs-string">      &#125;</span>&#x27;&gt;<span class="hljs-subst">$&#123;content&#125;</span>&lt;/div&gt;`</span><br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> newLines.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">encodeHTML</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!str || str.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">return</span> str<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&quot;&amp;#38;&quot;</span>)<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&quot;&amp;lt;&quot;</span>)<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&quot;&amp;gt;&quot;</span>)<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&#x27;/g</span>, <span class="hljs-string">&quot;&amp;#39;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h1><ol><li>JavaScript方式: 我们可以打包成一个js文件,放到html最上面(必须置于其它脚本之前),否则嵌码JS前面的数据获取不到。</li><li>npm方式: 因为是在main.js引入, 所以有些资源加载错误无法捕获到.</li></ol><h1 id="上报方式"><a href="#上报方式" class="headerlink" title="上报方式"></a>上报方式</h1><h2 id="sendBeacon"><a href="#sendBeacon" class="headerlink" title="sendBeacon"></a>sendBeacon</h2><p>Navigator.sendBeacon 是一个用于发送少量数据到服务器的 API.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> res=navigator.<span class="hljs-title function_">sendBeacon</span>(url, data); <span class="hljs-comment">// data可以是 `ArrayBufferView` 或`Blob`, `DOMString即String` 或者`FormData`类型的数据。</span><br><span class="hljs-comment">// res 返回一个 Boolean值，如果返回 true，则表示数据已经放入队列并且在将来某个时间点会进行传输。</span><br><span class="hljs-comment">// 如果返回 false，则表示数据无法放入队列，可能因为队列已满或者网络问题。</span><br></code></pre></td></tr></table></figure><ul><li>sendBeacon 方法的设计目标是确保数据在页面卸载时能够可靠地发送。浏览器会在后台继续尝试发送数据，即使页面已经关闭或正在导航到新页面</li><li>发送是post请求, 是异步的，但不返回任何信息给调用者，无法处理服务器的响应。只能判断出是否放入浏览器任务队列，不能判断是否发送成功。</li><li>非阻塞的，不会阻碍页面的卸载过程</li><li>也会有跨域问题,除非服务器设置了适当的 CORS 头。</li><li>一般上报不超过64k</li><li>一般浏览器都支持, ie不支持,谷歌版本&gt;=39</li></ul><p>我们测试<code>navigator.sendBeacon(&#39;http://localhost:3000/log&#39;, &#39;test&#39;)</code>, 在控制台可以看到<code>ResourceType为ping</code>,但是看到请求头和正常post接口没任何区别,仍是post请求。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/7.jpg" width="100%"></p><h2 id="xhr上报"><a href="#xhr上报" class="headerlink" title="xhr上报"></a>xhr上报</h2><ul><li>这种方法有一个问题，就是在页面卸载或刷新时进行上报的话，请求可能会在浏览器关闭或重新加载前还未发送至服务端就被浏览器 cancel 掉，导致数据上报失败。</li><li>可以将 ajax 请求改为同步方法，这样就能保证请求一定能发送到服务端. 但是同步就会阻塞页面关闭或重新加载的过程，这样就会影响用户体验。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">syncReport</span> = (<span class="hljs-params">url, &#123; data = &#123;&#125;, headers = &#123;&#125; &#125; = &#123;&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, url, <span class="hljs-literal">false</span>); <span class="hljs-comment">// false表示同步请求(不异步)</span><br>  xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(headers).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(key, headers[key]);<br>  &#125;);<br>  xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="img上报"><a href="#img上报" class="headerlink" title="img上报"></a>img上报</h2><ul><li>我们可以通过在 beforeunload 事件处理器中创建一个图片元素并设置它的 src 属性的方法来延迟卸载以保证数据的发送，因为绝大多数浏览器会延迟卸载以保证图片的载入(load事件)，所以数据可以在卸载事件中发送。不过beforeunload在移动端貌似不兼容,不会触发.</li><li>日志接口域名最好和当前页面域名不一致,因为浏览器对同一个域名的最大并发连接数为6个，如果日志同时上报了6次以上，就会对同域名的业务造成影响；更坏的情况如页面有一些错误、网络连接质量质量不高会让日志上报阻碍页面渲染.所以日志上报可以像使用CDN服务一样，使用单独域名和日志处理服务.(不同域名,最好在head头增加dns-prefetch预解析)</li><li>因为使用img,所以支持跨域,不过是get方法, 最长字符一般是2000个字符,一个英文字符占一个字节Byte,汉字占2字节. 1kb=1024字节Byte,所以一般不建议超过2kb</li><li>使用图片,就是浏览器禁止script,也不影响请求</li></ul><h2 id="gif图片上报"><a href="#gif图片上报" class="headerlink" title="gif图片上报"></a>gif图片上报</h2><ul><li>gif图片部署在nginx上,就能记录到请求的信息. 然后定时任务去读取nginx日志(比如<strong>每分钟拉一次</strong>),存入数据库.可以对数据进行清洗(格式化)</li><li>nginx的图片采用1X1的透明图,相比较于jpg，gif图更小，合法的 GIF 只需要 43 个字节.</li><li>和上面image不同的是,这个是通过nginx的日志来处理.(官方测试Nginx能够支持5万并发链接,实际生产环境中可以支撑2-4万并发连接数).而上面的是通过image的get请求发接口而已.</li></ul><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><h2 id="上报方式-1"><a href="#上报方式-1" class="headerlink" title="上报方式"></a>上报方式</h2><p>优雅降级<br>sendBeacon &gt; image &gt; xhr<br>判断如果浏览器支持sendBeacon,且上报数据小于64k(sendBeacon最大支持64k),使用sendBeacon上报(但是只能post接口). 注意还需要根据res判断是否加入队列成功.<br>否则判断上报数据 &lt; 2k, 使用image上报(get请求最多2000字符).<br>否则使用xhr上报.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断对象是否超过指定kb大小</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> object 源对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> limitInKB 最大kb</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isObjectOverSizeLimit</span>(<span class="hljs-params"></span><br><span class="hljs-params">  object: object,</span><br><span class="hljs-params">  limitInKB: number</span><br><span class="hljs-params"></span>): boolean &#123;<br>  <span class="hljs-keyword">const</span> serializedObject = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(object)<br>  <span class="hljs-keyword">const</span> sizeInBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>().<span class="hljs-title function_">encode</span>(serializedObject).<span class="hljs-property">length</span><br>  <span class="hljs-keyword">const</span> sizeInKB = sizeInBytes / <span class="hljs-number">1024</span><br>  <span class="hljs-keyword">return</span> sizeInKB &gt; limitInKB<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="上报频率"><a href="#上报频率" class="headerlink" title="上报频率"></a>上报频率</h2><ul><li>pv: 就是上报一次, 所以我们不需要上报频率.</li><li>性能监控:onload完, 上报一次, 所以我们不需要上报频率.(最好onload完加个1s的延时,因为onload完不加延时,有时performance获取的fp、fcp都可能获取不到)</li><li>错误监控: 每次调用上报方法的时候,先塞入数组中,去重,然后setTimeout(比如3s)上报.这相当于把多次合并为一次上报，以降低对服务器的压力。<br>如何对同一个错误去重? 我们可以根据错误信息、错误文件、行、列、页面url组合一起做为唯一标识进行去重.</li><li>接口错误: 不去重.</li><li>静态资源监控: 上报一次, 所以我们不需要上报频率.</li></ul><h2 id="sourceMap-1"><a href="#sourceMap-1" class="headerlink" title="sourceMap"></a>sourceMap</h2><ul><li>项目打包的时候同时将sourcemap打包到上传服务器, 做一个监控页面, 通过接口获取报错行列、报错文件.map,然后渲染源代码.</li><li>不做多版本sourcemap,因为sourcemap每次打包都是新的, 老的报错如果渲染过源代码就存下来.</li></ul><h1 id="vue错误上报"><a href="#vue错误上报" class="headerlink" title="vue错误上报"></a>vue错误上报</h1><p><code>window.addEventListener(&quot;error&quot;,()=&gt;&#123;&#125;)</code>只能监听js的错误, vue的错误是组件的错误, 监听不到, 需要vue提供的方法处理.<br>测试了下:</p><ul><li>vue普通代码报错(template和jsx): addEventListener监听不到, vue的errorHandler可以监听到</li><li>vue Promise代码报错(template和jsx): unhandledrejection可以监听到, vue的errorHandler不能监听到</li><li>main.js代码报错(普通和promise), addEventListener和unhandledrejection可以监听到, vue的errorHandler不能监听到</li></ul><p><strong>所以使用vue的errorHandler</strong></p><ul><li>可以捕获error捕获不到的vue错误,其他错误原生js可以正常捕获.</li><li>vue的errorHandler方法,返回的error对象, 信息只有message、stack.但第三个参数可以知道是钩子的名称, 比如created,mounted等.如下图<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/8.jpg" width="100%"></li></ul><h2 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">err, vm, info</span>) &#123;<br>  <span class="hljs-title function_">send</span>(err) <span class="hljs-comment">// 上报错误信息</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br>app.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">err, vm, info</span>) &#123;<br>   <span class="hljs-title function_">send</span>(err) <span class="hljs-comment">// 上报错误信息</span><br>&#125;;<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p><a target="_blank" rel="noopener" href="https://m-cheng-web.github.io/web-tracing/guide/spotlight">web-tracing</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7108660942686126093?searchId=202411211542117B97BF46B14987073FA1">腾讯三面：说说前端监控平台/监控SDK的架构设计和难点亮点</a><br><a target="_blank" rel="noopener" href="https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/">DOM 和 CSSOM</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021713604">浅谈浏览器页面渲染过程 load 与 DOMContentLoaded 事件</a><br><a target="_blank" rel="noopener" href="https://wukongdoc.tingyun.com/browser/metric/timing.html?q=">听云</a><br><a target="_blank" rel="noopener" href="https://wukongdoc.tingyun.com/browser/introduce/principle.html?h=navigation">听云</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6973567030528065573">使用 Performance API 获取页面性能</a><br><a target="_blank" rel="noopener" href="https://blog.itpub.net/70024924/viewspace-2992688/">页面CLS 优化实践</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7148364027817623589#heading-7">使用 Sentry 做性能监控 - 原理篇</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6908506976674807815#heading-5">前端异常上报</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63358859/article/details/139849910">使用sendBeacon进行前端数据上报</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mystylemylife.github.io/ypf-blog">ypf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mystylemylife.github.io/ypf-blog/2024/10/12/monitor/%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86/">https://mystylemylife.github.io/ypf-blog/2024/10/12/monitor/%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mystylemylife.github.io/ypf-blog" target="_blank">ypf的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/ypf-blog/2024/12/02/webpack4/1.%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/" title="1.打包文件分析"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">1.打包文件分析</div></div></a></div><div class="next-post pull-right"><a href="/ypf-blog/2024/10/09/git/git%20rebase%E5%8F%98%E5%9F%BA/" title="git rebase变基"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git rebase变基</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%8A%E6%8A%A5%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">搭建上报框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E9%94%99%E8%AF%AF"><span class="toc-number">2.</span> <span class="toc-text">监控错误</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%94%99%E8%AF%AF"><span class="toc-number">2.1.</span> <span class="toc-text">js执行错误+资源加载错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%F0%9F%8C%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">举个🌰:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#formatStack"><span class="toc-number">2.1.3.</span> <span class="toc-text">formatStack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lastEvent"><span class="toc-number">2.1.4.</span> <span class="toc-text">lastEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selector"><span class="toc-number">2.1.5.</span> <span class="toc-text">selector</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E9%94%99%E8%AF%AF"><span class="toc-number">2.2.</span> <span class="toc-text">promise错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%F0%9F%8C%B0-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">举个🌰:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XHR%E8%AF%B7%E6%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">XHR请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BD%E5%B1%8F"><span class="toc-number">2.4.</span> <span class="toc-text">白屏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-%E8%80%97%E6%97%B6"><span class="toc-number">3.</span> <span class="toc-text">监控性能指标(耗时)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">加载阶段描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text">初始化阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.2.</span> <span class="toc-text">请求阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.3.</span> <span class="toc-text">解析渲染阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#document-readyState"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">document.readyState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">浏览器页面渲染过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E9%98%B6%E6%AE%B5%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">各阶段计算公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E6%8C%87%E6%A0%87-%E8%80%97%E6%97%B6"><span class="toc-number">3.3.</span> <span class="toc-text">用户体验指标(耗时)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E4%BD%95%E6%97%B6%E5%BC%80%E5%A7%8B%E6%B8%B2%E6%9F%93-FP"><span class="toc-number">3.3.1.</span> <span class="toc-text">页面何时开始渲染(FP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E4%BD%95%E6%97%B6%E6%B8%B2%E6%9F%93%E5%86%85%E5%AE%B9-FCP%E3%80%81LCP%E3%80%81FMP%E3%80%81SI"><span class="toc-number">3.3.2.</span> <span class="toc-text">页面何时渲染内容(FCP、LCP、FMP、SI)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E4%BD%95%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%BA%A4%E4%BA%92-TTI%E3%80%81TBT"><span class="toc-number">3.3.3.</span> <span class="toc-text">页面何时可以交互(TTI、TBT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E6%98%AF%E5%90%A6%E6%9C%89%E5%BB%B6%E8%BF%9F-FID"><span class="toc-number">3.3.4.</span> <span class="toc-text">交互是否有延迟(FID)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%A7%86%E8%A7%89%E6%98%AF%E5%90%A6%E6%B5%81%E7%95%85-CLS"><span class="toc-number">3.3.5.</span> <span class="toc-text">页面视觉是否流畅(CLS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%9A%E5%8A%A1business"><span class="toc-number">4.</span> <span class="toc-text">监控业务business</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pv%E3%80%81uv"><span class="toc-number">4.1.</span> <span class="toc-text">pv、uv</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%81%9C%E7%95%99%E6%97%B6%E9%97%B4"><span class="toc-number">4.2.</span> <span class="toc-text">页面停留时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E4%BB%BB%E5%8A%A1-%E9%A1%B5%E9%9D%A2%E5%8D%A1%E9%A1%BF"><span class="toc-number">4.3.</span> <span class="toc-text">长任务(页面卡顿)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sourceMap"><span class="toc-number">5.</span> <span class="toc-text">sourceMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0sourceMap%E8%BD%AC%E6%8D%A2%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">5.1.</span> <span class="toc-text">实现sourceMap转换源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E5%B1%95%E7%A4%BA6%E8%A1%8C%E6%8A%A5%E9%94%99"><span class="toc-number">5.2.</span> <span class="toc-text">只展示6行报错</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">接入方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E6%8A%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">上报方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sendBeacon"><span class="toc-number">7.1.</span> <span class="toc-text">sendBeacon</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xhr%E4%B8%8A%E6%8A%A5"><span class="toc-number">7.2.</span> <span class="toc-text">xhr上报</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#img%E4%B8%8A%E6%8A%A5"><span class="toc-number">7.3.</span> <span class="toc-text">img上报</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gif%E5%9B%BE%E7%89%87%E4%B8%8A%E6%8A%A5"><span class="toc-number">7.4.</span> <span class="toc-text">gif图片上报</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E6%8A%A5%E6%96%B9%E5%BC%8F-1"><span class="toc-number">8.1.</span> <span class="toc-text">上报方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E6%8A%A5%E9%A2%91%E7%8E%87"><span class="toc-number">8.2.</span> <span class="toc-text">上报频率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sourceMap-1"><span class="toc-number">8.3.</span> <span class="toc-text">sourceMap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E9%94%99%E8%AF%AF%E4%B8%8A%E6%8A%A5"><span class="toc-number">9.</span> <span class="toc-text">vue错误上报</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2"><span class="toc-number">9.1.</span> <span class="toc-text">Vue2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3"><span class="toc-number">9.2.</span> <span class="toc-text">Vue3</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By ypf</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@4.13.0/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@4.13.0/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/mystylemylife/ypf-blog/assets/js/code-collapse.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@4.13.0/source/js/search/local-search.min.js"></script></div></div></body></html>