<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>js精度丢失问题 | ypf的博客</title><meta name="author" content="ypf"><meta name="copyright" content="ypf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="问题来源js精度问题大家都不陌生, 比如: 10.1+ 0.2 &amp;#x3D; 0.30000000000000004 &amp;gt; 0.3 那么有没有深究过原理?接下来我们来详细了解下. 前置知识进制进制通俗来讲就是一种表示数量大小的制度（方式），人类创造进制可以说是一项伟大的发明，我们都知道古人计数是通过打绳结"><link rel="shortcut icon" href="/ypf-blog/img/favicon.png"><link rel="canonical" href="https://mystylemylife.github.io/ypf-blog/2025/04/09/javascript/js%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mystylemylife/ypf-blog/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.staticfile.net/font-awesome/6.7.1/css/all.min.css"><script>const GLOBAL_CONFIG = {
  root: '/ypf-blog/',
  algolia: undefined,
  localSearch: {"path":"/ypf-blog/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"js精度丢失问题",isPost:!0,isHome:!1,isHighlightShrink:void 0,isToc:!0,postUpdate:"2025-04-18 16:38:35"}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mystylemylife/ypf-blog/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mystylemylife/ypf-blog/assets/css/atom-one-dark.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAABhdJREFUeF7tnW9MlmUUxg+ELHGtTEWCRmt+sD9SCYrYIGtJpmkuR0NMIh2mgIEaBEaJaAhCooOAbBQGtgHhWolbm9CXam0xy3IUNSotczkSRHOrJtBulnPo8/g+HN4X33O47i984Dn3fa7r957z3Hvu94/PrIXPDhCGWgd8AFgt20FhAKybLwAr5wvAAKzdAeX6cA8GYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoGYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoGYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoGYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoGYOUOKJeHCgZg5Q4ol4cKBmDlDiiXhwoG4OvngK+vL5VvzyR//3GWSXxx5Bi9U/+RRxNMevoJio58wHKNjs4TtGvvfo+uP9LJvbqC/cf50eH6CgoYf6OlzoGBAUrK2Erfdx4fqQ+W8dOn3UF1Zfnk4+Nj+f8j33bQupxCj6ztrkm9GrAROTcijMq2Z9rq7T7bSwtWpLvLjyHzfPxeGU2aeLPl3H//8y/FLk8j89ebh9cDNuaV5m2gmDkzbX1sPNhCJVV1bvU5c91Kin8y1nbODXml9HnbN25d0xOTiQDspFXHp+TSL7/+7haP7gwNoYaqAtvW3PpZG+XseMMta3l6EhGAjQlREWGDGy67cbqrmxYnbXSLX4fq9lDgpImWc507f4FiE9ZTf3+/W9by9CRiABsjXt+SQfOiwm092dfYTBX73h+RZ+mr4ykxbpHtpm7Vpm3U/sPPI1pjNINFAXbVqvv7B+ip5Cw69UcXy8PQkCBqeqvItjV74l7PSnQYQaIAD7bq8BlU/lqWrcTfTp2mZckvDcOCy5d+WLOLgqdOtox15y2AlRwzSBxgo7Pk1XR6eG6ErWTTpk27Hs5Ym7iMkhOWWoaYzhD3fDaZF4+0IRKwn98N1NpQafsApK+vj5Y89yJ1nelxxCM4aAp9UF1Cvr7WDzQq322imoaDjubytotEAnbSqjuPn6SE1FxHfh+oLqbQ4KmW1w5nHkeLjfJFYgEbn4pfSadHHrRv1ebhh9kYXWusil9CqUlxlpdcvNhHixIzqKf3/Chjcd9yogG7atUG0IIVL9C5vy5YOjb51lvoUO0e29acv7uamg9/6j63r8NMogEbvyJn3ksVBfa75i+/bqe03GJLa/eXbyNzoGA1vjrWQWuzvfsgwcnrRTxgI7Lo5fX0aPRsW71rsgroaPuPQ/6/eH405W1aYxkj5SBhzAA2rbqlvoImBIy31Hymp5cef+byiZM5fjTHkObBidWQcpAwZgAbobPvv4cqC7NtNb9Ze4De/v/NAaVbN1KMzSG+pIOEMQXYiC3cnEbzYyJtd8RmwxUSNIVqy/Itr5F2kDDmALtq1W1Hv6PbgwPptsCrH0ead4dIO0gYc4CN4Fn33U1VRTlOtA+5pqm5lXZW1g47ztsDVOyirzR5R04qxT40x7H3Ug8SnAhUCdi8G7OloYJumhDg0gPJBwkuxWn+5bPwsLto787NLj2QfJDgUpxmwEZ8QXYKPTYvytaHn06cpOUpzg4knJjpjdeobNGXjDat+pPGSssHIOZIceFK2QcJTl5QqgEbA2p2b6EZ06dd5cWf3WcHAWsfAKycMAADsGwH0KKV/8Q7AAOw7BblInvcg1XjJf2/AI4WjRatuobRolXjRYtWjheAAVi6A9hkYZMl/TV8zfyxyVKNF/dg5XgBGIClO2A+7WA+9XDlMN/jsXS1/bf2SNd9KX/192AtoLg6AJjrnJA4ABYCipsmAHOdExIHwEJAcdMEYK5zQuIAWAgobpoAzHVOSBwACwHFTROAuc4JiQNgIaC4aQIw1zkhcQAsBBQ3TQDmOickDoCFgOKmCcBc54TEAbAQUNw0AZjrnJA4ABYCipsmAHOdExIHwEJAcdMEYK5zQuIAWAgobpoAzHVOSBwACwHFTROAuc4JiQNgIaC4aQIw1zkhcQAsBBQ3TQDmOickDoCFgOKmCcBc54TEAbAQUNw0AZjrnJA4ABYCipsmAHOdExIHwEJAcdMEYK5zQuIAWAgobpr/AdetiMf12lDxAAAAAElFTkSuQmCC" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/ypf-blog/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/ypf-blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/ypf-blog/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ypf-blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> gwy</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/ypf-blog/categories/gwy/LFTT/"><span>LFTT</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/ypf-blog/" title="ypf的博客"><span class="site-name">ypf的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ypf-blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> gwy</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/ypf-blog/categories/gwy/LFTT/"><span>LFTT</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">js精度丢失问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-09T08:49:09.355Z" title="发表于 2025-04-09 16:49:09">2025-04-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-18T08:38:35.026Z" title="更新于 2025-04-18 16:38:35">2025-04-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/ypf-blog/categories/javascript/">javascript</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>js精度问题大家都不陌生, 比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0.1</span>+ <span class="hljs-number">0.2</span> = <span class="hljs-number">0.30000000000000004</span> &gt; <span class="hljs-number">0.3</span><br></code></pre></td></tr></table></figure><p>那么有没有深究过原理?接下来我们来详细了解下.</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>进制通俗来讲就是一种表示数量大小的制度（方式），人类创造进制可以说是一项伟大的发明，我们都知道古人计数是通过打绳结的方式，如果没有进制的出现，要表示一个很大的数字就会特别的困难.<br>常见的进制有：</p><table><thead><tr><th>进制</th><th>特点</th><th>进位</th></tr></thead><tbody><tr><td>2</td><td>有2个数字符号，即0和1</td><td>满2进1</td></tr><tr><td>8</td><td>有8个数字符号，0、1、2、3、4、5、6、7</td><td>满8进1</td></tr><tr><td>10</td><td>有10个数字符号，0、1、2、3、4、5、6、7、8、9</td><td>满10进1</td></tr><tr><td>16</td><td>有16个数字符号，0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F</td><td>满16进1</td></tr></tbody></table><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="整数十进制转二进制"><a href="#整数十进制转二进制" class="headerlink" title="整数十进制转二进制"></a>整数十进制转二进制</h3><blockquote><p>将十进制的数不断除以2，直到商是0。然后得到每一次的余数<code>逆序</code>排列起来即可。</p></blockquote><p>例如：我们要对十进制的101转为二进制，那么就有：<br>101 / 2 = 50 —— 余1<br>50 / 2 = 25 —— 余0<br>25 / 2 = 12 —— 余1<br>12 / 2 = 6 —— 余0<br>6 / 2 = 3 —— 余0<br>3 / 2 = 1 —— 余1<br>1 / 2 = 0 —— 余1</p><p>余数逆序排列一下得到十进制的101的转为二进制就为<code>1100101</code><br>用js的方式表达就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只能计算整数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">decimalToBinary</span>(<span class="hljs-params">num</span>) &#123; <br>  <span class="hljs-keyword">let</span> binary = <span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-comment">// 余数</span><br>  <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123; <br>    binary = (num % <span class="hljs-number">2</span>) + binary;  <span class="hljs-comment">// 收集余数(倒序 新的余+旧的余数)</span><br>    num = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(num / <span class="hljs-number">2</span>);  <span class="hljs-comment">// 循环计算商</span><br>  &#125; <span class="hljs-keyword">return</span> binary; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>%</code>是取余运算符，返回余数。 <code>/</code>是整除运算符，返回商。</li><li><code>Math.floor()</code>是向下取整，返回小于等于该数的最大整数。 <code>Math.ceil()</code>是向上取整，返回大于等于该数的最小整数。 <code>Math.round()</code>是四舍五入，返回最接近的整数。</li></ul><h3 id="小数十进制转二进制"><a href="#小数十进制转二进制" class="headerlink" title="小数十进制转二进制"></a>小数十进制转二进制</h3><blockquote><p>1.小数点左边按照上面计算<br>2.小数点右边不断乘以2, 然后看得到的值是否&gt;1，如果&gt;1就收集一个1并且减去一个1，&lt;1就收集0，不断循环往复直到得到的是1，然后<code>顺序</code>排列<br>3.最终相连得到二进制</p></blockquote><p>例如：我们要对十进制的<code>101.625</code>转为二进制，小数点右边就有：<br>0.625 x 2 = 1.25 &gt;1 收集 1 减掉1<br>0.25 x 2 = 0.5 &lt;1 收集 0<br>0.5 x 2 = 1 =1 收集 1<br>所以得到小数二进制就是<code>0.101</code>, 然后拼接整数的, 最终结果为<code>1100101.101</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只能计算小数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dec2bin</span>(<span class="hljs-params">decimal , precision = <span class="hljs-number">12</span></span>) &#123; <span class="hljs-comment">// 因为要避免无限循环，所以用一个精度来做限制</span><br>  <span class="hljs-keyword">var</span> binary= <span class="hljs-string">&#x27;.&#x27;</span>;<br>  <span class="hljs-keyword">while</span>(decimal &gt; <span class="hljs-number">0</span> &amp;&amp; precision &gt; <span class="hljs-number">0</span>)&#123;<br>    decimal*=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(decimal &gt;= <span class="hljs-number">1</span>)&#123;<br>      binary+=<span class="hljs-string">&#x27;1&#x27;</span>;<br>      decimal-=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      binary+=<span class="hljs-string">&#x27;0&#x27;</span><br>    &#125;<br>    precision--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> binary<br>&#125;<br><br><span class="hljs-title function_">dec2bin</span>(<span class="hljs-number">0.625</span>)  <span class="hljs-comment">// .101</span><br><span class="hljs-title function_">dec2bin</span>(<span class="hljs-number">0.1</span>)    <span class="hljs-comment">// .000110011001</span><br></code></pre></td></tr></table></figure><h3 id="整数二进制转十进制"><a href="#整数二进制转十进制" class="headerlink" title="整数二进制转十进制"></a>整数二进制转十进制</h3><blockquote><p>把二进制的每一位都乘以2的幂次方(从右向左0开始)，然后相加，最后得到十进制的数。</p></blockquote><p>例如：要计算二进制的1100101转为十进制，那么就有：<br>1 * 2^6 + 0 * 2^5 + 1 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 101</p><p>用js的方式表达就是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只能计算整数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">binaryToDecimal</span>(<span class="hljs-params">binary</span>) &#123; <br>  <span class="hljs-keyword">var</span> decimal = <span class="hljs-number">0</span>; <br>  <span class="hljs-keyword">var</span> len = binary.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; len; i++) &#123; <br>    <span class="hljs-keyword">var</span> bit = binary[i]; <br>    decimal += bit*<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,len - i - <span class="hljs-number">1</span>); <br>  &#125; <br>  <span class="hljs-keyword">return</span> decimal; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Math.pow(a,b)</code>是求幂运算符，返回a的b次幂。</li></ul><h3 id="小数二进制转十进制"><a href="#小数二进制转十进制" class="headerlink" title="小数二进制转十进制"></a>小数二进制转十进制</h3><blockquote><p>1.小数点左边按照上面计算<br>2.小数点右边每一位都乘以2的幂次方(从右向左 -1开始)，然后相加，最后得到十进制的数。<br>3.最终相加得到十进制</p></blockquote><p>例如：我们要对二进制的<code>1100101.101</code>转为十进制，小数点右边就有：<br>1 * 2^-1 + 0 * 2^-2 + 1 * 2^-3 = 0.625, 最终加上整数部分101，得到小数十进制为<code>101.625</code></p><h3 id="js原生转换"><a href="#js原生转换" class="headerlink" title="js原生转换"></a>js原生转换</h3><ol><li>10进制转x进制<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">(number).<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 默认10, 可选 2 8 10 16 </span><br><span class="hljs-comment">// 或者</span><br>number..<span class="hljs-title function_">toString</span>()<br>如 (<span class="hljs-number">10</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// &quot;1010&quot;</span><br>   <span class="hljs-number">10.</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// &quot;1010&quot;</span><br></code></pre></td></tr></table></figure>注意: <code>10.toString()</code>会报错, Number没有toString()方法,String才有</li><li>x进制转10进制<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(string, <span class="hljs-number">2</span>) <span class="hljs-comment">// 默认10进制, 可选 2 8 10 16 </span><br>如 <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1010&quot;</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="进制转换总结"><a href="#进制转换总结" class="headerlink" title="进制转换总结"></a>进制转换总结</h2><ul><li>十进制转二进制：<ul><li>整数<code>/2</code>,直到<code>商为0</code>,取<code>余数倒序</code>;</li><li>小数<code>*2</code><ul><li>结果<code>&gt;1收集1</code>,并<code>结果-1</code>继续计算</li><li><code>&lt;1收集0</code>,直至结果<code>=1,收集1</code></li><li>最终<code>正序</code>;</li></ul></li><li>最终整数<code>.</code>小数<code>拼接</code></li></ul></li><li>二进制转十进制：<ul><li>整数*2幂次方,<code>从0</code>开始, 从右向左;</li><li>小数*2幂次方,从<code>-1</code>开始, 从左向右;</li><li>最终整数小数结果<code>相加</code></li></ul></li><li>原生js方法<ul><li>10进制转x进制: <code>(number).toString()</code> 或者 <code>number..toString()</code>, 默认不传参数就是10进制</li><li>x进制转10进制: <code>parseInt(string, 2)</code>, 默认不传参数就是10进制</li></ul></li></ul><h2 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h2><blockquote><p>把一个数表示成a与10的n次幂相乘的形式,其中 1≤|a|&lt;10且不为分数形式，n为整数），这种记数法叫做科学记数法. 如 <code>2001 = 2.001×10^3</code></p></blockquote><p>上面就是科学计数法, 那么为什么已经有进制能方便的表示大数量,为什么还需要科学计数法呢?<br>我们都知道计算机存储数据是需要空间的，假设现在有4个格子，每一个格子可以表示一位数，可以使用任何方式，请问怎么用这4个格子表示最大的数量?</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/1.jpg" width="50%" height="50%"><p>如果用十进制, 很明显<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/2.jpg" width="50%" height="50%"><br>那这样很明显,计算机存储数量太少了, 我们假如指定一个规则, <code>最后一位表示指数,前三位表示基数</code>,此时最大数就变成<code>9.99e9=9990000000</code><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/3.jpg" width="50%" height="50%"><br>我们只是改变了一下计算规则，当基数为10的情况下，能够表示的最大数量就远远超过了刚开始的9999。js中Number类型存储就是使用科学计数法来存储的.</p><h3 id="js原生方法打印指数"><a href="#js原生方法打印指数" class="headerlink" title="js原生方法打印指数"></a>js原生方法打印指数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">2</span>**<span class="hljs-number">11</span>=<span class="hljs-number">2048</span><br><span class="hljs-comment">// 或者</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">11</span>)=<span class="hljs-number">2048</span><br></code></pre></td></tr></table></figure><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><blockquote><p>EEE 754 是浮点数运算的<code>工业标准</code>,由国际电气与电子工程师协会（IEEE）于1985年制定，用于规范计算机中浮点数的表示、运算和舍入方式.它被广泛运用于各种变成语言中(C、JAVA、JAVASCRIPT、PYTHON等).通过<code>二进制科学计数法</code>尽可能表示更大的范围.</p></blockquote><p><font style="font-size:20px">公式:</font><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/4.jpg" width="50%" height="50%"></p><ul><li>符号位(S)：用来表示正负(0为正，1为负)</li><li>指数位(E)：真实指数+偏移量</li><li>尾数位(M)：用来存储小数部分,开头隐含<code>1.</code>（规范化形式）</li></ul><p>常见格式:</p><ol><li>单精度（32位即4字节）： 符号（1） + 指数（8） + 尾数（23）</li><li>双精度（64位即8字节）： 符号（1） + 指数（11） + 尾数（52）</li><li>其他扩展格式（如半精度16位、四精度128位）</li></ol><p>我们从浮点数的定义来看,就是表示<code>带小数点的数</code>.</p><ul><li>在java中,是有整数类型、浮点类型的. 整数就是整数,小数就是浮点数.</li><li>但是js中,没有真正的整数类型,只有number类型,所有数字都是以<code>64位双精度浮点数</code>存储.</li></ul><p>上面可能对有些定义不理解, 如<code>真实指数、偏移量、开头隐含1.</code>等.<br>我们以js为例, 10进制-&gt;二进制-&gt;64位双精度存储, 即要将十进制数 <code>178.125</code> 转换为 <code>IEEE 754 64位浮点数</code>（float64）, 可以按照以下步骤进行：<br><strong>1. 将十进制数转换为二进制</strong><br>将 178 转换为二进制:<br>（1）整数部分（178）</p><figure class="highlight js"><figcaption><span>[toggle]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">178</span> ÷ <span class="hljs-number">2</span> = <span class="hljs-number">89</span> 余 <span class="hljs-number">0</span>  <br><span class="hljs-number">89</span> ÷ <span class="hljs-number">2</span> = <span class="hljs-number">44</span> 余 <span class="hljs-number">1</span>  <br><span class="hljs-number">44</span> ÷ <span class="hljs-number">2</span> = <span class="hljs-number">22</span> 余 <span class="hljs-number">0</span>  <br><span class="hljs-number">22</span> ÷ <span class="hljs-number">2</span> = <span class="hljs-number">11</span> 余 <span class="hljs-number">0</span>  <br><span class="hljs-number">11</span> ÷ <span class="hljs-number">2</span> = <span class="hljs-number">5</span> 余 <span class="hljs-number">1</span>  <br><span class="hljs-number">5</span> ÷ <span class="hljs-number">2</span> = <span class="hljs-number">2</span> 余 <span class="hljs-number">1</span>  <br><span class="hljs-number">2</span> ÷ <span class="hljs-number">2</span> = <span class="hljs-number">1</span> 余 <span class="hljs-number">0</span>  <br><span class="hljs-number">1</span> ÷ <span class="hljs-number">2</span> = <span class="hljs-number">0</span> 余 <span class="hljs-number">1</span>  <br></code></pre></td></tr></table></figure><p>从下往上读取余数，得到 10110010。<br>（2）小数部分（0.125）<br>将 0.125 转换为二进制：</p><figure class="highlight js"><figcaption><span>[toggle]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0.125</span> × <span class="hljs-number">2</span> = <span class="hljs-number">0.25</span> → 取 <span class="hljs-number">0</span>  <br><span class="hljs-number">0.25</span> × <span class="hljs-number">2</span> = <span class="hljs-number">0.5</span> → 取 <span class="hljs-number">0</span>  <br><span class="hljs-number">0.5</span> × <span class="hljs-number">2</span> = <span class="hljs-number">1.0</span> → 取 <span class="hljs-number">1</span>  <br></code></pre></td></tr></table></figure><p>从上往下读取整数部分，得到 001。<br>（3）合并整数和小数部分<br>最终二进制表示为：<code>178.125 → 10110010.001</code></p><p><strong>2. 将二进制数转换为科学计数法</strong><br>将 10110010.001 转换为 <code>1.xxxx × 2ⁿ</code> 形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">10110010.001</span> = <span class="hljs-number">1.0110010001</span> × <span class="hljs-number">2</span>⁷ <span class="hljs-comment">// 7是因为小数点移动了7位</span><br></code></pre></td></tr></table></figure><p>此时:</p><ul><li>有效数: 0110010001 去掉<code>1.</code>,因为 IEEE 754标准隐含存储</li><li>真实指数: 7</li></ul><p><strong>3. 计算 IEEE 754 64位浮点数的各个部分</strong></p><table><thead><tr><th>部分</th><th>位数</th><th>计算方式</th></tr></thead><tbody><tr><td>符号位</td><td>1</td><td>正数 → 0</td></tr><tr><td>指数位</td><td>11</td><td>真实指数 7 + 偏移量 1023 → 7 + 1023 = 1030 → 二进制 10000000110）</td></tr><tr><td>尾数位</td><td>52</td><td>0110010001000000000000000000000000000000000000000000（补零至 52 位）</td></tr></tbody></table><p><strong>4. 合并所有部分</strong></p><table><thead><tr><th>符号位（S）</th><th>指数位（E）</th><th>尾数位（M）</th></tr></thead><tbody><tr><td>0</td><td>10000000110</td><td>0110010001000000000000000000000000000000000000000000</td></tr></tbody></table><p>最终 64 位二进制表示：<br>0 10000000110 0110010001000000000000000000000000000000000000000000</p><h2 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h2><blockquote><p>分为真实指数和存储指数:<br>真实指数的是二进制转换为科学计数法,小数点<code>移动的次数</code>(向左为正,向右为负)<br>但是实际存储中,使用的是 <code>真实指数+偏移量</code>代替指数.</p></blockquote><table><thead><tr><th>十进制数</th><th>二进制</th><th>科学计数法</th><th>小数点移动</th><th>真实指数</th></tr></thead><tbody><tr><td>0.125</td><td>0.001</td><td>1.0 × 2^{-3}</td><td>右移 3 位</td><td>-3</td></tr><tr><td>4.0</td><td>100.0</td><td>1.0 × 2^{2}</td><td>左移 2 位</td><td>+2</td></tr><tr><td>0.5</td><td>0.1</td><td>1.0 × 2^{-1}</td><td>右移 1 位</td><td>-1</td></tr></tbody></table><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><p>上面我们计算的时候使用了偏移量, 是什么意思呢?<br>因为我们上面介绍真实指数有正/负,总共指数位有11位,还得分出1位存储指数符号,浪费空间并增加复杂度.所以引入偏移量代表一个<code>相对值</code>,将真实指数转换为 <code>无符号的存储指数</code>即存储指数始终&gt;=0</p><ul><li>存储时,用<code>真实指数+偏移量</code>代替指数.</li><li>读取时,反向计算用<code>存储指数-偏移量</code>即可.<br>偏移量的计算公式：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Bias</span>=<span class="hljs-number">2</span>^(n−<span class="hljs-number">1</span>)−<span class="hljs-number">1</span> <span class="hljs-comment">// n是指数的位数, 64位双精度规定是11, 实际就是2^11=2048除以2即分一半</span><br></code></pre></td></tr></table></figure>所以,指数范围为<code>-1022</code>到<code>+1023</code> (0 和 2047 有特殊用途）)</li></ul><h2 id="隐含存储1"><a href="#隐含存储1" class="headerlink" title="隐含存储1."></a>隐含存储<code>1.</code></h2><p>因为使用的是规范化的二进制科学计数法,即格式都为:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/4.jpg" width="50%" height="50%"><br>因为无论什么数字,都要变成<code>1.</code>开头的,所以我们</p><ul><li>不存储这个 1(因为它固定存在，存储它浪费空间)</li><li>只存储小数部分，当在计算时 自动补回 1。</li></ul><p>这样做的好处：</p><ul><li>节省 1 bit，使得 尾数（Mantissa） 可以<code>多存储 1 位</code>有效数字</li><li>例如,64位双精度浮点数存储时只存储小数部分共<code>52位</code>,计算时候再补回 1.,这样52位就具备了53位的存储能力</li></ul><h1 id="js浮点数"><a href="#js浮点数" class="headerlink" title="js浮点数"></a>js浮点数</h1><p>上面我们讲了js的number无论正数小数都是用<code>64位双精度浮点数</code>存储的.</p><h2 id="最大-小数"><a href="#最大-小数" class="headerlink" title="最大/小数"></a>最大/小数</h2><ul><li>指数: 范围为[-1022, +1023], 所以最大为<code>2^1023</code>,最小为<code>2^-1022</code></li></ul><p><strong>最大数</strong><br>最大尾数为1.111…(隐含1.),所以<br>最大值为2^1023 * (1 * 2^0 + 1 * 2^-1 + … + 1 * 2^-52)<br>提出2^-52得到 2^1023 * 2^-52 * (2^52 + … + 2^0)<br>得到2^971 * (2^53 - 1) === 1.7976931348623157e+308 === Number.MAX_VALUE</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>) <span class="hljs-comment">//  1.7976931348623157e+308</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) - <span class="hljs-number">1</span>) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">971</span>) === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>超过最大数，会变成Infinity,控制台输入一个超过最大数的数,自动输出 Infinity.</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/8.jpg" width="50%" height="50%"><p><strong>最小数</strong><br>最小尾数,不再隐含 1.（而是0.xxxx…),此时，所以<br>最小值为 2^-1022 * (0 * 2^0 + 0 * 2^-1 + … + 1 * 2^-52)<br>得到2^-1074 === 5e-324 === Number.MIN_VALUE</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>) <span class="hljs-comment">//  5e-324</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, -<span class="hljs-number">1074</span>) === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>超过最小数,会下溢变成0, 控制台输入一个超过最小数的数,自动输出 0.</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/9.jpg" width="50%" height="50%"><blockquote><p>不要小瞧这个数，在可观测的宇宙范围内，整个宇宙的原子数量也才到10^78到10^82之间，所以理论上来说没有什么统计和计算超过Number.MAX_VALUE这个范围了，完全够人类使用了.</p></blockquote><h2 id="最大-最小安全整数"><a href="#最大-最小安全整数" class="headerlink" title="最大/最小安全整数"></a>最大/最小安全整数</h2><p>上面只是Number有能力表示的最大数，而Number可枚举表示的最大整数实际就是尾数的最大值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>) <span class="hljs-comment">//  9007199254740991</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_SAFE_INTEGER</span>); <span class="hljs-comment">// -9007199254740991</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span> === <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) - <span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_SAFE_INTEGER</span> === -<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>即 <code>[-2^53+1, 2^53-1]</code><br>超过<code>MAX_SAFE_INTEGER</code>会发生什么?<br>超出后,js仍然可以显示，但 可能会丢失精度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> maxSafe = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(maxSafe + <span class="hljs-number">1</span>); <span class="hljs-comment">// 9007199254740992（仍然正确）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(maxSafe + <span class="hljs-number">2</span>); <span class="hljs-comment">// 9007199254740992（错误，应该是 9007199254740993）</span><br></code></pre></td></tr></table></figure><p>如何检测一个数是否超出安全范围?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>(<span class="hljs-number">9007199254740991</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>(<span class="hljs-number">9007199254740992</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h1 id="精度丢失过程"><a href="#精度丢失过程" class="headerlink" title="精度丢失过程"></a>精度丢失过程</h1><p>上面我们知道js的number是64位双精度浮点数并通过二进制指数存储的,所以我们通过<code>0.1+0.2</code>解释下:<br><strong>0.1</strong><br>1.转2进制<br>0.1 * 2 // 整数部分0, 小数部分 0.2<br>0.2 * 2 // 整数部分0, 小数部分 0.4<br>0.4 * 2 // 整数部分0, 小数部分 0.8<br>0.8 * 2 // 整数部分1, 小数部分 0.6 // 标记M1<br>0.6 * 2 // 整数部分1, 小数部分 0.2<br>0.2 * 2 // 整数部分0, 小数部分 0.4<br>0.4 * 2 // 整数部分0, 小数部分 0.8<br>0.8 * 2 // 整数部分1, 小数部分 0.6 // 又回到M1<br>所以他会导致无限循环计算, 0.000110011xxxx(0011循环), 当使用二进制科学计数法存储时,尾数只有52位,所以要截取(<code>0舍1入</code>,即最后一位是0舍去,是1进位),就导致丢失精度.<br>2. 转为二进制科学计数法</p><ul><li>符号位: 0</li><li>计算偏移指数位: 小数点向右移动4位, 所以-4 + 1023 = 1019 -&gt; 1111111011, 因为是11位,要往前补0,得到01111111011</li><li>尾数位:1.10011xxxxx, 去掉隐含1.不用存储,总共52位<br>最终结果位<code>0 01111111011 10011xxxxx</code></li></ul><p><strong>0.2</strong><br>1.转2进制<br>0.2 * 2 // 整数部分0, 小数部分 0.4<br>0.4 * 2 // 整数部分0, 小数部分 0.8<br>0.8 * 2 // 整数部分1, 小数部分 0.6 // 标记M1<br>0.6 * 2 // 整数部分1, 小数部分 0.2<br>0.2 * 2 // 整数部分0, 小数部分 0.4<br>0.4 * 2 // 整数部分0, 小数部分 0.8<br>0.8 * 2 // 整数部分1, 小数部分 0.6 // 又回到M1<br>所以也会无限循环,转二进制同上.</p><p><strong>所以:</strong></p><ul><li>精度丢失的本质,就是转二进制时无限循环,因为计算机存储是用二进制指数存储(1个符号位、 11位指数、52位尾数),所以要截取52位(此时已经精度丢失),导致计算的时候再次精度丢失,无法计算准确的结果.</li><li>精度丢失分为小数精度丢失</li></ul><h1 id="精度丢失分类"><a href="#精度丢失分类" class="headerlink" title="精度丢失分类"></a>精度丢失分类</h1><p>我们上面知道精度丢失的本质是转二进制无限循环,尾数需要截取52导致, 所以</p><ul><li>整数精度丢失: 在尾数范围内的整数因为不需截取,所以不会丢失精度,只有<code>超过安全</code>范围(<code>2^53-1</code>)的整数才会<code>丢失</code>精度</li><li>小数精度丢失: 只要无限循环超过尾数范围,就会丢失精度</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="小数精度丢失"><a href="#小数精度丢失" class="headerlink" title="小数精度丢失"></a>小数精度丢失</h2><h3 id="化整运算"><a href="#化整运算" class="headerlink" title="化整运算"></a>化整运算</h3><blockquote><p>在计算的时候将小数放到10^n变为整数再计算(注意放大可能会超过安全范围),最后再将结果除以10的幂次即可解决精度丢失问题.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">比如 <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> = <span class="hljs-number">0.30000000000000004</span><br><span class="hljs-comment">// 转换</span><br><span class="hljs-number">0.1</span> * <span class="hljs-number">10</span> + <span class="hljs-number">0.2</span> * <span class="hljs-number">10</span> =<span class="hljs-number">3</span><br><span class="hljs-number">3</span> / <span class="hljs-number">10</span> = <span class="hljs-number">0.3</span><br><br>比如 <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span> = <span class="hljs-number">0.21000000000000002</span><br><span class="hljs-comment">// 转换</span><br><span class="hljs-number">0.2</span> * <span class="hljs-number">100</span> + <span class="hljs-number">0.01</span> * <span class="hljs-number">100</span> = <span class="hljs-number">21</span><br><span class="hljs-number">21</span> / <span class="hljs-number">100</span> = <span class="hljs-number">0.21</span><br><br>比如 <span class="hljs-number">0.28</span> + <span class="hljs-number">0.01</span> = <span class="hljs-number">0.29000000000000004</span><br><span class="hljs-comment">// 转换</span><br><span class="hljs-number">0.28</span> * <span class="hljs-number">100</span> + <span class="hljs-number">0.01</span> * <span class="hljs-number">100</span> = <span class="hljs-number">29.000000000000004</span> <span class="hljs-comment">// *100化整不行</span><br><span class="hljs-number">0.28</span> * <span class="hljs-number">1000</span> + <span class="hljs-number">0.01</span> * <span class="hljs-number">1000</span> = <span class="hljs-number">290</span>  <span class="hljs-comment">// *1000化整行</span><br><span class="hljs-number">0.28</span> * <span class="hljs-number">10000</span> + <span class="hljs-number">0.01</span> * <span class="hljs-number">10000</span> = <span class="hljs-number">2900.0000000000005</span> <span class="hljs-comment">// *10000化整又不行</span><br></code></pre></td></tr></table></figure><p>上面例子我们发现:</p><ul><li>取两数的<code>最大尾数</code>做幂次方,可以将每个数都变为<code>整数</code></li><li>但是小数*10^n,因为计算乘法的时候有小数,也会出现精度问题</li></ul><p>所以我们要优先解决乘法精度问题.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> times = <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">let</span> baseNum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> n1 = num1.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> n2 = num2.<span class="hljs-title function_">toString</span>();<br>  baseNum += n1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>]?.<span class="hljs-property">length</span> || <span class="hljs-number">0</span>;<br>  baseNum += n2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>]?.<span class="hljs-property">length</span> || <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> (<br>    (<span class="hljs-title class_">Number</span>(n1.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)) * <span class="hljs-title class_">Number</span>(n2.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))) /<br>    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, baseNum)<br>  );<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">times</span>(<span class="hljs-number">0.28</span>, <span class="hljs-number">100</span>)); <span class="hljs-comment">// 28</span><br></code></pre></td></tr></table></figure><ul><li>乘法精度,我们通过取小数位数之和来做幂次方,将小数点去除计算再除以10的幂次方,来保证乘法精度</li></ul><p>此时我们再计算加法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> plus = <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">let</span> n1 = num1.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">let</span> n2 = num2.<span class="hljs-title function_">toString</span>();<br>  <span class="hljs-keyword">const</span> baseNum1 = n1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>]?.<span class="hljs-property">length</span> || <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> baseNum2 = n2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>]?.<span class="hljs-property">length</span> || <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> baseNum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(baseNum1, baseNum2); <span class="hljs-comment">// 取最大的小数位,保证每个小数都转为整数</span><br>  <span class="hljs-keyword">return</span> (<br>    (<span class="hljs-title function_">times</span>(num1, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, baseNum)) +<br>      <span class="hljs-title function_">times</span>(num2, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, baseNum))) /<br>    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, baseNum)<br>  );<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">plus</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>)); <span class="hljs-comment">// 0.3</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>因为化整肯定要放大,要用乘法,要注意<code>安全范围</code>,超过还是会丢失精度,下面会讲大整数如何处理</li><li>上面只是简单实现,默认当作都有小数点,实际还有指数表示的数字需要判断再split等</li></ul><h3 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed"></a>toFixed</h3><blockquote><p>toFixed(n) 用于将数字格式化为指定小数位数n的字符串表示, 默认n为0</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;0.3&#x27;</span><br></code></pre></td></tr></table></figure><p>这种虽然方便,但是还会有精度问题, 四舍五入不不对.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.35</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1.4 正确</span><br><span class="hljs-number">1.335</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 1.33  错误</span><br><span class="hljs-number">1.3335</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 1.333 错误</span><br><span class="hljs-number">1.33335</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 1.3334 正确</span><br><span class="hljs-number">1.333335</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">5</span>)  <span class="hljs-comment">// 1.33333 错误</span><br><span class="hljs-number">1.3333335</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">6</span>) <span class="hljs-comment">// 1.333333 错误</span><br></code></pre></td></tr></table></figure><p>为什么呢?<br>比如<code>1.005.toFixed(2)= 1.00</code>而不是<code>1.01</code>,实际是因为1.005转换二进制无限循环,会截取52丢失精度,再转换10进制实际是<code>1.0049999999999999</code>,所以不会进1.<br>所以处理精度问题,这种方法无效.</p><h2 id="整数精度丢失"><a href="#整数精度丢失" class="headerlink" title="整数精度丢失"></a>整数精度丢失</h2><p>上面只支持小数处理,大数处理不了,一般第三方库都是采用<code>转字符串</code>处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTwo</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  a = a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>  b = b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">while</span> (a.<span class="hljs-property">length</span> || b.<span class="hljs-property">length</span> || temp) &#123;<br>    temp += <span class="hljs-title class_">Number</span>(a.<span class="hljs-title function_">pop</span>() || <span class="hljs-number">0</span>) + <span class="hljs-title class_">Number</span>(b.<span class="hljs-title function_">pop</span>() || <span class="hljs-number">0</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(temp,<span class="hljs-string">&#x27;temp&#x27;</span>);<br>    <br>    res = (temp % <span class="hljs-number">10</span>) + res;<br>    temp = temp &gt; <span class="hljs-number">9</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^0+/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addTwo</span>(<span class="hljs-string">&#x27;11&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>)); <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><p>上面逻辑就是正常的<code>算数运算</code>, 倒序相加, 逢10进1<br>所以我们可以结合上面2种方法,分别计算整数和小数组合起来即可,最终输出字符串.</p><h2 id="三方库"><a href="#三方库" class="headerlink" title="三方库"></a>三方库</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/MikeMcl/decimal.js">decimal.js</a></li><li><a target="_blank" rel="noopener" href="https://github.com/MikeMcl/bignumber.js">bignumber.js</a></li><li><a target="_blank" rel="noopener" href="https://github.com/nefe/number-precision">number-precision</a> 不能处理超过安全范围数字,会警告超出边界.</li></ul><h1 id="接口返回精度问题"><a href="#接口返回精度问题" class="headerlink" title="接口返回精度问题"></a>接口返回精度问题</h1><ul><li><code>Number.MAX_SAFE_INTEGER=2^53-1=9007199254740991</code>总共16位</li><li>在js中,number只能展示<code>15-17位</code>(整数+小数,两个加起来总共),17位肯定丢失精度,一般至多16位</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/10.jpg" width="50%" height="50%"><p>当后端返回超过16位精度Long类型的数字时,前端直接在控制台看到的已经是<code>丢失精度</code>的数字,因为js引擎就只能处理15-17位,经过json序列化已经丢失精度.我们用postman或者curl是可以看到完整的数字.</p><p><strong>注意:</strong> 如果用express模拟接口,返回的也是丢失精度的,因为nodejs本身就是基于谷歌v8js引擎编译的,nodejs本身就是基于javascript.所以postman或者curl看到的也是丢失精度的.</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>后端返回超过16位精度的数字时,返回成字符串</li><li>前端我们在使用axios时候,通过<code>json-bigint</code>来格式化json<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">JSON</span>big = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;json-bigint&#x27;</span>);<br><span class="hljs-keyword">var</span> json = <span class="hljs-string">&#x27;&#123; &quot;value&quot; : 9223372036854775807.22222, &quot;v2&quot;: 123 &#125;&#x27;</span>;<br><span class="hljs-keyword">var</span> r = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;JSON.parse: &#x27;</span>, r); <span class="hljs-comment">// js自带parse丢失精度</span><br><br><span class="hljs-keyword">var</span> r1 = <span class="hljs-title class_">JSON</span>big.<span class="hljs-title function_">parse</span>(json);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;JSONbig.parse&#x27;</span>, r1); <span class="hljs-comment">// 不丢失精度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1.<span class="hljs-property">value</span>.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 使用某个字段</span><br></code></pre></td></tr></table></figure>运行如下:</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/11.jpg" width="50%" height="50%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">transformResponse</span> = [<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>Big.<span class="hljs-title function_">parse</span>(data)<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-keyword">return</span> data<br>    &#125;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p><strong>注意⚠️</strong>:</p><ul><li>JS 不擅长计算密集型，比如大规模字符串处理或 JSON.parse就属于计算密集型，因为js是单线程,主线程阻塞,导致后续无法执行,并且内存管理等语言方面限制导致不擅长.<br>在使用第三方库时比如<code>json-bigint</code>需要parse会遇到性能问题,如何解决?可以基于一些高性能的库(C、C++、rust)，将计算逻辑抽离打包为 Wasm 给浏览器使用</li></ul><h3 id="json-bigint原理"><a href="#json-bigint原理" class="headerlink" title="json-bigint原理"></a>json-bigint原理</h3><p>我们上面打印知道,经过处理后变成一个新对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> json = <span class="hljs-string">&#x27;&#123; &quot;value&quot; : 9223372036854775807.22222, &quot;v2&quot;: 123 &#125;&#x27;</span>;<br><span class="hljs-comment">// 转换</span><br><span class="hljs-title class_">BigNumber</span> &#123;<br>    <span class="hljs-attr">s</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">e</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">c</span>: [ <span class="hljs-number">92233</span>, <span class="hljs-number">72036854775807</span>, <span class="hljs-number">22222000000000</span> ]<br>  &#125;,<br>  <span class="hljs-attr">v2</span>: <span class="hljs-number">123</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>sign (s)：1（正数）或 -1（负数）</li><li>coefficient (c)：一个数组，存储标准化后的有效数字（整数部分）</li><li>exponent (e)：表示 10 的幂次（科学计数法的指数）</li></ul><p>所以:</p><ul><li>s: 1</li><li>e: 18, 小数点向左移动18位,变成9.22337203685477580722222* 10^18</li><li>c: 从右向左,逢14位分段,为什么是14位,因为js最大能表示15-17,选择14能保证安全.</li></ul><h1 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h1><p>我们知道js的number会丢失精度, 所以在ES2020中,引入了BigInt类型,用来解决精度丢失问题,但是只能用在整数上,不能用在浮点数上.</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/12.jpg" width="50%" height="50%"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="images/13.jpg" width="50%" height="50%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> num=<span class="hljs-number">9007199254740993</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 9007199254740992</span><br><span class="hljs-comment">// 字面量表示</span><br><span class="hljs-keyword">const</span> a=<span class="hljs-number">9007199254740993n</span><br><span class="hljs-keyword">const</span> b= <span class="hljs-title class_">BigInt</span>(num) <br><span class="hljs-keyword">const</span> c= <span class="hljs-title class_">BigInt</span>(<span class="hljs-string">&#x27;9007199254740993&#x27;</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c); <span class="hljs-comment">// 9007199254740993n 9007199254740992n 9007199254740993n</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toString</span>(),b.<span class="hljs-title function_">toString</span>(),c.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 9007199254740993 9007199254740992 9007199254740993</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a)); <span class="hljs-comment">// 报错 Uncaught TypeError: Do not know how to serialize a BigInt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b+<span class="hljs-number">1</span>) <span class="hljs-comment">// 运行时报错 Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1.</span><span class="hljs-number">1n</span>) <span class="hljs-comment">// 直接语法错误,标红,运行提示格式不对</span><br></code></pre></td></tr></table></figure><ul><li>字面量创建,如果直接传number还是会丢失精度,需要传字符串</li><li>bigint不能和number类型混用</li><li>只能表示整数,不能表示小数,直接语法就标红错误,运行提示格式不对</li><li>不能json序列化,所以前后端交互,需要toString给后端,后端返回还要再转biginit使用,那为啥不直接用string, 目前想到的可能是使用bigint可以计算,字符串就是拼接了.如果只是展示建议字符串即可.</li></ul><blockquote><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7216917459009536060?searchId=20250408134251801C24E75685AB51D3BB">保姆级讲解JS精度丢失问题(图文结合)</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7293738741397700642?searchId=20250415143831D59A749BBCE599D62B80">js实现高精度加减乘除模板</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mystylemylife.github.io/ypf-blog">ypf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mystylemylife.github.io/ypf-blog/2025/04/09/javascript/js%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/">https://mystylemylife.github.io/ypf-blog/2025/04/09/javascript/js%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mystylemylife.github.io/ypf-blog" target="_blank">ypf的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/ypf-blog/2025/04/07/webpack4/12.hmr/" title="12.hmr"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">12.hmr</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90"><span class="toc-number">1.</span> <span class="toc-text">问题来源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">整数十进制转二进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">小数十进制转二进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">整数二进制转十进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-number">2.2.4.</span> <span class="toc-text">小数二进制转十进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%8E%9F%E7%94%9F%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.5.</span> <span class="toc-text">js原生转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">进制转换总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">科学计数法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E6%89%93%E5%8D%B0%E6%8C%87%E6%95%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">js原生方法打印指数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">浮点数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">指数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">偏移量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%90%AB%E5%AD%98%E5%82%A81"><span class="toc-number">3.3.</span> <span class="toc-text">隐含存储1.</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">js浮点数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7-%E5%B0%8F%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">最大&#x2F;小数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7-%E6%9C%80%E5%B0%8F%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">最大&#x2F;最小安全整数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">精度丢失过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E5%88%86%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">精度丢失分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-number">7.1.</span> <span class="toc-text">小数精度丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%96%E6%95%B4%E8%BF%90%E7%AE%97"><span class="toc-number">7.1.1.</span> <span class="toc-text">化整运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toFixed"><span class="toc-number">7.1.2.</span> <span class="toc-text">toFixed</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-number">7.2.</span> <span class="toc-text">整数精度丢失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-number">7.3.</span> <span class="toc-text">三方库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">接口返回精度问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">8.1.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#json-bigint%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.1.</span> <span class="toc-text">json-bigint原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BigInt"><span class="toc-number">9.</span> <span class="toc-text">BigInt</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By ypf</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@4.13.0/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@4.13.0/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/gh/mystylemylife/ypf-blog/assets/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/mystylemylife/ypf-blog/assets/js/code-collapse.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@4.13.0/source/js/search/local-search.min.js"></script></div></div></body></html>